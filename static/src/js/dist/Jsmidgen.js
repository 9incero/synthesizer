/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/jsmidgen.js":
/*!****************************!*\
  !*** ./src/js/jsmidgen.js ***!
  \****************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar Midi = {};\r\n\r\n(function (exported) {\r\n  var DEFAULT_VOLUME = (exported.DEFAULT_VOLUME = 90);\r\n  var DEFAULT_DURATION = (exported.DEFAULT_DURATION = 128);\r\n  var DEFAULT_CHANNEL = (exported.DEFAULT_CHANNEL = 0);\r\n\r\n  /* ******************************************************************\r\n   * Utility functions\r\n   ****************************************************************** */\r\n\r\n  var Util = {\r\n    midi_letter_pitches: { a: 21, b: 23, c: 12, d: 14, e: 16, f: 17, g: 19 },\r\n\r\n    /**\r\n     * Convert a symbolic note name (e.g. \"c4\") to a numeric MIDI pitch (e.g.\r\n     * 60, middle C).\r\n     *\r\n     * @param {string} n - The symbolic note name to parse.\r\n     * @returns {number} The MIDI pitch that corresponds to the symbolic note\r\n     * name.\r\n     */\r\n    midiPitchFromNote: function (n) {\r\n      var matches = /([a-g])(#+|b+)?([0-9]+)$/i.exec(n);\r\n      var note = matches[1].toLowerCase(),\r\n        accidental = matches[2] || \"\",\r\n        octave = parseInt(matches[3], 10);\r\n      return (\r\n        12 * octave +\r\n        Util.midi_letter_pitches[note] +\r\n        (accidental.substr(0, 1) == \"#\" ? 1 : -1) * accidental.length\r\n      );\r\n    },\r\n\r\n    /**\r\n     * Ensure that the given argument is converted to a MIDI pitch. Note that\r\n     * it may already be one (including a purely numeric string).\r\n     *\r\n     * @param {string|number} p - The pitch to convert.\r\n     * @returns {number} The resulting numeric MIDI pitch.\r\n     */\r\n    ensureMidiPitch: function (p) {\r\n      if (typeof p == \"number\" || !/[^0-9]/.test(p)) {\r\n        // numeric pitch\r\n        return parseInt(p, 10);\r\n      } else {\r\n        // assume it's a note name\r\n        return Util.midiPitchFromNote(p);\r\n      }\r\n    },\r\n\r\n    midi_pitches_letter: {\r\n      12: \"c\",\r\n      13: \"c#\",\r\n      14: \"d\",\r\n      15: \"d#\",\r\n      16: \"e\",\r\n      17: \"f\",\r\n      18: \"f#\",\r\n      19: \"g\",\r\n      20: \"g#\",\r\n      21: \"a\",\r\n      22: \"a#\",\r\n      23: \"b\",\r\n    },\r\n    midi_flattened_notes: {\r\n      \"a#\": \"bb\",\r\n      \"c#\": \"db\",\r\n      \"d#\": \"eb\",\r\n      \"f#\": \"gb\",\r\n      \"g#\": \"ab\",\r\n    },\r\n\r\n    /**\r\n     * Convert a numeric MIDI pitch value (e.g. 60) to a symbolic note name\r\n     * (e.g. \"c4\").\r\n     *\r\n     * @param {number} n - The numeric MIDI pitch value to convert.\r\n     * @param {boolean} [returnFlattened=false] - Whether to prefer flattened\r\n     * notes to sharpened ones. Optional, default false.\r\n     * @returns {string} The resulting symbolic note name.\r\n     */\r\n    noteFromMidiPitch: function (n, returnFlattened) {\r\n      var octave = 0,\r\n        noteNum = n,\r\n        noteName,\r\n        returnFlattened = returnFlattened || false;\r\n      if (n > 23) {\r\n        // noteNum is on octave 1 or more\r\n        octave = Math.floor(n / 12) - 1;\r\n        // subtract number of octaves from noteNum\r\n        noteNum = n - octave * 12;\r\n      }\r\n\r\n      // get note name (c#, d, f# etc)\r\n      noteName = Util.midi_pitches_letter[noteNum];\r\n      // Use flattened notes if requested (e.g. f# should be output as gb)\r\n      if (returnFlattened && noteName.indexOf(\"#\") > 0) {\r\n        noteName = Util.midi_flattened_notes[noteName];\r\n      }\r\n      return noteName + octave;\r\n    },\r\n\r\n    /**\r\n     * Convert beats per minute (BPM) to microseconds per quarter note (MPQN).\r\n     *\r\n     * @param {number} bpm - A number in beats per minute.\r\n     * @returns {number} The number of microseconds per quarter note.\r\n     */\r\n    mpqnFromBpm: function (bpm) {\r\n      var mpqn = Math.floor(60000000 / bpm);\r\n      var ret = [];\r\n      do {\r\n        ret.unshift(mpqn & 0xff);\r\n        mpqn >>= 8;\r\n      } while (mpqn);\r\n      while (ret.length < 3) {\r\n        ret.push(0);\r\n      }\r\n      return ret;\r\n    },\r\n\r\n    /**\r\n     * Convert microseconds per quarter note (MPQN) to beats per minute (BPM).\r\n     *\r\n     * @param {number} mpqn - The number of microseconds per quarter note.\r\n     * @returns {number} A number in beats per minute.\r\n     */\r\n    bpmFromMpqn: function (mpqn) {\r\n      var m = mpqn;\r\n      if (typeof mpqn[0] != \"undefined\") {\r\n        m = 0;\r\n        for (var i = 0, l = mpqn.length - 1; l >= 0; ++i, --l) {\r\n          m |= mpqn[i] << l;\r\n        }\r\n      }\r\n      return Math.floor(60000000 / mpqn);\r\n    },\r\n\r\n    /**\r\n     * Converts an array of bytes to a string of hexadecimal characters. Prepares\r\n     * it to be converted into a base64 string.\r\n     *\r\n     * @param {Array} byteArray - Array of bytes to be converted.\r\n     * @returns {string} Hexadecimal string, e.g. \"097B8A\".\r\n     */\r\n    codes2Str: function (byteArray) {\r\n      return String.fromCharCode.apply(null, byteArray);\r\n    },\r\n\r\n    /**\r\n     * Converts a string of hexadecimal values to an array of bytes. It can also\r\n     * add remaining \"0\" nibbles in order to have enough bytes in the array as the\r\n     * `finalBytes` parameter.\r\n     *\r\n     * @param {string} str - string of hexadecimal values e.g. \"097B8A\"\r\n     * @param {number} [finalBytes] - Optional. The desired number of bytes\r\n     * (not nibbles) that the returned array should contain.\r\n     * @returns {Array} An array of nibbles.\r\n     */\r\n    str2Bytes: function (str, finalBytes) {\r\n      if (finalBytes) {\r\n        while (str.length / 2 < finalBytes) {\r\n          str = \"0\" + str;\r\n        }\r\n      }\r\n\r\n      var bytes = [];\r\n      for (var i = str.length - 1; i >= 0; i = i - 2) {\r\n        var chars = i === 0 ? str[i] : str[i - 1] + str[i];\r\n        bytes.unshift(parseInt(chars, 16));\r\n      }\r\n\r\n      return bytes;\r\n    },\r\n\r\n    /**\r\n     * Translates number of ticks to MIDI timestamp format, returning an array\r\n     * of bytes with the time values. MIDI has a very particular way to express\r\n     * time; take a good look at the spec before ever touching this function.\r\n     *\r\n     * @param {number} ticks - Number of ticks to be translated.\r\n     * @returns {number} Array of bytes that form the MIDI time value.\r\n     */\r\n    translateTickTime: function (ticks) {\r\n      var buffer = ticks & 0x7f;\r\n\r\n      while ((ticks = ticks >> 7)) {\r\n        buffer <<= 8;\r\n        buffer |= (ticks & 0x7f) | 0x80;\r\n      }\r\n\r\n      var bList = [];\r\n      while (true) {\r\n        bList.push(buffer & 0xff);\r\n\r\n        if (buffer & 0x80) {\r\n          buffer >>= 8;\r\n        } else {\r\n          break;\r\n        }\r\n      }\r\n      return bList;\r\n    },\r\n  };\r\n\r\n  /* ******************************************************************\r\n   * Event class\r\n   ****************************************************************** */\r\n\r\n  /**\r\n   * Construct a MIDI event.\r\n   *\r\n   * Parameters include:\r\n   *  - time [optional number] - Ticks since previous event.\r\n   *  - type [required number] - Type of event.\r\n   *  - channel [required number] - Channel for the event.\r\n   *  - param1 [required number] - First event parameter.\r\n   *  - param2 [optional number] - Second event parameter.\r\n   */\r\n  var MidiEvent = function (params) {\r\n    if (!this) return new MidiEvent(params);\r\n    if (\r\n      params &&\r\n      (params.type !== null || params.type !== undefined) &&\r\n      (params.channel !== null || params.channel !== undefined) &&\r\n      (params.param1 !== null || params.param1 !== undefined)\r\n    ) {\r\n      this.setTime(params.time);\r\n      this.setType(params.type);\r\n      this.setChannel(params.channel);\r\n      this.setParam1(params.param1);\r\n      this.setParam2(params.param2);\r\n    }\r\n  };\r\n\r\n  // event codes\r\n  MidiEvent.NOTE_OFF = 0x80;\r\n  MidiEvent.NOTE_ON = 0x90;\r\n  MidiEvent.AFTER_TOUCH = 0xa0;\r\n  MidiEvent.CONTROLLER = 0xb0;\r\n  MidiEvent.PROGRAM_CHANGE = 0xc0;\r\n  MidiEvent.CHANNEL_AFTERTOUCH = 0xd0;\r\n  MidiEvent.PITCH_BEND = 0xe0;\r\n\r\n  /**\r\n   * Set the time for the event in ticks since the previous event.\r\n   *\r\n   * @param {number} ticks - The number of ticks since the previous event. May\r\n   * be zero.\r\n   */\r\n  MidiEvent.prototype.setTime = function (ticks) {\r\n    this.time = Util.translateTickTime(ticks || 0);\r\n  };\r\n\r\n  /**\r\n   * Set the type of the event. Must be one of the event codes on MidiEvent.\r\n   *\r\n   * @param {number} type - Event type.\r\n   */\r\n  MidiEvent.prototype.setType = function (type) {\r\n    if (type < MidiEvent.NOTE_OFF || type > MidiEvent.PITCH_BEND) {\r\n      throw new Error(\"Trying to set an unknown event: \" + type);\r\n    }\r\n\r\n    this.type = type;\r\n  };\r\n\r\n  /**\r\n   * Set the channel for the event. Must be between 0 and 15, inclusive.\r\n   *\r\n   * @param {number} channel - The event channel.\r\n   */\r\n  MidiEvent.prototype.setChannel = function (channel) {\r\n    if (channel < 0 || channel > 15) {\r\n      throw new Error(\"Channel is out of bounds.\");\r\n    }\r\n\r\n    this.channel = channel;\r\n  };\r\n\r\n  /**\r\n   * Set the first parameter for the event. Must be between 0 and 255,\r\n   * inclusive.\r\n   *\r\n   * @param {number} p - The first event parameter value.\r\n   */\r\n  MidiEvent.prototype.setParam1 = function (p) {\r\n    this.param1 = p;\r\n  };\r\n\r\n  /**\r\n   * Set the second parameter for the event. Must be between 0 and 255,\r\n   * inclusive.\r\n   *\r\n   * @param {number} p - The second event parameter value.\r\n   */\r\n  MidiEvent.prototype.setParam2 = function (p) {\r\n    this.param2 = p;\r\n  };\r\n\r\n  /**\r\n   * Serialize the event to an array of bytes.\r\n   *\r\n   * @returns {Array} The array of serialized bytes.\r\n   */\r\n  MidiEvent.prototype.toBytes = function () {\r\n    var byteArray = [];\r\n\r\n    var typeChannelByte = this.type | (this.channel & 0xf);\r\n\r\n    byteArray.push.apply(byteArray, this.time);\r\n    byteArray.push(typeChannelByte);\r\n    byteArray.push(this.param1);\r\n\r\n    // Some events don't have a second parameter\r\n    if (this.param2 !== undefined && this.param2 !== null) {\r\n      byteArray.push(this.param2);\r\n    }\r\n    return byteArray;\r\n  };\r\n\r\n  /* ******************************************************************\r\n   * MetaEvent class\r\n   ****************************************************************** */\r\n\r\n  /**\r\n   * Construct a meta event.\r\n   *\r\n   * Parameters include:\r\n   *  - time [optional number] - Ticks since previous event.\r\n   *  - type [required number] - Type of event.\r\n   *  - data [optional array|string] - Event data.\r\n   */\r\n  var MetaEvent = function (params) {\r\n    if (!this) return new MetaEvent(params);\r\n    var p = params || {};\r\n    this.setTime(params.time);\r\n    this.setType(params.type);\r\n    this.setData(params.data);\r\n  };\r\n\r\n  MetaEvent.SEQUENCE = 0x00;\r\n  MetaEvent.TEXT = 0x01;\r\n  MetaEvent.COPYRIGHT = 0x02;\r\n  MetaEvent.TRACK_NAME = 0x03;\r\n  MetaEvent.INSTRUMENT = 0x04;\r\n  MetaEvent.LYRIC = 0x05;\r\n  MetaEvent.MARKER = 0x06;\r\n  MetaEvent.CUE_POINT = 0x07;\r\n  MetaEvent.CHANNEL_PREFIX = 0x20;\r\n  MetaEvent.END_OF_TRACK = 0x2f;\r\n  MetaEvent.TEMPO = 0x51;\r\n  MetaEvent.SMPTE = 0x54;\r\n  MetaEvent.TIME_SIG = 0x58;\r\n  MetaEvent.KEY_SIG = 0x59;\r\n  MetaEvent.SEQ_EVENT = 0x7f;\r\n\r\n  /**\r\n   * Set the time for the event in ticks since the previous event.\r\n   *\r\n   * @param {number} ticks - The number of ticks since the previous event. May\r\n   * be zero.\r\n   */\r\n  MetaEvent.prototype.setTime = function (ticks) {\r\n    this.time = Util.translateTickTime(ticks || 0);\r\n  };\r\n\r\n  /**\r\n   * Set the type of the event. Must be one of the event codes on MetaEvent.\r\n   *\r\n   * @param {number} t - Event type.\r\n   */\r\n  MetaEvent.prototype.setType = function (t) {\r\n    this.type = t;\r\n  };\r\n\r\n  /**\r\n   * Set the data associated with the event. May be a string or array of byte\r\n   * values.\r\n   *\r\n   * @param {string|Array} d - Event data.\r\n   */\r\n  MetaEvent.prototype.setData = function (d) {\r\n    this.data = d;\r\n  };\r\n\r\n  /**\r\n   * Serialize the event to an array of bytes.\r\n   *\r\n   * @returns {Array} The array of serialized bytes.\r\n   */\r\n  MetaEvent.prototype.toBytes = function () {\r\n    if (!this.type) {\r\n      throw new Error(\"Type for meta-event not specified.\");\r\n    }\r\n\r\n    var byteArray = [];\r\n    byteArray.push.apply(byteArray, this.time);\r\n    byteArray.push(0xff, this.type);\r\n\r\n    // If data is an array, we assume that it contains several bytes. We\r\n    // apend them to byteArray.\r\n    if (Array.isArray(this.data)) {\r\n      byteArray.push(this.data.length);\r\n      byteArray.push.apply(byteArray, this.data);\r\n    } else if (typeof this.data == \"number\") {\r\n      byteArray.push(1, this.data);\r\n    } else if (this.data !== null && this.data !== undefined) {\r\n      // assume string; may be a bad assumption\r\n      byteArray.push(this.data.length);\r\n      var dataBytes = this.data.split(\"\").map(function (x) {\r\n        return x.charCodeAt(0);\r\n      });\r\n      byteArray.push.apply(byteArray, dataBytes);\r\n    } else {\r\n      byteArray.push(0);\r\n    }\r\n\r\n    return byteArray;\r\n  };\r\n\r\n  /* ******************************************************************\r\n   * Track class\r\n   ****************************************************************** */\r\n\r\n  /**\r\n   * Construct a MIDI track.\r\n   *\r\n   * Parameters include:\r\n   *  - events [optional array] - Array of events for the track.\r\n   */\r\n  var Track = function (config) {\r\n    if (!this) return new Track(config);\r\n    var c = config || {};\r\n    this.events = c.events || [];\r\n  };\r\n\r\n  Track.START_BYTES = [0x4d, 0x54, 0x72, 0x6b];\r\n  Track.END_BYTES = [0x00, 0xff, 0x2f, 0x00];\r\n\r\n  /**\r\n   * Add an event to the track.\r\n   *\r\n   * @param {MidiEvent|MetaEvent} event - The event to add.\r\n   * @returns {Track} The current track.\r\n   */\r\n  Track.prototype.addEvent = function (event) {\r\n    this.events.push(event);\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Add a note-on event to the track.\r\n   *\r\n   * @param {number} channel - The channel to add the event to.\r\n   * @param {number|string} pitch - The pitch of the note, either numeric or\r\n   * symbolic.\r\n   * @param {number} [time=0] - The number of ticks since the previous event,\r\n   * defaults to 0.\r\n   * @param {number} [velocity=90] - The volume for the note, defaults to\r\n   * DEFAULT_VOLUME.\r\n   * @returns {Track} The current track.\r\n   */\r\n  Track.prototype.addNoteOn = Track.prototype.noteOn = function (\r\n    channel,\r\n    pitch,\r\n    time,\r\n    velocity\r\n  ) {\r\n    this.events.push(\r\n      new MidiEvent({\r\n        type: MidiEvent.NOTE_ON,\r\n        channel: channel,\r\n        param1: Util.ensureMidiPitch(pitch),\r\n        param2: velocity || DEFAULT_VOLUME,\r\n        time: time || 0,\r\n      })\r\n    );\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Add a note-off event to the track.\r\n   *\r\n   * @param {number} channel - The channel to add the event to.\r\n   * @param {number|string} pitch - The pitch of the note, either numeric or\r\n   * symbolic.\r\n   * @param {number} [time=0] - The number of ticks since the previous event,\r\n   * defaults to 0.\r\n   * @param {number} [velocity=90] - The velocity the note was released,\r\n   * defaults to DEFAULT_VOLUME.\r\n   * @returns {Track} The current track.\r\n   */\r\n  Track.prototype.addNoteOff = Track.prototype.noteOff = function (\r\n    channel,\r\n    pitch,\r\n    time,\r\n    velocity\r\n  ) {\r\n    this.events.push(\r\n      new MidiEvent({\r\n        type: MidiEvent.NOTE_OFF,\r\n        channel: channel,\r\n        param1: Util.ensureMidiPitch(pitch),\r\n        param2: velocity || DEFAULT_VOLUME,\r\n        time: time || 0,\r\n      })\r\n    );\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Add a note-on and -off event to the track.\r\n   *\r\n   * @param {number} channel - The channel to add the event to.\r\n   * @param {number|string} pitch - The pitch of the note, either numeric or\r\n   * symbolic.\r\n   * @param {number} dur - The duration of the note, in ticks.\r\n   * @param {number} [time=0] - The number of ticks since the previous event,\r\n   * defaults to 0.\r\n   * @param {number} [velocity=90] - The velocity the note was released,\r\n   * defaults to DEFAULT_VOLUME.\r\n   * @returns {Track} The current track.\r\n   */\r\n  Track.prototype.addNote = Track.prototype.note = function (\r\n    channel,\r\n    pitch,\r\n    dur,\r\n    time,\r\n    velocity\r\n  ) {\r\n    this.noteOn(channel, pitch, time, velocity);\r\n    if (dur) {\r\n      this.noteOff(channel, pitch, dur, velocity);\r\n    }\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Add a note-on and -off event to the track for each pitch in an array of pitches.\r\n   *\r\n   * @param {number} channel - The channel to add the event to.\r\n   * @param {array} chord - An array of pitches, either numeric or\r\n   * symbolic.\r\n   * @param {number} dur - The duration of the chord, in ticks.\r\n   * @param {number} [velocity=90] - The velocity of the chord,\r\n   * defaults to DEFAULT_VOLUME.\r\n   * @returns {Track} The current track.\r\n   */\r\n  Track.prototype.addChord = Track.prototype.chord = function (\r\n    channel,\r\n    chord,\r\n    dur,\r\n    velocity\r\n  ) {\r\n    if (!Array.isArray(chord) && !chord.length) {\r\n      throw new Error(\"Chord must be an array of pitches\");\r\n    }\r\n    chord.forEach(function (note) {\r\n      this.noteOn(channel, note, 0, velocity);\r\n    }, this);\r\n    chord.forEach(function (note, index) {\r\n      if (index === 0) {\r\n        this.noteOff(channel, note, dur);\r\n      } else {\r\n        this.noteOff(channel, note);\r\n      }\r\n    }, this);\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Set instrument for the track.\r\n   *\r\n   * @param {number} channel - The channel to set the instrument on.\r\n   * @param {number} instrument - The instrument to set it to.\r\n   * @param {number} [time=0] - The number of ticks since the previous event,\r\n   * defaults to 0.\r\n   * @returns {Track} The current track.\r\n   */\r\n  Track.prototype.setInstrument = Track.prototype.instrument = function (\r\n    channel,\r\n    instrument,\r\n    time\r\n  ) {\r\n    this.events.push(\r\n      new MidiEvent({\r\n        type: MidiEvent.PROGRAM_CHANGE,\r\n        channel: channel,\r\n        param1: instrument,\r\n        time: time || 0,\r\n      })\r\n    );\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Set the tempo for the track.\r\n   *\r\n   * @param {number} bpm - The new number of beats per minute.\r\n   * @param {number} [time=0] - The number of ticks since the previous event,\r\n   * defaults to 0.\r\n   * @returns {Track} The current track.\r\n   */\r\n  Track.prototype.setTempo = Track.prototype.tempo = function (bpm, time) {\r\n    this.events.push(\r\n      new MetaEvent({\r\n        type: MetaEvent.TEMPO,\r\n        data: Util.mpqnFromBpm(bpm),\r\n        time: time || 0,\r\n      })\r\n    );\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Serialize the track to an array of bytes.\r\n   *\r\n   * @returns {Array} The array of serialized bytes.\r\n   */\r\n  Track.prototype.toBytes = function () {\r\n    var trackLength = 0;\r\n    var eventBytes = [];\r\n    var startBytes = Track.START_BYTES;\r\n    var endBytes = Track.END_BYTES;\r\n\r\n    var addEventBytes = function (event) {\r\n      var bytes = event.toBytes();\r\n      trackLength += bytes.length;\r\n      eventBytes.push.apply(eventBytes, bytes);\r\n    };\r\n\r\n    this.events.forEach(addEventBytes);\r\n\r\n    // Add the end-of-track bytes to the sum of bytes for the track, since\r\n    // they are counted (unlike the start-of-track ones).\r\n    trackLength += endBytes.length;\r\n\r\n    // Makes sure that track length will fill up 4 bytes with 0s in case\r\n    // the length is less than that (the usual case).\r\n    var lengthBytes = Util.str2Bytes(trackLength.toString(16), 4);\r\n\r\n    return startBytes.concat(lengthBytes, eventBytes, endBytes);\r\n  };\r\n\r\n  /* ******************************************************************\r\n   * File class\r\n   ****************************************************************** */\r\n\r\n  /**\r\n   * Construct a file object.\r\n   *\r\n   * Parameters include:\r\n   *  - ticks [optional number] - Number of ticks per beat, defaults to 128.\r\n   *    Must be 1-32767.\r\n   *  - tracks [optional array] - Track data.\r\n   */\r\n  var File = function (config) {\r\n    if (!this) return new File(config);\r\n\r\n    var c = config || {};\r\n    if (c.ticks) {\r\n      if (typeof c.ticks !== \"number\") {\r\n        throw new Error(\"Ticks per beat must be a number!\");\r\n        return;\r\n      }\r\n      if (c.ticks <= 0 || c.ticks >= 1 << 15 || c.ticks % 1 !== 0) {\r\n        throw new Error(\r\n          \"Ticks per beat must be an integer between 1 and 32767!\"\r\n        );\r\n        return;\r\n      }\r\n    }\r\n\r\n    this.ticks = c.ticks || 128;\r\n    this.tracks = c.tracks || [];\r\n  };\r\n\r\n  File.HDR_CHUNKID = \"MThd\"; // File magic cookie\r\n  File.HDR_CHUNK_SIZE = \"\\x00\\x00\\x00\\x06\"; // Header length for SMF\r\n  File.HDR_TYPE0 = \"\\x00\\x00\"; // Midi Type 0 id\r\n  File.HDR_TYPE1 = \"\\x00\\x01\"; // Midi Type 1 id\r\n\r\n  /**\r\n   * Add a track to the file.\r\n   *\r\n   * @param {Track} track - The track to add.\r\n   */\r\n  File.prototype.addTrack = function (track) {\r\n    if (track) {\r\n      this.tracks.push(track);\r\n      return this;\r\n    } else {\r\n      track = new Track();\r\n      this.tracks.push(track);\r\n      return track;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Serialize the MIDI file to an array of bytes.\r\n   *\r\n   * @returns {Array} The array of serialized bytes.\r\n   */\r\n  File.prototype.toBytes = function () {\r\n    var trackCount = this.tracks.length.toString(16);\r\n\r\n    // prepare the file header\r\n    var bytes = File.HDR_CHUNKID + File.HDR_CHUNK_SIZE;\r\n\r\n    // set Midi type based on number of tracks\r\n    if (parseInt(trackCount, 16) > 1) {\r\n      bytes += File.HDR_TYPE1;\r\n    } else {\r\n      bytes += File.HDR_TYPE0;\r\n    }\r\n\r\n    // add the number of tracks (2 bytes)\r\n    bytes += Util.codes2Str(Util.str2Bytes(trackCount, 2));\r\n    // add the number of ticks per beat (currently hardcoded)\r\n    bytes += String.fromCharCode(this.ticks / 256, this.ticks % 256);\r\n\r\n    // iterate over the tracks, converting to bytes too\r\n    this.tracks.forEach(function (track) {\r\n      bytes += Util.codes2Str(track.toBytes());\r\n    });\r\n\r\n    return bytes;\r\n  };\r\n\r\n  /* ******************************************************************\r\n   * Exports\r\n   ****************************************************************** */\r\n\r\n  exported.Util = Util;\r\n  exported.File = File;\r\n  exported.Track = Track;\r\n  exported.Event = MidiEvent;\r\n  exported.MetaEvent = MetaEvent;\r\n})(Midi);\r\n\r\nif ( true && module !== null) {\r\n  module.exports = Midi;\r\n} else if ( true && exports !== null) {\r\n  exports = Midi;\r\n} else {\r\n  this.Midi = Midi;\r\n}\r\n\n\n//# sourceURL=webpack://Synthesizer/./src/js/jsmidgen.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/jsmidgen.js");
/******/ 	
/******/ })()
;