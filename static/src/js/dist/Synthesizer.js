/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../node_modules/adsr/index.js":
/*!*************************************!*\
  !*** ../node_modules/adsr/index.js ***!
  \*************************************/
/***/ ((module) => {

eval("module.exports = ADSR\r\n\r\nfunction ADSR(audioContext){\r\n  var node = audioContext.createGain()\r\n\r\n  var voltage = node._voltage = getVoltage(audioContext)\r\n  var value = scale(voltage)\r\n  var startValue = scale(voltage)\r\n  var endValue = scale(voltage)\r\n\r\n  node._startAmount = scale(startValue)\r\n  node._endAmount = scale(endValue)\r\n\r\n  node._multiplier = scale(value)\r\n  node._multiplier.connect(node)\r\n  node._startAmount.connect(node)\r\n  node._endAmount.connect(node)\r\n\r\n  node.value = value.gain\r\n  node.startValue = startValue.gain\r\n  node.endValue = endValue.gain\r\n\r\n  node.startValue.value = 0\r\n  node.endValue.value = 0\r\n\r\n  Object.defineProperties(node, props)\r\n  return node\r\n}\r\n\r\nvar props = {\r\n\r\n  attack: { value: 0, writable: true },\r\n  decay: { value: 0, writable: true },\r\n  sustain: { value: 1, writable: true },\r\n  release: {value: 0, writable: true },\r\n\r\n  getReleaseDuration: {\r\n    value: function(){\r\n      return this.release\r\n    }\r\n  },\r\n\r\n  start: {\r\n    value: function(at){\r\n      var target = this._multiplier.gain\r\n      var startAmount = this._startAmount.gain\r\n      var endAmount = this._endAmount.gain\r\n\r\n      this._voltage.start(at)\r\n      this._decayFrom = this._decayFrom = at+this.attack\r\n      this._startedAt = at\r\n\r\n      var sustain = this.sustain\r\n\r\n      target.cancelScheduledValues(at)\r\n      startAmount.cancelScheduledValues(at)\r\n      endAmount.cancelScheduledValues(at)\r\n\r\n      endAmount.setValueAtTime(0, at)\r\n\r\n      if (this.attack){\r\n        target.setValueAtTime(0, at)\r\n        target.linearRampToValueAtTime(1, at + this.attack)\r\n\r\n        startAmount.setValueAtTime(1, at)\r\n        startAmount.linearRampToValueAtTime(0, at + this.attack)\r\n      } else {\r\n        target.setValueAtTime(1, at)\r\n        startAmount.setValueAtTime(0, at)\r\n      }\r\n\r\n      if (this.decay){\r\n        target.setTargetAtTime(sustain, this._decayFrom, getTimeConstant(this.decay))\r\n      }\r\n    }\r\n  },\r\n\r\n  stop: {\r\n    value: function(at, isTarget){\r\n      if (isTarget){\r\n        at = at - this.release\r\n      }\r\n\r\n      var endTime = at + this.release\r\n      if (this.release){\r\n\r\n        var target = this._multiplier.gain\r\n        var startAmount = this._startAmount.gain\r\n        var endAmount = this._endAmount.gain\r\n\r\n        target.cancelScheduledValues(at)\r\n        startAmount.cancelScheduledValues(at)\r\n        endAmount.cancelScheduledValues(at)\r\n\r\n        var expFalloff = getTimeConstant(this.release)\r\n\r\n        // truncate attack (required as linearRamp is removed by cancelScheduledValues)\r\n        if (this.attack && at < this._decayFrom){\r\n          var valueAtTime = getValue(0, 1, this._startedAt, this._decayFrom, at)\r\n          target.linearRampToValueAtTime(valueAtTime, at)\r\n          startAmount.linearRampToValueAtTime(1-valueAtTime, at)\r\n          startAmount.setTargetAtTime(0, at, expFalloff)\r\n        }\r\n\r\n        endAmount.setTargetAtTime(1, at, expFalloff)\r\n        target.setTargetAtTime(0, at, expFalloff)\r\n      }\r\n\r\n      this._voltage.stop(endTime)\r\n      return endTime\r\n    }\r\n  },\r\n\r\n  onended: {\r\n    get: function(){\r\n      return this._voltage.onended\r\n    },\r\n    set: function(value){\r\n      this._voltage.onended = value\r\n    }\r\n  }\r\n\r\n}\r\n\r\nvar flat = new Float32Array([1,1])\r\nfunction getVoltage(context){\r\n  var voltage = context.createBufferSource()\r\n  var buffer = context.createBuffer(1, 2, context.sampleRate)\r\n  buffer.getChannelData(0).set(flat)\r\n  voltage.buffer = buffer\r\n  voltage.loop = true\r\n  return voltage\r\n}\r\n\r\nfunction scale(node){\r\n  var gain = node.context.createGain()\r\n  node.connect(gain)\r\n  return gain\r\n}\r\n\r\nfunction getTimeConstant(time){\r\n  return Math.log(time+1)/Math.log(100)\r\n}\r\n\r\nfunction getValue(start, end, fromTime, toTime, at){\r\n  var difference = end - start\r\n  var time = toTime - fromTime\r\n  var truncateTime = at - fromTime\r\n  var phase = truncateTime / time\r\n  var value = start + phase * difference\r\n\r\n  if (value <= start) {\r\n      value = start\r\n  }\r\n  if (value >= end) {\r\n      value = end\r\n  }\r\n\r\n  return value\r\n}\r\n\n\n//# sourceURL=webpack://Synthesizer/../node_modules/adsr/index.js?");

/***/ }),

/***/ "../node_modules/audio-loader/lib/base64.js":
/*!**************************************************!*\
  !*** ../node_modules/audio-loader/lib/base64.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";
eval("\r\n\r\n// DECODE UTILITIES\r\nfunction b64ToUint6 (nChr) {\r\n  return nChr > 64 && nChr < 91 ? nChr - 65\r\n    : nChr > 96 && nChr < 123 ? nChr - 71\r\n    : nChr > 47 && nChr < 58 ? nChr + 4\r\n    : nChr === 43 ? 62\r\n    : nChr === 47 ? 63\r\n    : 0\r\n}\r\n\r\n// Decode Base64 to Uint8Array\r\n// ---------------------------\r\nfunction decode (sBase64, nBlocksSize) {\r\n  var sB64Enc = sBase64.replace(/[^A-Za-z0-9\\+\\/]/g, '')\r\n  var nInLen = sB64Enc.length\r\n  var nOutLen = nBlocksSize\r\n    ? Math.ceil((nInLen * 3 + 1 >> 2) / nBlocksSize) * nBlocksSize\r\n    : nInLen * 3 + 1 >> 2\r\n  var taBytes = new Uint8Array(nOutLen)\r\n\r\n  for (var nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0; nInIdx < nInLen; nInIdx++) {\r\n    nMod4 = nInIdx & 3\r\n    nUint24 |= b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << 18 - 6 * nMod4\r\n    if (nMod4 === 3 || nInLen - nInIdx === 1) {\r\n      for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {\r\n        taBytes[nOutIdx] = nUint24 >>> (16 >>> nMod3 & 24) & 255\r\n      }\r\n      nUint24 = 0\r\n    }\r\n  }\r\n  return taBytes\r\n}\r\n\r\nmodule.exports = { decode: decode }\r\n\n\n//# sourceURL=webpack://Synthesizer/../node_modules/audio-loader/lib/base64.js?");

/***/ }),

/***/ "../node_modules/audio-loader/lib/fetch.js":
/*!*************************************************!*\
  !*** ../node_modules/audio-loader/lib/fetch.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
eval("/* global XMLHttpRequest */\r\n\r\n\r\n/**\r\n * Given a url and a return type, returns a promise to the content of the url\r\n * Basically it wraps a XMLHttpRequest into a Promise\r\n *\r\n * @param {String} url\r\n * @param {String} type - can be 'text' or 'arraybuffer'\r\n * @return {Promise}\r\n */\r\nmodule.exports = function (url, type) {\r\n  return new Promise(function (done, reject) {\r\n    var req = new XMLHttpRequest()\r\n    if (type) req.responseType = type\r\n\r\n    req.open('GET', url)\r\n    req.onload = function () {\r\n      req.status === 200 ? done(req.response) : reject(Error(req.statusText))\r\n    }\r\n    req.onerror = function () { reject(Error('Network Error')) }\r\n    req.send()\r\n  })\r\n}\r\n\n\n//# sourceURL=webpack://Synthesizer/../node_modules/audio-loader/lib/fetch.js?");

/***/ }),

/***/ "../node_modules/audio-loader/lib/index.js":
/*!*************************************************!*\
  !*** ../node_modules/audio-loader/lib/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\n\r\nvar base64 = __webpack_require__(/*! ./base64 */ \"../node_modules/audio-loader/lib/base64.js\")\r\nvar fetch = __webpack_require__(/*! ./fetch */ \"../node_modules/audio-loader/lib/fetch.js\")\r\n\r\n// Given a regex, return a function that test if against a string\r\nfunction fromRegex (r) {\r\n  return function (o) { return typeof o === 'string' && r.test(o) }\r\n}\r\n// Try to apply a prefix to a name\r\nfunction prefix (pre, name) {\r\n  return typeof pre === 'string' ? pre + name\r\n    : typeof pre === 'function' ? pre(name)\r\n    : name\r\n}\r\n\r\n/**\r\n * Load one or more audio files\r\n *\r\n *\r\n * Possible option keys:\r\n *\r\n * - __from__ {Function|String}: a function or string to convert from file names to urls.\r\n * If is a string it will be prefixed to the name:\r\n * `load(ac, 'snare.mp3', { from: 'http://audio.net/samples/' })`\r\n * If it's a function it receives the file name and should return the url as string.\r\n * - __only__ {Array} - when loading objects, if provided, only the given keys\r\n * will be included in the decoded object:\r\n * `load(ac, 'piano.json', { only: ['C2', 'D2'] })`\r\n *\r\n * @param {AudioContext} ac - the audio context\r\n * @param {Object} source - the object to be loaded\r\n * @param {Object} options - (Optional) the load options for that object\r\n * @param {Object} defaultValue - (Optional) the default value to return as\r\n * in a promise if not valid loader found\r\n */\r\nfunction load (ac, source, options, defVal) {\r\n  var loader =\r\n    // Basic audio loading\r\n      isArrayBuffer(source) ? loadArrayBuffer\r\n    : isAudioFileName(source) ? loadAudioFile\r\n    : isPromise(source) ? loadPromise\r\n    // Compound objects\r\n    : isArray(source) ? loadArrayData\r\n    : isObject(source) ? loadObjectData\r\n    : isJsonFileName(source) ? loadJsonFile\r\n    // Base64 encoded audio\r\n    : isBase64Audio(source) ? loadBase64Audio\r\n    : isJsFileName(source) ? loadMidiJSFile\r\n    : null\r\n\r\n  var opts = options || {}\r\n  return loader ? loader(ac, source, opts)\r\n    : defVal ? Promise.resolve(defVal)\r\n    : Promise.reject('Source not valid (' + source + ')')\r\n}\r\nload.fetch = fetch\r\n\r\n// BASIC AUDIO LOADING\r\n// ===================\r\n\r\n// Load (decode) an array buffer\r\nfunction isArrayBuffer (o) { return o instanceof ArrayBuffer }\r\nfunction loadArrayBuffer (ac, array, options) {\r\n  return new Promise(function (done, reject) {\r\n    ac.decodeAudioData(array,\r\n      function (buffer) { done(buffer) },\r\n      function () { reject(\"Can't decode audio data (\" + array.slice(0, 30) + '...)') }\r\n    )\r\n  })\r\n}\r\n\r\n// Load an audio filename\r\nvar isAudioFileName = fromRegex(/\\.(mp3|wav|ogg)(\\?.*)?$/i)\r\nfunction loadAudioFile (ac, name, options) {\r\n  var url = prefix(options.from, name)\r\n  return load(ac, load.fetch(url, 'arraybuffer'), options)\r\n}\r\n\r\n// Load the result of a promise\r\nfunction isPromise (o) { return o && typeof o.then === 'function' }\r\nfunction loadPromise (ac, promise, options) {\r\n  return promise.then(function (value) {\r\n    return load(ac, value, options)\r\n  })\r\n}\r\n\r\n// COMPOUND OBJECTS\r\n// ================\r\n\r\n// Try to load all the items of an array\r\nvar isArray = Array.isArray\r\nfunction loadArrayData (ac, array, options) {\r\n  return Promise.all(array.map(function (data) {\r\n    return load(ac, data, options, data)\r\n  }))\r\n}\r\n\r\n// Try to load all the values of a key/value object\r\nfunction isObject (o) { return o && typeof o === 'object' }\r\nfunction loadObjectData (ac, obj, options) {\r\n  var dest = {}\r\n  var promises = Object.keys(obj).map(function (key) {\r\n    if (options.only && options.only.indexOf(key) === -1) return null\r\n    var value = obj[key]\r\n    return load(ac, value, options, value).then(function (audio) {\r\n      dest[key] = audio\r\n    })\r\n  })\r\n  return Promise.all(promises).then(function () { return dest })\r\n}\r\n\r\n// Load the content of a JSON file\r\nvar isJsonFileName = fromRegex(/\\.json(\\?.*)?$/i)\r\nfunction loadJsonFile (ac, name, options) {\r\n  var url = prefix(options.from, name)\r\n  return load(ac, load.fetch(url, 'text').then(JSON.parse), options)\r\n}\r\n\r\n// BASE64 ENCODED FORMATS\r\n// ======================\r\n\r\n// Load strings with Base64 encoded audio\r\nvar isBase64Audio = fromRegex(/^data:audio/)\r\nfunction loadBase64Audio (ac, source, options) {\r\n  var i = source.indexOf(',')\r\n  return load(ac, base64.decode(source.slice(i + 1)).buffer, options)\r\n}\r\n\r\n// Load .js files with MidiJS soundfont prerendered audio\r\nvar isJsFileName = fromRegex(/\\.js(\\?.*)?$/i)\r\nfunction loadMidiJSFile (ac, name, options) {\r\n  var url = prefix(options.from, name)\r\n  return load(ac, load.fetch(url, 'text').then(midiJsToJson), options)\r\n}\r\n\r\n// convert a MIDI.js javascript soundfont file to json\r\nfunction midiJsToJson (data) {\r\n  var begin = data.indexOf('MIDI.Soundfont.')\r\n  if (begin < 0) throw Error('Invalid MIDI.js Soundfont format')\r\n  begin = data.indexOf('=', begin) + 2\r\n  var end = data.lastIndexOf(',')\r\n  return JSON.parse(data.slice(begin, end) + '}')\r\n}\r\n\r\nif ( true && module.exports) module.exports = load\r\nif (typeof window !== 'undefined') window.loadAudio = load\r\n\n\n//# sourceURL=webpack://Synthesizer/../node_modules/audio-loader/lib/index.js?");

/***/ }),

/***/ "../node_modules/midimessage/dist/index.min.js":
/*!*****************************************************!*\
  !*** ../node_modules/midimessage/dist/index.min.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("(function(e){if(true){module.exports=e()}else { var t; }})(function(){var e,t,s;return function o(e,t,s){function a(n,i){if(!t[n]){if(!e[n]){var l=undefined;if(!i&&l)return require(n,!0);if(r)return r(n,!0);var h=new Error(\"Cannot find module '\"+n+\"'\");throw h.code=\"MODULE_NOT_FOUND\",h}var c=t[n]={exports:{}};e[n][0].call(c.exports,function(t){var s=e[n][1][t];return a(s?s:t)},c,c.exports,o,e,t,s)}return t[n].exports}var r=undefined;for(var n=0;n<s.length;n++)a(s[n]);return a}({1:[function(e,t,s){\"use strict\";Object.defineProperty(s,\"__esModule\",{value:true});s[\"default\"]=function(e){function t(e){this._event=e;this._data=e.data;this.receivedTime=e.receivedTime;if(this._data&&this._data.length<2){console.warn(\"Illegal MIDI message of length\",this._data.length);return}this._messageCode=e.data[0]&240;this.channel=e.data[0]&15;switch(this._messageCode){case 128:this.messageType=\"noteoff\";this.key=e.data[1]&127;this.velocity=e.data[2]&127;break;case 144:this.messageType=\"noteon\";this.key=e.data[1]&127;this.velocity=e.data[2]&127;break;case 160:this.messageType=\"keypressure\";this.key=e.data[1]&127;this.pressure=e.data[2]&127;break;case 176:this.messageType=\"controlchange\";this.controllerNumber=e.data[1]&127;this.controllerValue=e.data[2]&127;if(this.controllerNumber===120&&this.controllerValue===0){this.channelModeMessage=\"allsoundoff\"}else if(this.controllerNumber===121){this.channelModeMessage=\"resetallcontrollers\"}else if(this.controllerNumber===122){if(this.controllerValue===0){this.channelModeMessage=\"localcontroloff\"}else{this.channelModeMessage=\"localcontrolon\"}}else if(this.controllerNumber===123&&this.controllerValue===0){this.channelModeMessage=\"allnotesoff\"}else if(this.controllerNumber===124&&this.controllerValue===0){this.channelModeMessage=\"omnimodeoff\"}else if(this.controllerNumber===125&&this.controllerValue===0){this.channelModeMessage=\"omnimodeon\"}else if(this.controllerNumber===126){this.channelModeMessage=\"monomodeon\"}else if(this.controllerNumber===127){this.channelModeMessage=\"polymodeon\"}break;case 192:this.messageType=\"programchange\";this.program=e.data[1];break;case 208:this.messageType=\"channelpressure\";this.pressure=e.data[1]&127;break;case 224:this.messageType=\"pitchbendchange\";var t=e.data[2]&127;var s=e.data[1]&127;this.pitchBend=(t<<8)+s;break}}return new t(e)};t.exports=s[\"default\"]},{}]},{},[1])(1)});\r\n//# sourceMappingURL=dist/index.js.map\n\n//# sourceURL=webpack://Synthesizer/../node_modules/midimessage/dist/index.min.js?");

/***/ }),

/***/ "../node_modules/note-parser/index.js":
/*!********************************************!*\
  !*** ../node_modules/note-parser/index.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"acc\": () => (/* binding */ acc),\n/* harmony export */   \"alt\": () => (/* binding */ alt),\n/* harmony export */   \"build\": () => (/* binding */ build),\n/* harmony export */   \"chroma\": () => (/* binding */ chroma),\n/* harmony export */   \"freq\": () => (/* binding */ freq),\n/* harmony export */   \"letter\": () => (/* binding */ letter),\n/* harmony export */   \"midi\": () => (/* binding */ midi),\n/* harmony export */   \"oct\": () => (/* binding */ oct),\n/* harmony export */   \"parse\": () => (/* binding */ parse),\n/* harmony export */   \"pc\": () => (/* binding */ pc),\n/* harmony export */   \"regex\": () => (/* binding */ regex),\n/* harmony export */   \"step\": () => (/* binding */ step)\n/* harmony export */ });\n\r\n\r\n// util\r\nfunction fillStr (s, num) { return Array(num + 1).join(s) }\r\nfunction isNum (x) { return typeof x === 'number' }\r\nfunction isStr (x) { return typeof x === 'string' }\r\nfunction isDef (x) { return typeof x !== 'undefined' }\r\nfunction midiToFreq (midi, tuning) {\r\n  return Math.pow(2, (midi - 69) / 12) * (tuning || 440)\r\n}\r\n\r\nvar REGEX = /^([a-gA-G])(#{1,}|b{1,}|x{1,}|)(-?\\d*)\\s*(.*)\\s*$/\r\n/**\r\n * A regex for matching note strings in scientific notation.\r\n *\r\n * @name regex\r\n * @function\r\n * @return {RegExp} the regexp used to parse the note name\r\n *\r\n * The note string should have the form `letter[accidentals][octave][element]`\r\n * where:\r\n *\r\n * - letter: (Required) is a letter from A to G either upper or lower case\r\n * - accidentals: (Optional) can be one or more `b` (flats), `#` (sharps) or `x` (double sharps).\r\n * They can NOT be mixed.\r\n * - octave: (Optional) a positive or negative integer\r\n * - element: (Optional) additionally anything after the duration is considered to\r\n * be the element name (for example: 'C2 dorian')\r\n *\r\n * The executed regex contains (by array index):\r\n *\r\n * - 0: the complete string\r\n * - 1: the note letter\r\n * - 2: the optional accidentals\r\n * - 3: the optional octave\r\n * - 4: the rest of the string (trimmed)\r\n *\r\n * @example\r\n * var parser = require('note-parser')\r\n * parser.regex.exec('c#4')\r\n * // => ['c#4', 'c', '#', '4', '']\r\n * parser.regex.exec('c#4 major')\r\n * // => ['c#4major', 'c', '#', '4', 'major']\r\n * parser.regex().exec('CMaj7')\r\n * // => ['CMaj7', 'C', '', '', 'Maj7']\r\n */\r\nfunction regex () { return REGEX }\r\n\r\nvar SEMITONES = [0, 2, 4, 5, 7, 9, 11]\r\n/**\r\n * Parse a note name in scientific notation an return it's components,\r\n * and some numeric properties including midi number and frequency.\r\n *\r\n * @name parse\r\n * @function\r\n * @param {String} note - the note string to be parsed\r\n * @param {Boolean} isTonic - true the strings it's supposed to contain a note number\r\n * and some category (for example an scale: 'C# major'). It's false by default,\r\n * but when true, en extra tonicOf property is returned with the category ('major')\r\n * @param {Float} tunning - The frequency of A4 note to calculate frequencies.\r\n * By default it 440.\r\n * @return {Object} the parsed note name or null if not a valid note\r\n *\r\n * The parsed note name object will ALWAYS contains:\r\n * - letter: the uppercase letter of the note\r\n * - acc: the accidentals of the note (only sharps or flats)\r\n * - pc: the pitch class (letter + acc)\r\n * - step: s a numeric representation of the letter. It's an integer from 0 to 6\r\n * where 0 = C, 1 = D ... 6 = B\r\n * - alt: a numeric representation of the accidentals. 0 means no alteration,\r\n * positive numbers are for sharps and negative for flats\r\n * - chroma: a numeric representation of the pitch class. It's like midi for\r\n * pitch classes. 0 = C, 1 = C#, 2 = D ... 11 = B. Can be used to find enharmonics\r\n * since, for example, chroma of 'Cb' and 'B' are both 11\r\n *\r\n * If the note has octave, the parser object will contain:\r\n * - oct: the octave number (as integer)\r\n * - midi: the midi number\r\n * - freq: the frequency (using tuning parameter as base)\r\n *\r\n * If the parameter `isTonic` is set to true, the parsed object will contain:\r\n * - tonicOf: the rest of the string that follows note name (left and right trimmed)\r\n *\r\n * @example\r\n * var parse = require('note-parser').parse\r\n * parse('Cb4')\r\n * // => { letter: 'C', acc: 'b', pc: 'Cb', step: 0, alt: -1, chroma: -1,\r\n *         oct: 4, midi: 59, freq: 246.94165062806206 }\r\n * // if no octave, no midi, no freq\r\n * parse('fx')\r\n * // => { letter: 'F', acc: '##', pc: 'F##', step: 3, alt: 2, chroma: 7 })\r\n */\r\nfunction parse (str, isTonic, tuning) {\r\n  if (typeof str !== 'string') return null\r\n  var m = REGEX.exec(str)\r\n  if (!m || (!isTonic && m[4])) return null\r\n\r\n  var p = { letter: m[1].toUpperCase(), acc: m[2].replace(/x/g, '##') }\r\n  p.pc = p.letter + p.acc\r\n  p.step = (p.letter.charCodeAt(0) + 3) % 7\r\n  p.alt = p.acc[0] === 'b' ? -p.acc.length : p.acc.length\r\n  var pos = SEMITONES[p.step] + p.alt\r\n  p.chroma = pos < 0 ? 12 + pos : pos % 12\r\n  if (m[3]) { // has octave\r\n    p.oct = +m[3]\r\n    p.midi = pos + 12 * (p.oct + 1)\r\n    p.freq = midiToFreq(p.midi, tuning)\r\n  }\r\n  if (isTonic) p.tonicOf = m[4]\r\n  return p\r\n}\r\n\r\nvar LETTERS = 'CDEFGAB'\r\nfunction accStr (n) { return !isNum(n) ? '' : n < 0 ? fillStr('b', -n) : fillStr('#', n) }\r\nfunction octStr (n) { return !isNum(n) ? '' : '' + n }\r\n\r\n/**\r\n * Create a string from a parsed object or `step, alteration, octave` parameters\r\n * @param {Object} obj - the parsed data object\r\n * @return {String} a note string or null if not valid parameters\r\n * @since 1.2\r\n * @example\r\n * parser.build(parser.parse('cb2')) // => 'Cb2'\r\n *\r\n * @example\r\n * // it accepts (step, alteration, octave) parameters:\r\n * parser.build(3) // => 'F'\r\n * parser.build(3, -1) // => 'Fb'\r\n * parser.build(3, -1, 4) // => 'Fb4'\r\n */\r\nfunction build (s, a, o) {\r\n  if (s === null || typeof s === 'undefined') return null\r\n  if (s.step) return build(s.step, s.alt, s.oct)\r\n  if (s < 0 || s > 6) return null\r\n  return LETTERS.charAt(s) + accStr(a) + octStr(o)\r\n}\r\n\r\n/**\r\n * Get midi of a note\r\n *\r\n * @name midi\r\n * @function\r\n * @param {String|Integer} note - the note name or midi number\r\n * @return {Integer} the midi number of the note or null if not a valid note\r\n * or the note does NOT contains octave\r\n * @example\r\n * var parser = require('note-parser')\r\n * parser.midi('A4') // => 69\r\n * parser.midi('A') // => null\r\n * @example\r\n * // midi numbers are bypassed (even as strings)\r\n * parser.midi(60) // => 60\r\n * parser.midi('60') // => 60\r\n */\r\nfunction midi (note) {\r\n  if ((isNum(note) || isStr(note)) && note >= 0 && note < 128) return +note\r\n  var p = parse(note)\r\n  return p && isDef(p.midi) ? p.midi : null\r\n}\r\n\r\n/**\r\n * Get freq of a note in hertzs (in a well tempered 440Hz A4)\r\n *\r\n * @name freq\r\n * @function\r\n * @param {String} note - the note name or note midi number\r\n * @param {String} tuning - (Optional) the A4 frequency (440 by default)\r\n * @return {Float} the freq of the number if hertzs or null if not valid note\r\n * @example\r\n * var parser = require('note-parser')\r\n * parser.freq('A4') // => 440\r\n * parser.freq('A') // => null\r\n * @example\r\n * // can change tuning (440 by default)\r\n * parser.freq('A4', 444) // => 444\r\n * parser.freq('A3', 444) // => 222\r\n * @example\r\n * // it accepts midi numbers (as numbers and as strings)\r\n * parser.freq(69) // => 440\r\n * parser.freq('69', 442) // => 442\r\n */\r\nfunction freq (note, tuning) {\r\n  var m = midi(note)\r\n  return m === null ? null : midiToFreq(m, tuning)\r\n}\r\n\r\nfunction letter (src) { return (parse(src) || {}).letter }\r\nfunction acc (src) { return (parse(src) || {}).acc }\r\nfunction pc (src) { return (parse(src) || {}).pc }\r\nfunction step (src) { return (parse(src) || {}).step }\r\nfunction alt (src) { return (parse(src) || {}).alt }\r\nfunction chroma (src) { return (parse(src) || {}).chroma }\r\nfunction oct (src) { return (parse(src) || {}).oct }\r\n\n\n//# sourceURL=webpack://Synthesizer/../node_modules/note-parser/index.js?");

/***/ }),

/***/ "../node_modules/sample-player/lib/events.js":
/*!***************************************************!*\
  !*** ../node_modules/sample-player/lib/events.js ***!
  \***************************************************/
/***/ ((module) => {

eval("\r\nmodule.exports = function (player) {\r\n  /**\r\n   * Adds a listener of an event\r\n   * @chainable\r\n   * @param {String} event - the event name\r\n   * @param {Function} callback - the event handler\r\n   * @return {SamplePlayer} the player\r\n   * @example\r\n   * player.on('start', function(time, note) {\r\n   *   console.log(time, note)\r\n   * })\r\n   */\r\n  player.on = function (event, cb) {\r\n    if (arguments.length === 1 && typeof event === 'function') return player.on('event', event)\r\n    var prop = 'on' + event\r\n    var old = player[prop]\r\n    player[prop] = old ? chain(old, cb) : cb\r\n    return player\r\n  }\r\n  return player\r\n}\r\n\r\nfunction chain (fn1, fn2) {\r\n  return function (a, b, c, d) { fn1(a, b, c, d); fn2(a, b, c, d) }\r\n}\r\n\n\n//# sourceURL=webpack://Synthesizer/../node_modules/sample-player/lib/events.js?");

/***/ }),

/***/ "../node_modules/sample-player/lib/index.js":
/*!**************************************************!*\
  !*** ../node_modules/sample-player/lib/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\n\r\nvar player = __webpack_require__(/*! ./player */ \"../node_modules/sample-player/lib/player.js\")\r\nvar events = __webpack_require__(/*! ./events */ \"../node_modules/sample-player/lib/events.js\")\r\nvar notes = __webpack_require__(/*! ./notes */ \"../node_modules/sample-player/lib/notes.js\")\r\nvar scheduler = __webpack_require__(/*! ./scheduler */ \"../node_modules/sample-player/lib/scheduler.js\")\r\nvar midi = __webpack_require__(/*! ./midi */ \"../node_modules/sample-player/lib/midi.js\")\r\n\r\nfunction SamplePlayer (ac, source, options) {\r\n  return midi(scheduler(notes(events(player(ac, source, options)))))\r\n}\r\n\r\nif ( true && module.exports) module.exports = SamplePlayer\r\nif (typeof window !== 'undefined') window.SamplePlayer = SamplePlayer\r\n\n\n//# sourceURL=webpack://Synthesizer/../node_modules/sample-player/lib/index.js?");

/***/ }),

/***/ "../node_modules/sample-player/lib/midi.js":
/*!*************************************************!*\
  !*** ../node_modules/sample-player/lib/midi.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var midimessage = __webpack_require__(/*! midimessage */ \"../node_modules/midimessage/dist/index.min.js\")\r\n\r\nmodule.exports = function (player) {\r\n  /**\r\n  * Connect a player to a midi input\r\n  *\r\n  * The options accepts:\r\n  *\r\n  * - channel: the channel to listen to. Listen to all channels by default.\r\n  *\r\n  * @param {MIDIInput} input\r\n  * @param {Object} options - (Optional)\r\n  * @return {SamplePlayer} the player\r\n  * @example\r\n  * var piano = player(...)\r\n  * window.navigator.requestMIDIAccess().then(function (midiAccess) {\r\n  *   midiAccess.inputs.forEach(function (midiInput) {\r\n  *     piano.listenToMidi(midiInput)\r\n  *   })\r\n  * })\r\n  */\r\n  player.listenToMidi = function (input, options) {\r\n    var started = {}\r\n    var opts = options || {}\r\n    var gain = opts.gain || function (vel) { return vel / 127 }\r\n\r\n    input.onmidimessage = function (msg) {\r\n      var mm = msg.messageType ? msg : midimessage(msg)\r\n      if (mm.messageType === 'noteon' && mm.velocity === 0) {\r\n        mm.messageType = 'noteoff'\r\n      }\r\n      if (opts.channel && mm.channel !== opts.channel) return\r\n\r\n      switch (mm.messageType) {\r\n        case 'noteon':\r\n          started[mm.key] = player.play(mm.key, 0, { gain: gain(mm.velocity) })\r\n          break\r\n        case 'noteoff':\r\n          if (started[mm.key]) {\r\n            started[mm.key].stop()\r\n            delete started[mm.key]\r\n          }\r\n          break\r\n      }\r\n    }\r\n    return player\r\n  }\r\n  return player\r\n}\r\n\n\n//# sourceURL=webpack://Synthesizer/../node_modules/sample-player/lib/midi.js?");

/***/ }),

/***/ "../node_modules/sample-player/lib/notes.js":
/*!**************************************************!*\
  !*** ../node_modules/sample-player/lib/notes.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\n\r\nvar note = __webpack_require__(/*! note-parser */ \"../node_modules/sample-player/node_modules/note-parser/index.js\")\r\nvar isMidi = function (n) { return n !== null && n !== [] && n >= 0 && n < 129 }\r\nvar toMidi = function (n) { return isMidi(n) ? +n : note.midi(n) }\r\n\r\n// Adds note name to midi conversion\r\nmodule.exports = function (player) {\r\n  if (player.buffers) {\r\n    var map = player.opts.map\r\n    var toKey = typeof map === 'function' ? map : toMidi\r\n    var mapper = function (name) {\r\n      return name ? toKey(name) || name : null\r\n    }\r\n\r\n    player.buffers = mapBuffers(player.buffers, mapper)\r\n    var start = player.start\r\n    player.start = function (name, when, options) {\r\n      var key = mapper(name)\r\n      var dec = key % 1\r\n      if (dec) {\r\n        key = Math.floor(key)\r\n        options = Object.assign(options || {}, { cents: Math.floor(dec * 100) })\r\n      }\r\n      return start(key, when, options)\r\n    }\r\n  }\r\n  return player\r\n}\r\n\r\nfunction mapBuffers (buffers, toKey) {\r\n  return Object.keys(buffers).reduce(function (mapped, name) {\r\n    mapped[toKey(name)] = buffers[name]\r\n    return mapped\r\n  }, {})\r\n}\r\n\n\n//# sourceURL=webpack://Synthesizer/../node_modules/sample-player/lib/notes.js?");

/***/ }),

/***/ "../node_modules/sample-player/lib/player.js":
/*!***************************************************!*\
  !*** ../node_modules/sample-player/lib/player.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* global AudioBuffer */\r\n\r\n\r\nvar ADSR = __webpack_require__(/*! adsr */ \"../node_modules/adsr/index.js\")\r\n\r\nvar EMPTY = {}\r\nvar DEFAULTS = {\r\n  gain: 1,\r\n  attack: 0.01,\r\n  decay: 0.1,\r\n  sustain: 0.9,\r\n  release: 0.3,\r\n  loop: false,\r\n  cents: 0,\r\n  loopStart: 0,\r\n  loopEnd: 0\r\n}\r\n\r\n/**\r\n * Create a sample player.\r\n *\r\n * @param {AudioContext} ac - the audio context\r\n * @param {ArrayBuffer|Object<String,ArrayBuffer>} source\r\n * @param {Onject} options - (Optional) an options object\r\n * @return {player} the player\r\n * @example\r\n * var SamplePlayer = require('sample-player')\r\n * var ac = new AudioContext()\r\n * var snare = SamplePlayer(ac, <AudioBuffer>)\r\n * snare.play()\r\n */\r\nfunction SamplePlayer (ac, source, options) {\r\n  var connected = false\r\n  var nextId = 0\r\n  var tracked = {}\r\n  var out = ac.createGain()\r\n  out.gain.value = 1\r\n\r\n  var opts = Object.assign({}, DEFAULTS, options)\r\n\r\n  /**\r\n   * @namespace\r\n   */\r\n  var player = { context: ac, out: out, opts: opts }\r\n  if (source instanceof AudioBuffer) player.buffer = source\r\n  else player.buffers = source\r\n\r\n  /**\r\n   * Start a sample buffer.\r\n   *\r\n   * The returned object has a function `stop(when)` to stop the sound.\r\n   *\r\n   * @param {String} name - the name of the buffer. If the source of the\r\n   * SamplePlayer is one sample buffer, this parameter is not required\r\n   * @param {Float} when - (Optional) when to start (current time if by default)\r\n   * @param {Object} options - additional sample playing options\r\n   * @return {AudioNode} an audio node with a `stop` function\r\n   * @example\r\n   * var sample = player(ac, <AudioBuffer>).connect(ac.destination)\r\n   * sample.start()\r\n   * sample.start(5, { gain: 0.7 }) // name not required since is only one AudioBuffer\r\n   * @example\r\n   * var drums = player(ac, { snare: <AudioBuffer>, kick: <AudioBuffer>, ... }).connect(ac.destination)\r\n   * drums.start('snare')\r\n   * drums.start('snare', 0, { gain: 0.3 })\r\n   */\r\n  player.start = function (name, when, options) {\r\n    // if only one buffer, reorder arguments\r\n    if (player.buffer && name !== null) return player.start(null, name, when)\r\n\r\n    var buffer = name ? player.buffers[name] : player.buffer\r\n    if (!buffer) {\r\n      console.warn('Buffer ' + name + ' not found.')\r\n      return\r\n    } else if (!connected) {\r\n      console.warn('SamplePlayer not connected to any node.')\r\n      return\r\n    }\r\n\r\n    var opts = options || EMPTY\r\n    when = Math.max(ac.currentTime, when || 0)\r\n    player.emit('start', when, name, opts)\r\n    var node = createNode(name, buffer, opts)\r\n    node.id = track(name, node)\r\n    node.env.start(when)\r\n    node.source.start(when)\r\n    player.emit('started', when, node.id, node)\r\n    if (opts.duration) node.stop(when + opts.duration)\r\n    return node\r\n  }\r\n\r\n  // NOTE: start will be override so we can't copy the function reference\r\n  // this is obviously not a good design, so this code will be gone soon.\r\n  /**\r\n   * An alias for `player.start`\r\n   * @see player.start\r\n   * @since 0.3.0\r\n   */\r\n  player.play = function (name, when, options) {\r\n    return player.start(name, when, options)\r\n  }\r\n\r\n  /**\r\n   * Stop some or all samples\r\n   *\r\n   * @param {Float} when - (Optional) an absolute time in seconds (or currentTime\r\n   * if not specified)\r\n   * @param {Array} nodes - (Optional) an array of nodes or nodes ids to stop\r\n   * @return {Array} an array of ids of the stoped samples\r\n   *\r\n   * @example\r\n   * var longSound = player(ac, <AudioBuffer>).connect(ac.destination)\r\n   * longSound.start(ac.currentTime)\r\n   * longSound.start(ac.currentTime + 1)\r\n   * longSound.start(ac.currentTime + 2)\r\n   * longSound.stop(ac.currentTime + 3) // stop the three sounds\r\n   */\r\n  player.stop = function (when, ids) {\r\n    var node\r\n    ids = ids || Object.keys(tracked)\r\n    return ids.map(function (id) {\r\n      node = tracked[id]\r\n      if (!node) return null\r\n      node.stop(when)\r\n      return node.id\r\n    })\r\n  }\r\n  /**\r\n   * Connect the player to a destination node\r\n   *\r\n   * @param {AudioNode} destination - the destination node\r\n   * @return {AudioPlayer} the player\r\n   * @chainable\r\n   * @example\r\n   * var sample = player(ac, <AudioBuffer>).connect(ac.destination)\r\n   */\r\n  player.connect = function (dest) {\r\n    connected = true\r\n    out.connect(dest)\r\n    return player\r\n  }\r\n\r\n  player.emit = function (event, when, obj, opts) {\r\n    if (player.onevent) player.onevent(event, when, obj, opts)\r\n    var fn = player['on' + event]\r\n    if (fn) fn(when, obj, opts)\r\n  }\r\n\r\n  return player\r\n\r\n  // =============== PRIVATE FUNCTIONS ============== //\r\n\r\n  function track (name, node) {\r\n    node.id = nextId++\r\n    tracked[node.id] = node\r\n    node.source.onended = function () {\r\n      var now = ac.currentTime\r\n      node.source.disconnect()\r\n      node.env.disconnect()\r\n      node.disconnect()\r\n      player.emit('ended', now, node.id, node)\r\n    }\r\n    return node.id\r\n  }\r\n\r\n  function createNode (name, buffer, options) {\r\n    var node = ac.createGain()\r\n    node.gain.value = 0 // the envelope will control the gain\r\n    node.connect(out)\r\n\r\n    node.env = envelope(ac, options, opts)\r\n    node.env.connect(node.gain)\r\n\r\n    node.source = ac.createBufferSource()\r\n    node.source.buffer = buffer\r\n    node.source.connect(node)\r\n    node.source.loop = options.loop || opts.loop\r\n    node.source.playbackRate.value = centsToRate(options.cents || opts.cents)\r\n    node.source.loopStart = options.loopStart || opts.loopStart\r\n    node.source.loopEnd = options.loopEnd || opts.loopEnd\r\n    node.stop = function (when) {\r\n      var time = when || ac.currentTime\r\n      player.emit('stop', time, name)\r\n      var stopAt = node.env.stop(time)\r\n      node.source.stop(stopAt)\r\n    }\r\n    return node\r\n  }\r\n}\r\n\r\nfunction isNum (x) { return typeof x === 'number' }\r\nvar PARAMS = ['attack', 'decay', 'sustain', 'release']\r\nfunction envelope (ac, options, opts) {\r\n  var env = ADSR(ac)\r\n  var adsr = options.adsr || opts.adsr\r\n  PARAMS.forEach(function (name, i) {\r\n    if (adsr) env[name] = adsr[i]\r\n    else env[name] = options[name] || opts[name]\r\n  })\r\n  env.value.value = isNum(options.gain) ? options.gain\r\n    : isNum(opts.gain) ? opts.gain : 1\r\n  return env\r\n}\r\n\r\n/*\r\n * Get playback rate for a given pitch change (in cents)\r\n * Basic [math](http://www.birdsoft.demon.co.uk/music/samplert.htm):\r\n * f2 = f1 * 2^( C / 1200 )\r\n */\r\nfunction centsToRate (cents) { return cents ? Math.pow(2, cents / 1200) : 1 }\r\n\r\nmodule.exports = SamplePlayer\r\n\n\n//# sourceURL=webpack://Synthesizer/../node_modules/sample-player/lib/player.js?");

/***/ }),

/***/ "../node_modules/sample-player/lib/scheduler.js":
/*!******************************************************!*\
  !*** ../node_modules/sample-player/lib/scheduler.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
eval("\r\n\r\nvar isArr = Array.isArray\r\nvar isObj = function (o) { return o && typeof o === 'object' }\r\nvar OPTS = {}\r\n\r\nmodule.exports = function (player) {\r\n  /**\r\n   * Schedule a list of events to be played at specific time.\r\n   *\r\n   * It supports three formats of events for the events list:\r\n   *\r\n   * - An array with [time, note]\r\n   * - An array with [time, object]\r\n   * - An object with { time: ?, [name|note|midi|key]: ? }\r\n   *\r\n   * @param {Float} time - an absolute time to start (or AudioContext's\r\n   * currentTime if provided number is 0)\r\n   * @param {Array} events - the events list.\r\n   * @return {Array} an array of ids\r\n   *\r\n   * @example\r\n   * // Event format: [time, note]\r\n   * var piano = player(ac, ...).connect(ac.destination)\r\n   * piano.schedule(0, [ [0, 'C2'], [0.5, 'C3'], [1, 'C4'] ])\r\n   *\r\n   * @example\r\n   * // Event format: an object { time: ?, name: ? }\r\n   * var drums = player(ac, ...).connect(ac.destination)\r\n   * drums.schedule(0, [\r\n   *   { name: 'kick', time: 0 },\r\n   *   { name: 'snare', time: 0.5 },\r\n   *   { name: 'kick', time: 1 },\r\n   *   { name: 'snare', time: 1.5 }\r\n   * ])\r\n   */\r\n  player.schedule = function (time, events) {\r\n    var now = player.context.currentTime\r\n    var when = time < now ? now : time\r\n    player.emit('schedule', when, events)\r\n    var t, o, note, opts\r\n    return events.map(function (event) {\r\n      if (!event) return null\r\n      else if (isArr(event)) {\r\n        t = event[0]; o = event[1]\r\n      } else {\r\n        t = event.time; o = event\r\n      }\r\n\r\n      if (isObj(o)) {\r\n        note = o.name || o.key || o.note || o.midi || null\r\n        opts = o\r\n      } else {\r\n        note = o\r\n        opts = OPTS\r\n      }\r\n\r\n      return player.start(note, when + (t || 0), opts)\r\n    })\r\n  }\r\n  return player\r\n}\r\n\n\n//# sourceURL=webpack://Synthesizer/../node_modules/sample-player/lib/scheduler.js?");

/***/ }),

/***/ "../node_modules/sample-player/node_modules/note-parser/index.js":
/*!***********************************************************************!*\
  !*** ../node_modules/sample-player/node_modules/note-parser/index.js ***!
  \***********************************************************************/
/***/ ((module) => {

"use strict";
eval("\r\n\r\nvar REGEX = /^([a-gA-G])(#{1,}|b{1,}|x{1,}|)(-?\\d*)\\s*(.*)\\s*$/\r\n/**\r\n * A regex for matching note strings in scientific notation.\r\n *\r\n * @name regex\r\n * @function\r\n * @return {RegExp} the regexp used to parse the note name\r\n *\r\n * The note string should have the form `letter[accidentals][octave][element]`\r\n * where:\r\n *\r\n * - letter: (Required) is a letter from A to G either upper or lower case\r\n * - accidentals: (Optional) can be one or more `b` (flats), `#` (sharps) or `x` (double sharps).\r\n * They can NOT be mixed.\r\n * - octave: (Optional) a positive or negative integer\r\n * - element: (Optional) additionally anything after the duration is considered to\r\n * be the element name (for example: 'C2 dorian')\r\n *\r\n * The executed regex contains (by array index):\r\n *\r\n * - 0: the complete string\r\n * - 1: the note letter\r\n * - 2: the optional accidentals\r\n * - 3: the optional octave\r\n * - 4: the rest of the string (trimmed)\r\n *\r\n * @example\r\n * var parser = require('note-parser')\r\n * parser.regex.exec('c#4')\r\n * // => ['c#4', 'c', '#', '4', '']\r\n * parser.regex.exec('c#4 major')\r\n * // => ['c#4major', 'c', '#', '4', 'major']\r\n * parser.regex().exec('CMaj7')\r\n * // => ['CMaj7', 'C', '', '', 'Maj7']\r\n */\r\nfunction regex () { return REGEX }\r\n\r\nvar SEMITONES = [0, 2, 4, 5, 7, 9, 11]\r\n/**\r\n * Parse a note name in scientific notation an return it's components,\r\n * and some numeric properties including midi number and frequency.\r\n *\r\n * @name parse\r\n * @function\r\n * @param {String} note - the note string to be parsed\r\n * @param {Boolean} isTonic - true if the note is the tonic of something.\r\n * If true, en extra tonicOf property is returned. It's false by default.\r\n * @param {Float} tunning - The frequency of A4 note to calculate frequencies.\r\n * By default it 440.\r\n * @return {Object} the parsed note name or null if not a valid note\r\n *\r\n * The parsed note name object will ALWAYS contains:\r\n * - letter: the uppercase letter of the note\r\n * - acc: the accidentals of the note (only sharps or flats)\r\n * - pc: the pitch class (letter + acc)\r\n * - step: s a numeric representation of the letter. It's an integer from 0 to 6\r\n * where 0 = C, 1 = D ... 6 = B\r\n * - alt: a numeric representation of the accidentals. 0 means no alteration,\r\n * positive numbers are for sharps and negative for flats\r\n * - chroma: a numeric representation of the pitch class. It's like midi for\r\n * pitch classes. 0 = C, 1 = C#, 2 = D ... It can have negative values: -1 = Cb.\r\n * Can detect pitch class enhramonics.\r\n *\r\n * If the note has octave, the parser object will contain:\r\n * - oct: the octave number (as integer)\r\n * - midi: the midi number\r\n * - freq: the frequency (using tuning parameter as base)\r\n *\r\n * If the parameter `isTonic` is set to true, the parsed object will contain:\r\n * - tonicOf: the rest of the string that follows note name (left and right trimmed)\r\n *\r\n * @example\r\n * var parse = require('note-parser').parse\r\n * parse('Cb4')\r\n * // => { letter: 'C', acc: 'b', pc: 'Cb', step: 0, alt: -1, chroma: -1,\r\n *         oct: 4, midi: 59, freq: 246.94165062806206 }\r\n * // if no octave, no midi, no freq\r\n * parse('fx')\r\n * // => { letter: 'F', acc: '##', pc: 'F##', step: 3, alt: 2, chroma: 7 })\r\n */\r\nfunction parse (str, isTonic, tuning) {\r\n  if (typeof str !== 'string') return null\r\n  var m = REGEX.exec(str)\r\n  if (!m || !isTonic && m[4]) return null\r\n\r\n  var p = { letter: m[1].toUpperCase(), acc: m[2].replace(/x/g, '##') }\r\n  p.pc = p.letter + p.acc\r\n  p.step = (p.letter.charCodeAt(0) + 3) % 7\r\n  p.alt = p.acc[0] === 'b' ? -p.acc.length : p.acc.length\r\n  p.chroma = SEMITONES[p.step] + p.alt\r\n  if (m[3]) {\r\n    p.oct = +m[3]\r\n    p.midi = p.chroma + 12 * (p.oct + 1)\r\n    p.freq = midiToFreq(p.midi, tuning)\r\n  }\r\n  if (isTonic) p.tonicOf = m[4]\r\n  return p\r\n}\r\n\r\n/**\r\n * Given a midi number, return its frequency\r\n * @param {Integer} midi - midi note number\r\n * @param {Float} tuning - (Optional) the A4 tuning (440Hz by default)\r\n * @return {Float} frequency in hertzs\r\n */\r\nfunction midiToFreq (midi, tuning) {\r\n  return Math.pow(2, (midi - 69) / 12) * (tuning || 440)\r\n}\r\n\r\nvar parser = { parse: parse, regex: regex, midiToFreq: midiToFreq }\r\nvar FNS = ['letter', 'acc', 'pc', 'step', 'alt', 'chroma', 'oct', 'midi', 'freq']\r\nFNS.forEach(function (name) {\r\n  parser[name] = function (src) {\r\n    var p = parse(src)\r\n    return p && (typeof p[name] !== 'undefined') ? p[name] : null\r\n  }\r\n})\r\n\r\nmodule.exports = parser\r\n\r\n// extra API docs\r\n/**\r\n * Get midi of a note\r\n *\r\n * @name midi\r\n * @function\r\n * @param {String} note - the note name\r\n * @return {Integer} the midi number of the note or null if not a valid note\r\n * or the note does NOT contains octave\r\n * @example\r\n * var parser = require('note-parser')\r\n * parser.midi('A4') // => 69\r\n * parser.midi('A') // => null\r\n */\r\n/**\r\n * Get freq of a note in hertzs (in a well tempered 440Hz A4)\r\n *\r\n * @name freq\r\n * @function\r\n * @param {String} note - the note name\r\n * @return {Float} the freq of the number if hertzs or null if not valid note\r\n * or the note does NOT contains octave\r\n * @example\r\n * var parser = require('note-parser')\r\n * parser.freq('A4') // => 440\r\n * parser.freq('A') // => null\r\n */\r\n\n\n//# sourceURL=webpack://Synthesizer/../node_modules/sample-player/node_modules/note-parser/index.js?");

/***/ }),

/***/ "../node_modules/soundfont-player/lib/index.js":
/*!*****************************************************!*\
  !*** ../node_modules/soundfont-player/lib/index.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\n\r\nvar load = __webpack_require__(/*! audio-loader */ \"../node_modules/audio-loader/lib/index.js\")\r\nvar player = __webpack_require__(/*! sample-player */ \"../node_modules/sample-player/lib/index.js\")\r\n\r\n/**\r\n * Load a soundfont instrument. It returns a promise that resolves to a\r\n * instrument object.\r\n *\r\n * The instrument object returned by the promise has the following properties:\r\n *\r\n * - name: the instrument name\r\n * - play: A function to play notes from the buffer with the signature\r\n * `play(note, time, duration, options)`\r\n *\r\n *\r\n * The valid options are:\r\n *\r\n * - `format`: the soundfont format. 'mp3' by default. Can be 'ogg'\r\n * - `soundfont`: the soundfont name. 'MusyngKite' by default. Can be 'FluidR3_GM'\r\n * - `nameToUrl` <Function>: a function to convert from instrument names to URL\r\n * - `destination`: by default Soundfont uses the `audioContext.destination` but you can override it.\r\n * - `gain`: the gain of the player (1 by default)\r\n * - `notes`: an array of the notes to decode. It can be an array of strings\r\n * with note names or an array of numbers with midi note numbers. This is a\r\n * performance option: since decoding mp3 is a cpu intensive process, you can limit\r\n * limit the number of notes you want and reduce the time to load the instrument.\r\n *\r\n * @param {AudioContext} ac - the audio context\r\n * @param {String} name - the instrument name. For example: 'acoustic_grand_piano'\r\n * @param {Object} options - (Optional) the same options as Soundfont.loadBuffers\r\n * @return {Promise}\r\n *\r\n * @example\r\n * var Soundfont = require('sounfont-player')\r\n * Soundfont.instrument('marimba').then(function (marimba) {\r\n *   marimba.play('C4')\r\n * })\r\n */\r\nfunction instrument (ac, name, options) {\r\n  if (arguments.length === 1) return function (n, o) { return instrument(ac, n, o) }\r\n  var opts = options || {}\r\n  var isUrl = opts.isSoundfontURL || isSoundfontURL\r\n  var toUrl = opts.nameToUrl || nameToUrl\r\n  var url = isUrl(name) ? name : toUrl(name, opts.soundfont, opts.format)\r\n\r\n  return load(ac, url, { only: opts.only || opts.notes }).then(function (buffers) {\r\n    var p = player(ac, buffers, opts).connect(opts.destination ? opts.destination : ac.destination)\r\n    p.url = url\r\n    p.name = name\r\n    return p\r\n  })\r\n}\r\n\r\nfunction isSoundfontURL (name) {\r\n  return /\\.js(\\?.*)?$/i.test(name)\r\n}\r\n\r\n/**\r\n * Given an instrument name returns a URL to to the Benjamin Gleitzman's\r\n * package of [pre-rendered sound fonts](https://github.com/gleitz/midi-js-soundfonts)\r\n *\r\n * @param {String} name - instrument name\r\n * @param {String} soundfont - (Optional) the soundfont name. One of 'FluidR3_GM'\r\n * or 'MusyngKite' ('MusyngKite' by default)\r\n * @param {String} format - (Optional) Can be 'mp3' or 'ogg' (mp3 by default)\r\n * @returns {String} the Soundfont file url\r\n * @example\r\n * var Soundfont = require('soundfont-player')\r\n * Soundfont.nameToUrl('marimba', 'mp3')\r\n */\r\nfunction nameToUrl (name, sf, format) {\r\n  format = format === 'ogg' ? format : 'mp3'\r\n  sf = sf === 'FluidR3_GM' ? sf : 'MusyngKite'\r\n  return 'https://gleitz.github.io/midi-js-soundfonts/' + sf + '/' + name + '-' + format + '.js'\r\n}\r\n\r\n// In the 1.0.0 release it will be:\r\n// var Soundfont = {}\r\nvar Soundfont = __webpack_require__(/*! ./legacy */ \"../node_modules/soundfont-player/lib/legacy.js\")\r\nSoundfont.instrument = instrument\r\nSoundfont.nameToUrl = nameToUrl\r\n\r\nif ( true && module.exports) module.exports = Soundfont\r\nif (typeof window !== 'undefined') window.Soundfont = Soundfont\r\n\n\n//# sourceURL=webpack://Synthesizer/../node_modules/soundfont-player/lib/index.js?");

/***/ }),

/***/ "../node_modules/soundfont-player/lib/legacy.js":
/*!******************************************************!*\
  !*** ../node_modules/soundfont-player/lib/legacy.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\n\r\nvar parser = __webpack_require__(/*! note-parser */ \"../node_modules/note-parser/index.js\")\r\n\r\n/**\r\n * Create a Soundfont object\r\n *\r\n * @param {AudioContext} context - the [audio context](https://developer.mozilla.org/en/docs/Web/API/AudioContext)\r\n * @param {Function} nameToUrl - (Optional) a function that maps the sound font name to the url\r\n * @return {Soundfont} a soundfont object\r\n */\r\nfunction Soundfont (ctx, nameToUrl) {\r\n  console.warn('new Soundfont() is deprected')\r\n  console.log('Please use Soundfont.instrument() instead of new Soundfont().instrument()')\r\n  if (!(this instanceof Soundfont)) return new Soundfont(ctx)\r\n\r\n  this.nameToUrl = nameToUrl || Soundfont.nameToUrl\r\n  this.ctx = ctx\r\n  this.instruments = {}\r\n  this.promises = []\r\n}\r\n\r\nSoundfont.prototype.onready = function (callback) {\r\n  console.warn('deprecated API')\r\n  console.log('Please use Promise.all(Soundfont.instrument(), Soundfont.instrument()).then() instead of new Soundfont().onready()')\r\n  Promise.all(this.promises).then(callback)\r\n}\r\n\r\nSoundfont.prototype.instrument = function (name, options) {\r\n  console.warn('new Soundfont().instrument() is deprecated.')\r\n  console.log('Please use Soundfont.instrument() instead.')\r\n  var ctx = this.ctx\r\n  name = name || 'default'\r\n  if (name in this.instruments) return this.instruments[name]\r\n  var inst = {name: name, play: oscillatorPlayer(ctx, options)}\r\n  this.instruments[name] = inst\r\n  if (name !== 'default') {\r\n    var promise = Soundfont.instrument(ctx, name, options).then(function (instrument) {\r\n      inst.play = instrument.play\r\n      return inst\r\n    })\r\n    this.promises.push(promise)\r\n    inst.onready = function (cb) {\r\n      console.warn('onready is deprecated. Use Soundfont.instrument().then()')\r\n      promise.then(cb)\r\n    }\r\n  } else {\r\n    inst.onready = function (cb) {\r\n      console.warn('onready is deprecated. Use Soundfont.instrument().then()')\r\n      cb()\r\n    }\r\n  }\r\n  return inst\r\n}\r\n\r\n/*\r\n * Load the buffers of a given instrument name. It returns a promise that resolves\r\n * to a hash with midi note numbers as keys, and audio buffers as values.\r\n *\r\n * @param {AudioContext} ac - the audio context\r\n * @param {String} name - the instrument name (it accepts an url if starts with \"http\")\r\n * @param {Object} options - (Optional) options object\r\n * @return {Promise} a promise that resolves to a Hash of { midiNoteNum: <AudioBuffer> }\r\n *\r\n * The options object accepts the following keys:\r\n *\r\n * - nameToUrl {Function}: a function to convert from instrument names to urls.\r\n * By default it uses Benjamin Gleitzman's package of\r\n * [pre-rendered sound fonts](https://github.com/gleitz/midi-js-soundfonts)\r\n * - notes {Array}: the list of note names to be decoded (all by default)\r\n *\r\n * @example\r\n * var Soundfont = require('soundfont-player')\r\n * Soundfont.loadBuffers(ctx, 'acoustic_grand_piano').then(function(buffers) {\r\n *  buffers[60] // => An <AudioBuffer> corresponding to note C4\r\n * })\r\n */\r\nfunction loadBuffers (ac, name, options) {\r\n  console.warn('Soundfont.loadBuffers is deprecate.')\r\n  console.log('Use Soundfont.instrument(..) and get buffers properties from the result.')\r\n  return Soundfont.instrument(ac, name, options).then(function (inst) {\r\n    return inst.buffers\r\n  })\r\n}\r\nSoundfont.loadBuffers = loadBuffers\r\n\r\n/**\r\n * Returns a function that plays an oscillator\r\n *\r\n * @param {AudioContext} ac - the audio context\r\n * @param {Hash} defaultOptions - (Optional) a hash of options:\r\n * - vcoType: the oscillator type (default: 'sine')\r\n * - gain: the output gain value (default: 0.4)\r\n  * - destination: the player destination (default: ac.destination)\r\n */\r\nfunction oscillatorPlayer (ctx, defaultOptions) {\r\n  defaultOptions = defaultOptions || {}\r\n  return function (note, time, duration, options) {\r\n    console.warn('The oscillator player is deprecated.')\r\n    console.log('Starting with version 0.9.0 you will have to wait until the soundfont is loaded to play sounds.')\r\n    var midi = note > 0 && note < 129 ? +note : parser.midi(note)\r\n    var freq = midi ? parser.midiToFreq(midi, 440) : null\r\n    if (!freq) return\r\n\r\n    duration = duration || 0.2\r\n\r\n    options = options || {}\r\n    var destination = options.destination || defaultOptions.destination || ctx.destination\r\n    var vcoType = options.vcoType || defaultOptions.vcoType || 'sine'\r\n    var gain = options.gain || defaultOptions.gain || 0.4\r\n\r\n    var vco = ctx.createOscillator()\r\n    vco.type = vcoType\r\n    vco.frequency.value = freq\r\n\r\n    /* VCA */\r\n    var vca = ctx.createGain()\r\n    vca.gain.value = gain\r\n\r\n    /* Connections */\r\n    vco.connect(vca)\r\n    vca.connect(destination)\r\n\r\n    vco.start(time)\r\n    if (duration > 0) vco.stop(time + duration)\r\n    return vco\r\n  }\r\n}\r\n\r\n/**\r\n * Given a note name, return the note midi number\r\n *\r\n * @name noteToMidi\r\n * @function\r\n * @param {String} noteName\r\n * @return {Integer} the note midi number or null if not a valid note name\r\n */\r\nSoundfont.noteToMidi = parser.midi\r\n\r\nmodule.exports = Soundfont\r\n\n\n//# sourceURL=webpack://Synthesizer/../node_modules/soundfont-player/lib/legacy.js?");

/***/ }),

/***/ "./src/js/JZZ.js":
/*!***********************!*\
  !*** ./src/js/JZZ.js ***!
  \***********************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("(function(global, factory) {\r\n  /* istanbul ignore next */\r\n  if (true) {\r\n    module.exports = factory();\r\n  }\r\n  else {}\r\n})(this, function() {\r\n\r\n  var _scope = typeof window === 'undefined' ? __webpack_require__.g : window;\r\n  var _version = '1.5.9';\r\n  var i, j, k, m, n;\r\n\r\n  /* istanbul ignore next */\r\n  var _time = Date.now || function () { return new Date().getTime(); };\r\n  var _startTime = _time();\r\n  /* istanbul ignore next */\r\n  var _now = typeof performance != 'undefined' && performance.now ?\r\n    function() { return performance.now(); } : function() { return _time() - _startTime; };\r\n  var _schedule = function(f) {\r\n    setTimeout(f, 0);\r\n  };\r\n  function _nop() {}\r\n  function _func(f) { return typeof f == 'function'; }\r\n\r\n  // _R: common root for all async objects\r\n  function _R() {\r\n    this._orig = this;\r\n    this._ready = false;\r\n    this._queue = [];\r\n    this._log = [];\r\n  }\r\n  _R.prototype._exec = function() {\r\n    while (this._ready && this._queue.length) {\r\n      var x = this._queue.shift();\r\n      x[0].apply(this, x[1]);\r\n    }\r\n  };\r\n  _R.prototype._push = function(func, arg) { this._queue.push([func, arg]); _R.prototype._exec.apply(this); };\r\n  _R.prototype._slip = function(func, arg) { this._queue.unshift([func, arg]); };\r\n  _R.prototype._pause = function() { this._ready = false; };\r\n  _R.prototype._resume = function() { this._ready = true; _R.prototype._exec.apply(this); };\r\n  _R.prototype._break = function(err) { this._orig._bad = true; this._orig._log.push(err || 'Unknown JZZ error'); };\r\n  _R.prototype._repair = function() { this._orig._bad = false; };\r\n  _R.prototype._crash = function(err) { this._break(err); this._resume(); };\r\n  _R.prototype._err = function() { return this._log[this._log.length - 1]; };\r\n  _R.prototype.log = function() { return _clone(this._log); };\r\n  _R.prototype._dup = function() {\r\n    var F = function() {};\r\n    F.prototype = this._orig;\r\n    var ret = new F();\r\n    ret._ready = false;\r\n    ret._queue = [];\r\n    return ret;\r\n  };\r\n  _R.prototype._image = function() { return this._dup(); };\r\n  _R.prototype._thenable = function() {\r\n    if (this.then) return this;\r\n    var self = this;\r\n    var F = function() {}; F.prototype = self;\r\n    var ret = new F();\r\n    ret.then = function(good, bad) { self._push(_then, [good, bad]); return this; };      \r\n    return ret;\r\n  };\r\n  function _then(good, bad) {\r\n    if (this._bad) {\r\n      if (_func(bad)) bad.apply(this, [new Error(this._err())]);\r\n    }\r\n    else {\r\n      if (_func(good)) good.apply(this, [this]);\r\n    }\r\n  }\r\n  function _wait(obj, delay) {\r\n    if (this._bad) obj._crash(this._err());\r\n    else setTimeout(function() { obj._resume(); }, delay);\r\n  }\r\n  _R.prototype.wait = function(delay) {\r\n    if (!delay) return this;\r\n    var ret = this._image();\r\n    this._push(_wait, [ret, delay]);\r\n    return ret._thenable();\r\n  };\r\n  function _kick(obj) { if (this._bad) obj._break(this._err()); obj._resume(); }\r\n  function _rechain(self, obj, name) {\r\n    self[name] = function() {\r\n      var arg = arguments;\r\n      var ret = obj._image();\r\n      this._push(_kick, [ret]);\r\n      return ret[name].apply(ret, arg);\r\n    };\r\n  }\r\n  function _and(q) {\r\n    if (!this._bad) {\r\n      if (_func(q)) q.apply(this); else console.log(q);\r\n    }\r\n  }\r\n  _R.prototype.and = function(func) { this._push(_and, [func]); return this._thenable(); };\r\n  function _or(q) {\r\n    if (this._bad) {\r\n      if (_func(q)) q.apply(this); else console.log(q);\r\n    }\r\n  }\r\n  _R.prototype.or = function(func) { this._push(_or, [func]); return this._thenable(); };\r\n\r\n  _R.prototype._info = {};\r\n  _R.prototype.info = function() {\r\n    var info = _clone(this._orig._info);\r\n    if (typeof info.engine == 'undefined') info.engine = 'none';\r\n    if (typeof info.sysex == 'undefined') info.sysex = true;\r\n    return info;\r\n  };\r\n  _R.prototype.name = function() { return this.info().name; };\r\n\r\n  function _close(obj) {\r\n    if (this._bad) obj._crash(this._err());\r\n    else {\r\n      this._break('Closed');\r\n      obj._resume();\r\n    }\r\n  }\r\n  _R.prototype.close = function() {\r\n    var ret = new _R();\r\n    if (this._close) this._push(this._close, []);\r\n    this._push(_close, [ret]);\r\n    return ret._thenable();\r\n  };\r\n\r\n  function _tryAny(arr) {\r\n    if (!arr.length) {\r\n      this._break();\r\n      return;\r\n    }\r\n    var func = arr.shift();\r\n    if (arr.length) {\r\n      var self = this;\r\n      this._slip(_or, [ function() { _tryAny.apply(self, [arr]); } ]);\r\n    }\r\n    try {\r\n      this._repair();\r\n      func.apply(this);\r\n    }\r\n    catch (err) {\r\n      this._break(err.toString());\r\n    }\r\n  }\r\n\r\n  function _push(arr, obj) {\r\n    for (var i = 0; i < arr.length; i++) if (arr[i] === obj) return;\r\n    arr.push(obj);\r\n  }\r\n  function _pop(arr, obj) {\r\n    for (var i = 0; i < arr.length; i++) if (arr[i] === obj) {\r\n      arr.splice(i, 1);\r\n      return;\r\n    }\r\n  }\r\n\r\n  // _J: JZZ object\r\n  function _J() {\r\n    _R.apply(this);\r\n  }\r\n  _J.prototype = new _R();\r\n\r\n  function _for(x, f) {\r\n    for(var k in x) if (x.hasOwnProperty(k)) f.call(this, k);\r\n  }\r\n  function _clone(obj, key, val) {\r\n    if (typeof key == 'undefined') return _clone(obj, [], []);\r\n    if (obj instanceof Object) {\r\n      for (var i = 0; i < key.length; i++) if (key[i] === obj) return val[i];\r\n      var ret;\r\n      if (obj instanceof Array) ret = []; else ret = {};\r\n      key.push(obj); val.push(ret);\r\n      _for(obj, function(k) { ret[k] = _clone(obj[k], key, val); });\r\n      return ret;\r\n    }\r\n    return obj;\r\n  }\r\n  _J.prototype._info = { name: 'JZZ.js', ver: _version, version: _version, inputs: [], outputs: [] };\r\n\r\n  var _outs = [];\r\n  var _ins = [];\r\n  var _outsW = [];\r\n  var _insW = [];\r\n\r\n  function _postRefresh() {\r\n    _jzz._info.engine = _engine._type;\r\n    _jzz._info.version = _engine._version;\r\n    _jzz._info.sysex = _engine._sysex;\r\n    _jzz._info.inputs = [];\r\n    _jzz._info.outputs = [];\r\n    _outs = [];\r\n    _ins = [];\r\n    _engine._allOuts = {};\r\n    _engine._allIns = {};\r\n    var i, x;\r\n    for (i = 0; i < _engine._outs.length; i++) {\r\n      x = _engine._outs[i];\r\n      x.engine = _engine;\r\n      _engine._allOuts[x.name] = x;\r\n      _jzz._info.outputs.push({\r\n        id: x.name,\r\n        name: x.name,\r\n        manufacturer: x.manufacturer,\r\n        version: x.version,\r\n        engine: _engine._type\r\n      });\r\n      _outs.push(x);\r\n    }\r\n    for (i = 0; i < _virtual._outs.length; i++) {\r\n      x = _virtual._outs[i];\r\n      _jzz._info.outputs.push({\r\n        id: x.name,\r\n        name: x.name,\r\n        manufacturer: x.manufacturer,\r\n        version: x.version,\r\n        engine: x.type\r\n      });\r\n      _outs.push(x);\r\n    }\r\n    for (i = 0; i < _engine._ins.length; i++) {\r\n      x = _engine._ins[i];\r\n      x.engine = _engine;\r\n      _engine._allIns[x.name] = x;\r\n      _jzz._info.inputs.push({\r\n        id: x.name,\r\n        name: x.name,\r\n        manufacturer: x.manufacturer,\r\n        version: x.version,\r\n        engine: _engine._type\r\n      });\r\n      _ins.push(x);\r\n    }\r\n    for (i = 0; i < _virtual._ins.length; i++) {\r\n      x = _virtual._ins[i];\r\n      _jzz._info.inputs.push({\r\n        id: x.name,\r\n        name: x.name,\r\n        manufacturer: x.manufacturer,\r\n        version: x.version,\r\n        engine: x.type\r\n      });\r\n      _ins.push(x);\r\n    }\r\n    if (_jzz._watcher && _jzz._watcher._handles.length) {\r\n      var diff = _diff(_insW, _outsW, _jzz._info.inputs, _jzz._info.outputs);\r\n       if (diff) {\r\n        for (j = 0; j < diff.inputs.removed.length; j++) {\r\n          x = _engine._inMap[diff.inputs.removed[j].name];\r\n          if (x) x._closeAll();\r\n        }\r\n        for (j = 0; j < diff.outputs.removed.length; j++) {\r\n          x = _engine._outMap[diff.outputs.removed[j].name];\r\n          if (x) x._closeAll();\r\n        }\r\n        _fireW(diff);\r\n      }\r\n    }\r\n    _insW = _jzz._info.inputs;\r\n    _outsW = _jzz._info.outputs;\r\n  }\r\n  function _refresh() {\r\n    if (!this._bad) _engine._refresh(this);\r\n  }\r\n  _J.prototype.refresh = function() {\r\n    this._push(_refresh, []);\r\n    return this._thenable();\r\n  };\r\n\r\n  function _filterList(q, arr) {\r\n    var i, n;\r\n    if (_func(q)) q = q(arr);\r\n    if (!(q instanceof Array)) q = [q];\r\n    var before = [];\r\n    var after = [];\r\n    var etc = arr.slice();\r\n    var a = before;\r\n    for (i = 0; i < q.length; i++) {\r\n      if (typeof q[i] == 'undefined') a = after;\r\n      else if (q[i] instanceof RegExp) for (n = 0; n < etc.length; n++) {\r\n        if (q[i].test(etc[n].name)) {\r\n          a.push(etc[n]);\r\n          etc.splice(n, 1);\r\n          n--;\r\n        }\r\n      }\r\n      else {\r\n        for (n = 0; n < etc.length; n++) if (q[i] + '' === n + '' || q[i] === etc[n].name || (q[i] instanceof Object && q[i].name === etc[n].name)) {\r\n          a.push(etc[n]);\r\n          etc.splice(n, 1);\r\n          n--;\r\n        }\r\n      }\r\n    }\r\n    return a == before ? before : before.concat(etc).concat(after);\r\n  }\r\n\r\n  function _notFound(port, q) {\r\n    var msg;\r\n    if (q instanceof RegExp) msg = 'Port matching ' + q + ' not found';\r\n    else if (q instanceof Object || typeof q == 'undefined') msg = 'Port not found';\r\n    else msg = 'Port \"' + q + '\" not found';\r\n    port._crash(msg);\r\n  }\r\n  function _openMidiOut(port, arg) {\r\n    if (this._bad) port._crash(this._err());\r\n    else {\r\n      var arr = _filterList(arg, _outs);\r\n      if (!arr.length) { _notFound(port, arg); return; }\r\n      var pack = function(x) { return function() { x.engine._openOut(this, x.name); }; };\r\n      for (var i = 0; i < arr.length; i++) arr[i] = pack(arr[i]);\r\n      port._slip(_tryAny, [arr]);\r\n      port._resume();\r\n    }\r\n  }\r\n  _J.prototype.openMidiOut = function(arg) {\r\n    var port = new _M();\r\n    this._push(_refresh, []);\r\n    this._push(_openMidiOut, [port, arg]);\r\n    return port._thenable();\r\n  };\r\n  _J.prototype._openMidiOutNR = function(arg) {\r\n    var port = new _M();\r\n    this._push(_openMidiOut, [port, arg]);\r\n    return port._thenable();\r\n  };\r\n\r\n  function _openMidiIn(port, arg) {\r\n    if (this._bad) port._crash(this._err());\r\n    else {\r\n      var arr = _filterList(arg, _ins);\r\n      if (!arr.length) { _notFound(port, arg); return; }\r\n      var pack = function(x) { return function() { x.engine._openIn(this, x.name); }; };\r\n      for (var i = 0; i < arr.length; i++) arr[i] = pack(arr[i]);\r\n      port._slip(_tryAny, [arr]);\r\n      port._resume();\r\n    }\r\n  }\r\n  _J.prototype.openMidiIn = function(arg) {\r\n    var port = new _M();\r\n    this._push(_refresh, []);\r\n    this._push(_openMidiIn, [port, arg]);\r\n    return port._thenable();\r\n  };\r\n  _J.prototype._openMidiInNR = function(arg) {\r\n    var port = new _M();\r\n    this._push(_openMidiIn, [port, arg]);\r\n    return port._thenable();\r\n  };\r\n\r\n  function _onChange(watcher, arg) {\r\n    if (this._bad) watcher._crash();\r\n    else {\r\n      watcher._slip(_connectW, [arg]);\r\n      watcher._resume();\r\n    }\r\n  }\r\n  _J.prototype.onChange = function(arg) {\r\n    if (!this._orig._watcher) this._orig._watcher = new _W();\r\n    var watcher = this._orig._watcher._image();\r\n    this._push(_onChange, [watcher, arg]);\r\n    return watcher._thenable();\r\n  };\r\n\r\n  _J.prototype._close = function() {\r\n    _engine._close();\r\n  };\r\n\r\n  // _M: MIDI-In/Out object\r\n  function _M() {\r\n    _R.apply(this);\r\n    this._handles = [];\r\n    this._outs = [];\r\n  }\r\n  _M.prototype = new _R();\r\n  _M.prototype._filter = function(msg) {\r\n    if (this._orig._mpe) {\r\n      var out;\r\n      var outs = 0;\r\n      if (this._handles && this._handles.length) {\r\n        outs = this._handles.length;\r\n        out = this._handles[0];\r\n      }\r\n      if (this._outs && this._outs.length) {\r\n        outs = this._outs.length;\r\n        out = this._outs[0];\r\n      }\r\n      if (outs == 1 && !out._mpe) {\r\n        msg = this._orig._mpe.filter(msg);\r\n      }\r\n    }\r\n    return msg;\r\n  };\r\n  _M.prototype._receive = function(msg) { this._emit(this._filter(msg)); };\r\n  function _receive(msg) { if (!this._bad) this._receive(msg); }\r\n  _M.prototype.send = function() {\r\n    this._push(_receive, [MIDI.apply(null, arguments)]);\r\n    return this._thenable();\r\n  };\r\n  _M.prototype.note = function(c, n, v, t) {\r\n    this.noteOn(c, n, v);\r\n    if (typeof this._ch == 'undefined' && typeof this._master == 'undefined') {\r\n      if (t > 0) this.wait(t).noteOff(c, n);\r\n    }\r\n    else {\r\n      if (v > 0) this.wait(v).noteOff(c);\r\n    }\r\n    return this._thenable();\r\n  };\r\n  _M.prototype._emit = function(msg) {\r\n    var i;\r\n    for (i = 0; i < this._handles.length; i++) this._handles[i].apply(this, [MIDI(msg)._stamp(this)]);\r\n    for (i = 0; i < this._outs.length; i++) {\r\n      var m = MIDI(msg);\r\n      if (!m._stamped(this._outs[i])) this._outs[i].send(m._stamp(this));\r\n    }\r\n  };\r\n  function _emit(msg) { this._emit(msg); }\r\n  _M.prototype.emit = function(msg) {\r\n    this._push(_emit, [msg]);\r\n    return this._thenable();\r\n  };\r\n  function _connect(arg) {\r\n    if (_func(arg)) _push(this._orig._handles, arg);\r\n    else _push(this._orig._outs, arg);\r\n  }\r\n  function _disconnect(arg) {\r\n    if (typeof arg == 'undefined') {\r\n      this._orig._handles = [];\r\n      this._orig._outs = [];\r\n    }\r\n    else if (_func(arg)) _pop(this._orig._handles, arg);\r\n    else _pop(this._orig._outs, arg);\r\n  }\r\n  _M.prototype.connect = function(arg) {\r\n    this._push(_connect, [arg]);\r\n    return this._thenable();\r\n  };\r\n  _M.prototype.disconnect = function(arg) {\r\n    this._push(_disconnect, [arg]);\r\n    return this._thenable();\r\n  };\r\n  _M.prototype.connected = function() {\r\n    return this._orig._handles.length + this._orig._outs.length;\r\n  };\r\n  _M.prototype._image = function() {\r\n    var dup = this._dup();\r\n    dup._ch = this._ch;\r\n    dup._sxid = this._sxid;\r\n    dup._master = this._master;\r\n    dup._band = this._band;\r\n    return dup;\r\n  };\r\n  _M.prototype._ch = undefined;\r\n  _M.prototype._sxid = 0x7f;\r\n  _M.prototype._master = undefined;\r\n  _M.prototype._band = undefined;\r\n\r\n  _M.prototype.sxId = function(id) {\r\n    if (typeof id == 'undefined') id = _M.prototype._sxid;\r\n    if (id == this._sxid) return this._thenable();\r\n    id = _7b(id);\r\n    var img = this._image();\r\n    img._sxid = id;\r\n    this._push(_kick, [img]);\r\n    return img._thenable();\r\n  };\r\n  _M.prototype.ch = function(c) {\r\n    if (c == this._ch || typeof c == 'undefined' && typeof this._ch == 'undefined') return this._thenable();\r\n    var img = this._image();\r\n    if (typeof c != 'undefined') c = _ch(c);\r\n    img._ch = c;\r\n    img._master = undefined;\r\n    img._band = undefined;\r\n    this._push(_kick, [img]);\r\n    return img._thenable();\r\n  };\r\n\r\n  function _mpe(m, n) {\r\n    if (!this._orig._mpe) this._orig._mpe = new MPE();\r\n    this._orig._mpe.setup(m, n);\r\n  }\r\n  _M.prototype.mpe = function(m, n) {\r\n    if (m == this._master && n == this._band || typeof m == 'undefined' && typeof this._master == 'undefined') return this._thenable();\r\n    if (typeof m != 'undefined') MPE.validate(m, n);\r\n    if (!n) return this.ch(m);\r\n    var img = this._image();\r\n    img._ch = undefined;\r\n    img._master = m;\r\n    img._band = n;\r\n    this._push(_mpe, [m, n]);\r\n    this._push(_kick, [img]);\r\n    return img._thenable();\r\n  };\r\n  function _validateChannel(c) {\r\n    if (c != parseInt(c) || c < 0 || c > 15)\r\n      throw RangeError('Bad channel value (must not be less than 0 or more than 15): ' + c);\r\n  }\r\n\r\n  // _W: Watcher object ~ MIDIAccess.onstatechange\r\n  function _W() {\r\n    _R.apply(this);\r\n    this._handles = [];\r\n    _rechain(this, _jzz, 'refresh');\r\n    _rechain(this, _jzz, 'openMidiOut');\r\n    _rechain(this, _jzz, 'openMidiIn');\r\n    _rechain(this, _jzz, 'onChange');\r\n    _rechain(this, _jzz, 'close');\r\n  }\r\n  _W.prototype = new _R();\r\n  function _connectW(arg) {\r\n    if (_func(arg)) {\r\n      if (!this._orig._handles.length) _engine._watch();\r\n      _push(this._orig._handles, arg);\r\n    }\r\n  }\r\n  function _disconnectW(arg) {\r\n    if (typeof arg == 'undefined') this._orig._handles = [];\r\n    else _pop(this._orig._handles, arg);\r\n    if (!this._orig._handles.length) _engine._unwatch();\r\n  }\r\n  _W.prototype.connect = function(arg) {\r\n    this._push(_connectW, [arg]);\r\n    return this._thenable();\r\n  };\r\n  _W.prototype.disconnect = function(arg) {\r\n    this._push(_disconnectW, [arg]);\r\n    return this._thenable();\r\n  };\r\n  function _changed(x0, y0, x1, y1) {\r\n    var i;\r\n    if (x0.length != x1.length || y0.length != y1.length) return true;\r\n    for (i = 0; i < x0.length; i++) if (x0[i].name != x1[i].name) return true;\r\n    for (i = 0; i < y0.length; i++) if (y0[i].name != y1[i].name) return true;\r\n    return false;\r\n  }\r\n  function _diff(x0, y0, x1, y1) {\r\n    if (!_changed(x0, y0, x1, y1)) return;\r\n    var ax = []; // added\r\n    var ay = [];\r\n    var rx = []; // removed\r\n    var ry = [];\r\n    var i;\r\n    var h = {};\r\n    for (i = 0; i < x0.length; i++) h[x0[i].name] = true;\r\n    for (i = 0; i < x1.length; i++) if (!h[x1[i].name]) ax.push(x1[i]);\r\n    h = {};\r\n    for (i = 0; i < x1.length; i++) h[x1[i].name] = true;\r\n    for (i = 0; i < x0.length; i++) if (!h[x0[i].name]) rx.push(x0[i]);\r\n    h = {};\r\n    for (i = 0; i < y0.length; i++) h[y0[i].name] = true;\r\n    for (i = 0; i < y1.length; i++) if (!h[y1[i].name]) ay.push(y1[i]);\r\n    h = {};\r\n    for (i = 0; i < y1.length; i++) h[y1[i].name] = true;\r\n    for (i = 0; i < y0.length; i++) if (!h[y0[i].name]) ry.push(y0[i]);\r\n    return { inputs: { added: ax, removed: rx }, outputs: { added: ay, removed: ry } };\r\n  }\r\n  function _fireW(arg) {\r\n    for (i = 0; i < _jzz._watcher._handles.length; i++) _jzz._watcher._handles[i].apply(_jzz, [arg]);\r\n  }\r\n\r\n  var _jzz;\r\n  var _engine = { _outs: [], _ins: [] };\r\n  var _virtual = { _outs: [], _ins: [] };\r\n\r\n  // // Node.js\r\n  // function _tryNODE() {\r\n  //   if (typeof module != 'undefined' && module.exports) {\r\n  //     var jazzmidi = require('jazz-midi');\r\n  //     if (jazzmidi) {\r\n  //       _initNode(jazzmidi);\r\n  //       return;\r\n  //     }\r\n  //   }\r\n  //   this._break();\r\n  // }\r\n  // Jazz-Plugin\r\n  function _tryJazzPlugin() {\r\n    var div = document.createElement('div');\r\n    div.style.visibility = 'hidden';\r\n    document.body.appendChild(div);\r\n    var obj = document.createElement('object');\r\n    obj.style.visibility = 'hidden';\r\n    obj.style.width = '0px'; obj.style.height = '0px';\r\n    obj.classid = 'CLSID:1ACE1618-1C7D-4561-AEE1-34842AA85E90';\r\n    obj.type = 'audio/x-jazz';\r\n    document.body.appendChild(obj);\r\n    /* istanbul ignore next */\r\n    if (obj.isJazz) {\r\n      _initJazzPlugin(obj);\r\n      return;\r\n    }\r\n    this._break();\r\n  }\r\n\r\n  // Web MIDI API\r\n  var _navigator;\r\n  var _requestMIDIAccess;\r\n  function _findMidiAccess() {\r\n    if (typeof navigator !== 'undefined' && navigator.requestMIDIAccess) {\r\n      _navigator = navigator;\r\n      _requestMIDIAccess = navigator.requestMIDIAccess;\r\n      try {\r\n        if (_requestMIDIAccess.toString().indexOf('JZZ(') != -1) _requestMIDIAccess = undefined;\r\n      }\r\n      catch (err) {}\r\n    }\r\n  }\r\n  function _tryWebMIDI() {\r\n    _findMidiAccess();\r\n    if (_requestMIDIAccess) {\r\n      var self = this;\r\n      var onGood = function(midi) {\r\n        _initWebMIDI(midi);\r\n        self._resume();\r\n      };\r\n      var onBad = function(msg) {\r\n        self._crash(msg);\r\n      };\r\n      var opt = {};\r\n      _requestMIDIAccess.call(_navigator, opt).then(onGood, onBad);\r\n      this._pause();\r\n      return;\r\n    }\r\n    this._break();\r\n  }\r\n  function _tryWebMIDIsysex() {\r\n    _findMidiAccess();\r\n    if (_requestMIDIAccess) {\r\n      var self = this;\r\n      var onGood = function(midi) {\r\n        _initWebMIDI(midi, true);\r\n        self._resume();\r\n      };\r\n      var onBad = function(msg) {\r\n        self._crash(msg);\r\n      };\r\n      var opt = { sysex:true };\r\n      _requestMIDIAccess.call(_navigator, opt).then(onGood, onBad);\r\n      this._pause();\r\n      return;\r\n    }\r\n    this._break();\r\n  }\r\n\r\n  // Web-extension\r\n  function _tryCRX() {\r\n    var self = this;\r\n    var inst;\r\n    var msg;\r\n    function eventHandle(evt) {\r\n      inst = true;\r\n      var a = evt.detail;\r\n      if (!a) {\r\n        if (!msg) msg = document.getElementById('jazz-midi-msg');\r\n        if (!msg) return;\r\n        try { a = JSON.parse(msg.innerText); } catch (err) {}\r\n        msg.innerText = '';\r\n      }\r\n      document.removeEventListener('jazz-midi-msg', eventHandle);\r\n      if (a[0] === 'version') {\r\n        _initCRX(msg, a[2]);\r\n        self._resume();\r\n      }\r\n      else {\r\n        self._crash();\r\n      }\r\n    }\r\n    this._pause();\r\n    try {\r\n      document.addEventListener('jazz-midi-msg', eventHandle);\r\n      document.dispatchEvent(new Event('jazz-midi'));\r\n    }\r\n    catch (err) {}\r\n    setTimeout(function() { if (!inst) self._crash(); }, 50);\r\n  }\r\n\r\n  /* istanbul ignore next */\r\n  function _zeroBreak() {\r\n    this._pause();\r\n    var self = this;\r\n    _schedule(function() { self._crash(); });\r\n  }\r\n\r\n  function _filterEngines(opt) {\r\n    var ret = [];\r\n    var arr = _filterEngineNames(opt);\r\n    for (var i = 0; i < arr.length; i++) {\r\n      if (arr[i] == 'webmidi') {\r\n        if (opt && opt.sysex === true) ret.push(_tryWebMIDIsysex);\r\n        if (!opt || opt.sysex !== true || opt.degrade === true) ret.push(_tryWebMIDI);\r\n      }\r\n      //else if (arr[i] == 'node') { ret.push(_tryNODE); ret.push(_zeroBreak); }\r\n      else if (arr[i] == 'extension') ret.push(_tryCRX);\r\n      else if (arr[i] == 'plugin') ret.push(_tryJazzPlugin);\r\n    }\r\n    ret.push(_initNONE);\r\n    return ret;\r\n  }\r\n\r\n  function _filterEngineNames(opt) {\r\n    var web = ['node', 'extension', 'plugin', 'webmidi'];\r\n    if (!opt || !opt.engine) return web;\r\n    var arr = opt.engine instanceof Array ? opt.engine : [opt.engine];\r\n    var dup = {};\r\n    var none;\r\n    var etc;\r\n    var head = [];\r\n    var tail = [];\r\n    var i;\r\n    for (i = 0; i < arr.length; i++) {\r\n      var name = arr[i].toString().toLowerCase();\r\n      if (dup[name]) continue;\r\n      dup[name] = true;\r\n      if (name === 'none') none = true;\r\n      if (name === 'etc' || typeof name == 'undefined') etc = true;\r\n      if (etc) tail.push(name); else head.push(name);\r\n      _pop(web, name);\r\n    }\r\n    if (etc || head.length || tail.length) none = false;\r\n    return none ? [] : head.concat(etc ? web : tail);\r\n  }\r\n\r\n  function _initJZZ(opt) {\r\n    _jzz = new _J();\r\n    _jzz._options = opt;\r\n    _jzz._push(_tryAny, [_filterEngines(opt)]);\r\n    _jzz.refresh();\r\n    _jzz._resume();\r\n  }\r\n\r\n  function _initNONE() {\r\n    _engine._type = 'none';\r\n    _engine._version = _version;\r\n    _engine._sysex = true;\r\n    _engine._outs = [];\r\n    _engine._ins = [];\r\n    _engine._refresh = function() { _postRefresh(); };\r\n    _engine._watch = _nop;\r\n    _engine._unwatch = _nop;\r\n    _engine._close = _nop;\r\n  }\r\n  // common initialization for Jazz-Plugin and jazz-midi\r\n  function _initEngineJP() {\r\n    _engine._inArr = [];\r\n    _engine._outArr = [];\r\n    _engine._inMap = {};\r\n    _engine._outMap = {};\r\n    _engine._outsW = [];\r\n    _engine._insW = [];\r\n    _engine._version = _engine._main.version;\r\n    _engine._sysex = true;\r\n    var watcher;\r\n    function _closeAll() {\r\n      for (var i = 0; i < this.clients.length; i++) this._close(this.clients[i]);\r\n    }\r\n    _engine._refresh = function() {\r\n      _engine._outs = [];\r\n      _engine._ins = [];\r\n      var i, x;\r\n      for (i = 0; (x = _engine._main.MidiOutInfo(i)).length; i++) {\r\n        _engine._outs.push({ type: _engine._type, name: x[0], manufacturer: x[1], version: x[2] });\r\n      }\r\n      for (i = 0; (x = _engine._main.MidiInInfo(i)).length; i++) {\r\n        _engine._ins.push({ type: _engine._type, name: x[0], manufacturer: x[1], version: x[2] });\r\n      }\r\n      _postRefresh();\r\n    };\r\n    _engine._openOut = function(port, name) {\r\n      var impl = _engine._outMap[name];\r\n      if (!impl) {\r\n        if (_engine._pool.length <= _engine._outArr.length) _engine._pool.push(_engine._newPlugin());\r\n        impl = {\r\n          name: name,\r\n          clients: [],\r\n          info: {\r\n            name: name,\r\n            manufacturer: _engine._allOuts[name].manufacturer,\r\n            version: _engine._allOuts[name].version,\r\n            type: 'MIDI-out',\r\n            sysex: _engine._sysex,\r\n            engine: _engine._type\r\n          },\r\n          _close: function(port) { _engine._closeOut(port); },\r\n          _closeAll: _closeAll,\r\n          _receive: function(a) { if (a.length) this.plugin.MidiOutRaw(a.slice()); }\r\n        };\r\n        var plugin = _engine._pool[_engine._outArr.length];\r\n        impl.plugin = plugin;\r\n        _engine._outArr.push(impl);\r\n        _engine._outMap[name] = impl;\r\n      }\r\n      if (!impl.open) {\r\n        var s = impl.plugin.MidiOutOpen(name);\r\n        if (s !== name) {\r\n          if (s) impl.plugin.MidiOutClose();\r\n          port._break(); return;\r\n        }\r\n        impl.open = true;\r\n      }\r\n      port._orig._impl = impl;\r\n      _push(impl.clients, port._orig);\r\n      port._info = impl.info;\r\n      port._receive = function(arg) { impl._receive(arg); };\r\n      port._close = function() { impl._close(this); };\r\n    };\r\n    _engine._openIn = function(port, name) {\r\n      var impl = _engine._inMap[name];\r\n      if (!impl) {\r\n        if (_engine._pool.length <= _engine._inArr.length) _engine._pool.push(_engine._newPlugin());\r\n        impl = {\r\n          name: name,\r\n          clients: [],\r\n          info: {\r\n            name: name,\r\n            manufacturer: _engine._allIns[name].manufacturer,\r\n            version: _engine._allIns[name].version,\r\n            type: 'MIDI-in',\r\n            sysex: _engine._sysex,\r\n            engine: _engine._type\r\n          },\r\n          _close: function(port) { _engine._closeIn(port); },\r\n          _closeAll: _closeAll,\r\n          handle: function(t, a) {\r\n            for (var i = 0; i < this.clients.length; i++) {\r\n              var msg = MIDI(a);\r\n              this.clients[i]._emit(msg);\r\n            }\r\n          }\r\n        };\r\n        var makeHandle = function(x) { return function(t, a) { x.handle(t, a); }; };\r\n        impl.onmidi = makeHandle(impl);\r\n        var plugin = _engine._pool[_engine._inArr.length];\r\n        impl.plugin = plugin;\r\n        _engine._inArr.push(impl);\r\n        _engine._inMap[name] = impl;\r\n      }\r\n      if (!impl.open) {\r\n        var s = impl.plugin.MidiInOpen(name, impl.onmidi);\r\n        if (s !== name) {\r\n          if (s) impl.plugin.MidiInClose();\r\n          port._break(); return;\r\n        }\r\n        impl.open = true;\r\n      }\r\n      port._orig._impl = impl;\r\n      _push(impl.clients, port._orig);\r\n      port._info = impl.info;\r\n      port._close = function() { impl._close(this); };\r\n    };\r\n    _engine._closeOut = function(port) {\r\n      var impl = port._impl;\r\n      _pop(impl.clients, port._orig);\r\n      if (!impl.clients.length && impl.open) {\r\n        impl.open = false;\r\n        impl.plugin.MidiOutClose();\r\n      }\r\n    };\r\n    _engine._closeIn = function(port) {\r\n      var impl = port._impl;\r\n      _pop(impl.clients, port._orig);\r\n      if (!impl.clients.length && impl.open) {\r\n        impl.open = false;\r\n        impl.plugin.MidiInClose();\r\n      }\r\n    };\r\n    _engine._close = function() {\r\n      for (var i = 0; i < _engine._inArr.length; i++) if (_engine._inArr[i].open) _engine._inArr[i].plugin.MidiInClose();\r\n      _engine._unwatch();\r\n    };\r\n    _engine._watch = function() {\r\n      if (!watcher) watcher = setInterval(function() { _engine._refresh(); }, 250);\r\n    };\r\n    _engine._unwatch = function() {\r\n      if (watcher) clearInterval(watcher);\r\n      watcher = undefined;\r\n    };\r\n  }\r\n\r\n  function _initNode(obj) {\r\n    _engine._type = 'node';\r\n    _engine._main = obj;\r\n    _engine._pool = [];\r\n    _engine._newPlugin = function() { return new obj.MIDI(); };\r\n    _initEngineJP();\r\n  }\r\n  /* istanbul ignore next */\r\n  function _initJazzPlugin(obj) {\r\n    _engine._type = 'plugin';\r\n    _engine._main = obj;\r\n    _engine._pool = [obj];\r\n    _engine._newPlugin = function() {\r\n      var plg = document.createElement('object');\r\n      plg.style.visibility = 'hidden';\r\n      plg.style.width = '0px'; obj.style.height = '0px';\r\n      plg.classid = 'CLSID:1ACE1618-1C7D-4561-AEE1-34842AA85E90';\r\n      plg.type = 'audio/x-jazz';\r\n      document.body.appendChild(plg);\r\n      return plg.isJazz ? plg : undefined;\r\n    };\r\n    _initEngineJP();\r\n  }\r\n  function _initWebMIDI(access, sysex) {\r\n    _engine._type = 'webmidi';\r\n    _engine._version = 43;\r\n    _engine._sysex = !!sysex;\r\n    _engine._access = access;\r\n    _engine._inMap = {};\r\n    _engine._outMap = {};\r\n    _engine._outsW = [];\r\n    _engine._insW = [];\r\n    var watcher;\r\n    function _closeAll() {\r\n      for (var i = 0; i < this.clients.length; i++) this._close(this.clients[i]);\r\n    }\r\n    _engine._refresh = function() {\r\n      _engine._outs = [];\r\n      _engine._ins = [];\r\n      _engine._access.outputs.forEach(function(port) {\r\n        _engine._outs.push({type: _engine._type, name: port.name, manufacturer: port.manufacturer, version: port.version});\r\n      });\r\n      _engine._access.inputs.forEach(function(port) {\r\n        _engine._ins.push({type: _engine._type, name: port.name, manufacturer: port.manufacturer, version: port.version});\r\n      });\r\n      _postRefresh();\r\n    };\r\n    _engine._openOut = function(port, name) {\r\n      var impl = _engine._outMap[name];\r\n      if (!impl) {\r\n        impl = {\r\n          name: name,\r\n          clients: [],\r\n          info: {\r\n            name: name,\r\n            manufacturer: _engine._allOuts[name].manufacturer,\r\n            version: _engine._allOuts[name].version,\r\n            type: 'MIDI-out',\r\n            sysex: _engine._sysex,\r\n            engine: _engine._type\r\n          },\r\n          _close: function(port) { _engine._closeOut(port); },\r\n          _closeAll: _closeAll,\r\n          _receive: function(a) { if (impl.dev && a.length) this.dev.send(a.slice()); }\r\n        };\r\n      }\r\n      var found;\r\n      _engine._access.outputs.forEach(function(dev) {\r\n        if (dev.name === name) found = dev;\r\n      });\r\n      if (found) {\r\n        impl.dev = found;\r\n        _engine._outMap[name] = impl;\r\n        port._orig._impl = impl;\r\n        _push(impl.clients, port._orig);\r\n        port._info = impl.info;\r\n        port._receive = function(arg) { impl._receive(arg); };\r\n        port._close = function() { impl._close(this); };\r\n        if (impl.dev.open) {\r\n          port._pause();\r\n          impl.dev.open().then(function() {\r\n            port._resume();\r\n          }, function() {\r\n            port._crash();\r\n          });\r\n        }\r\n      }\r\n      else port._break();\r\n    };\r\n    _engine._openIn = function(port, name) {\r\n      var impl = _engine._inMap[name];\r\n      if (!impl) {\r\n        impl = {\r\n          name: name,\r\n          clients: [],\r\n          info: {\r\n            name: name,\r\n            manufacturer: _engine._allIns[name].manufacturer,\r\n            version: _engine._allIns[name].version,\r\n            type: 'MIDI-in',\r\n            sysex: _engine._sysex,\r\n            engine: _engine._type\r\n          },\r\n          _close: function(port) { _engine._closeIn(port); },\r\n          _closeAll: _closeAll,\r\n          handle: function(evt) {\r\n            for (var i = 0; i < this.clients.length; i++) {\r\n              var msg = MIDI([].slice.call(evt.data));\r\n              this.clients[i]._emit(msg);\r\n            }\r\n          }\r\n        };\r\n      }\r\n      var found;\r\n      _engine._access.inputs.forEach(function(dev) {\r\n        if (dev.name === name) found = dev;\r\n      });\r\n      if (found) {\r\n        impl.dev = found;\r\n        var makeHandle = function(x) { return function(evt) { x.handle(evt); }; };\r\n        impl.dev.onmidimessage = makeHandle(impl);\r\n        _engine._inMap[name] = impl;\r\n        port._orig._impl = impl;\r\n        _push(impl.clients, port._orig);\r\n        port._info = impl.info;\r\n        port._close = function() { impl._close(this); };\r\n        if (impl.dev.open) {\r\n          port._pause();\r\n          impl.dev.open().then(function() {\r\n            port._resume();\r\n          }, function() {\r\n            port._crash();\r\n          });\r\n        }\r\n      }\r\n      else port._break();\r\n    };\r\n    _engine._closeOut = function(port) {\r\n      var impl = port._impl;\r\n      _pop(impl.clients, port._orig);\r\n      if (!impl.clients.length) {\r\n        if (impl.dev && impl.dev.close) impl.dev.close();\r\n        impl.dev = undefined;\r\n      }\r\n    };\r\n    _engine._closeIn = function(port) {\r\n      var impl = port._impl;\r\n      _pop(impl.clients, port._orig);\r\n      if (!impl.clients.length) {\r\n        if (impl.dev) {\r\n          impl.dev.onmidimessage = null;\r\n          if (impl.dev.close) impl.dev.close();\r\n        }\r\n        impl.dev = undefined;\r\n      }\r\n    };\r\n    _engine._close = function() {\r\n      _engine._unwatch();\r\n    };\r\n    _engine._watch = function() {\r\n      _engine._access.onstatechange = function() {\r\n        watcher = true;\r\n        _schedule(function() {\r\n          if (watcher) {\r\n            _engine._refresh();\r\n            watcher = false;\r\n          }\r\n        });\r\n      };\r\n    };\r\n    _engine._unwatch = function() {\r\n      _engine._access.onstatechange = undefined;\r\n    };\r\n  }\r\n  function _initCRX(msg, ver) {\r\n    _engine._type = 'extension';\r\n    _engine._version = ver;\r\n    _engine._sysex = true;\r\n    _engine._pool = [];\r\n    _engine._outs = [];\r\n    _engine._ins = [];\r\n    _engine._inArr = [];\r\n    _engine._outArr = [];\r\n    _engine._inMap = {};\r\n    _engine._outMap = {};\r\n    _engine._outsW = [];\r\n    _engine._insW = [];\r\n    _engine.refreshClients = [];\r\n    _engine._msg = msg;\r\n    _engine._newPlugin = function() {\r\n      var plugin = { id: _engine._pool.length };\r\n      _engine._pool.push(plugin);\r\n      if (!plugin.id) plugin.ready = true;\r\n      else document.dispatchEvent(new CustomEvent('jazz-midi', { detail: ['new'] }));\r\n    };\r\n    _engine._newPlugin();\r\n    _engine._refresh = function(client) {\r\n      _engine.refreshClients.push(client);\r\n      client._pause();\r\n      _schedule(function() {\r\n        document.dispatchEvent(new CustomEvent('jazz-midi', { detail: ['refresh'] }));\r\n      });\r\n    };\r\n    function _closeAll() {\r\n      for (var i = 0; i < this.clients.length; i++) this._close(this.clients[i]);\r\n    }\r\n    _engine._openOut = function(port, name) {\r\n      var impl = _engine._outMap[name];\r\n      if (!impl) {\r\n        if (_engine._pool.length <= _engine._outArr.length) _engine._newPlugin();\r\n        var plugin = _engine._pool[_engine._outArr.length];\r\n        impl = {\r\n          name: name,\r\n          clients: [],\r\n          info: {\r\n            name: name,\r\n            manufacturer: _engine._allOuts[name].manufacturer,\r\n            version: _engine._allOuts[name].version,\r\n            type: 'MIDI-out',\r\n            sysex: _engine._sysex,\r\n            engine: _engine._type\r\n          },\r\n          _start: function() { document.dispatchEvent(new CustomEvent('jazz-midi', { detail: ['openout', plugin.id, name] })); },\r\n          _close: function(port) { _engine._closeOut(port); },\r\n          _closeAll: _closeAll,\r\n          _receive: function(a) { if (a.length) { var v = a.slice(); v.splice(0, 0, 'play', plugin.id); document.dispatchEvent(new CustomEvent('jazz-midi', {detail: v})); } }\r\n        };\r\n        impl.plugin = plugin;\r\n        plugin.output = impl;\r\n        _engine._outArr.push(impl);\r\n        _engine._outMap[name] = impl;\r\n      }\r\n      port._orig._impl = impl;\r\n      _push(impl.clients, port._orig);\r\n      port._info = impl.info;\r\n      port._receive = function(arg) { impl._receive(arg); };\r\n      port._close = function() { impl._close(this); };\r\n      if (!impl.open) {\r\n        port._pause();\r\n        if (impl.plugin.ready) impl._start();\r\n      }\r\n    };\r\n    _engine._openIn = function(port, name) {\r\n      var impl = _engine._inMap[name];\r\n      if (!impl) {\r\n        if (_engine._pool.length <= _engine._inArr.length) _engine._newPlugin();\r\n        var plugin = _engine._pool[_engine._inArr.length];\r\n        impl = {\r\n          name: name,\r\n          clients: [],\r\n          info: {\r\n            name: name,\r\n            manufacturer: _engine._allIns[name].manufacturer,\r\n            version: _engine._allIns[name].version,\r\n            type: 'MIDI-in',\r\n            sysex: _engine._sysex,\r\n            engine: _engine._type\r\n          },\r\n          _start: function() { document.dispatchEvent(new CustomEvent('jazz-midi', { detail: ['openin', plugin.id, name] })); },\r\n          _close: function(port) { _engine._closeIn(port); },\r\n          _closeAll: _closeAll\r\n        };\r\n        impl.plugin = plugin;\r\n        plugin.input = impl;\r\n        _engine._inArr.push(impl);\r\n        _engine._inMap[name] = impl;\r\n      }\r\n      port._orig._impl = impl;\r\n      _push(impl.clients, port._orig);\r\n      port._info = impl.info;\r\n      port._close = function() { impl._close(this); };\r\n      if (!impl.open) {\r\n        port._pause();\r\n        if (impl.plugin.ready) impl._start();\r\n      }\r\n    };\r\n    _engine._closeOut = function(port) {\r\n      var impl = port._impl;\r\n      _pop(impl.clients, port._orig);\r\n      if (!impl.clients.length && impl.open) {\r\n        impl.open = false;\r\n        document.dispatchEvent(new CustomEvent('jazz-midi', { detail: ['closeout', impl.plugin.id] }));\r\n      }\r\n    };\r\n    _engine._closeIn = function(port) {\r\n      var impl = port._impl;\r\n      _pop(impl.clients, port._orig);\r\n      if (!impl.clients.length && impl.open) {\r\n        impl.open = false;\r\n        document.dispatchEvent(new CustomEvent('jazz-midi', { detail: ['closein', impl.plugin.id] }));\r\n      }\r\n    };\r\n    _engine._close = function() {\r\n      _engine._unwatch();\r\n    };\r\n    var watcher;\r\n    _engine._watch = function() {\r\n      _engine._insW = _engine._ins;\r\n      _engine._outsW = _engine._outs;\r\n      watcher = setInterval(function() {\r\n        document.dispatchEvent(new CustomEvent('jazz-midi', {detail:['refresh']}));\r\n      }, 250);\r\n    };\r\n    _engine._unwatch = function() {\r\n      clearInterval(watcher);\r\n      watcher = undefined;\r\n    };\r\n    document.addEventListener('jazz-midi-msg', function(evt) {\r\n      var i, j, impl;\r\n      var v = evt.detail ? [ evt.detail ] : undefined;\r\n      if (!v) {\r\n        v = _engine._msg.innerText.split('\\n');\r\n        _engine._msg.innerText = '';\r\n        for (i = 0; i < v.length; i++) try { v[i] = JSON.parse(v[i]); } catch (err) { v[i] = []; }\r\n      }\r\n      for (i = 0; i < v.length; i++) {\r\n        var a = v[i];\r\n        if (!a.length) continue;\r\n        if (a[0] === 'refresh') {\r\n          if (a[1].ins) {\r\n            for (j = 0; j < a[1].ins.length; j++) a[1].ins[j].type = _engine._type;\r\n            _engine._ins = a[1].ins;\r\n          }\r\n          if (a[1].outs) {\r\n            for (j = 0; j < a[1].outs.length; j++) a[1].outs[j].type = _engine._type;\r\n            _engine._outs = a[1].outs;\r\n          }\r\n          _postRefresh();\r\n          for (j = 0; j < _engine.refreshClients.length; j++) _engine.refreshClients[j]._resume();\r\n          _engine.refreshClients = [];\r\n        }\r\n        else if (a[0] === 'version') {\r\n          var plugin = _engine._pool[a[1]];\r\n          if (plugin) {\r\n            plugin.ready = true;\r\n            if (plugin.input) plugin.input._start();\r\n            if (plugin.output) plugin.output._start();\r\n          }\r\n        }\r\n        else if (a[0] === 'openout') {\r\n          impl = _engine._pool[a[1]].output;\r\n          if (impl) {\r\n            if (a[2] == impl.name) {\r\n              impl.open = true;\r\n              if (impl.clients) for (j = 0; j < impl.clients.length; j++) impl.clients[j]._resume();\r\n            }\r\n            else if (impl.clients) for (j = 0; j < impl.clients.length; j++) impl.clients[j]._crash();\r\n          }\r\n        }\r\n        else if (a[0] === 'openin') {\r\n          impl = _engine._pool[a[1]].input;\r\n          if (impl) {\r\n            if (a[2] == impl.name) {\r\n              impl.open = true;\r\n              if (impl.clients) for (j = 0; j < impl.clients.length; j++) impl.clients[j]._resume();\r\n            }\r\n            else if (impl.clients) for (j = 0; j < impl.clients.length; j++) impl.clients[j]._crash();\r\n          }\r\n        }\r\n        else if (a[0] === 'midi') {\r\n          impl = _engine._pool[a[1]].input;\r\n          if (impl && impl.clients) {\r\n            for (j = 0; j < impl.clients.length; j++) {\r\n              var msg = MIDI(a.slice(3));\r\n              impl.clients[j]._emit(msg);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  var JZZ = function(opt) {\r\n    if (!_jzz) _initJZZ(opt);\r\n    return _jzz._thenable();\r\n  };\r\n  JZZ.JZZ = JZZ;\r\n  JZZ.version = _version;\r\n  JZZ.info = function() { return _J.prototype.info(); };\r\n\r\n  function Widget(arg) {\r\n    var self = new _M();\r\n    if (arg instanceof Object) _for(arg, function(k) { self[k] = arg[k]; });\r\n    self._resume();\r\n    return self;\r\n  }\r\n  JZZ.Widget = Widget;\r\n  _J.prototype.Widget = JZZ.Widget;\r\n  JZZ.addMidiIn = function(name, widget) {\r\n    var info = _clone(widget._info || {});\r\n    info.name = name;\r\n    info.type = info.type || 'javascript';\r\n    info.manufacturer = info.manufacturer || 'virtual';\r\n    info.version = info.version || '0.0';\r\n    var engine = {\r\n      _info: function() { return info; },\r\n      _openIn: function(port) {\r\n        port._pause();\r\n        port._info = _clone(info);\r\n        port._close = function() { widget.disconnect(port); };\r\n        widget.connect(port);\r\n        port._resume();\r\n      }\r\n    };\r\n    return JZZ.lib.registerMidiIn(name, engine);\r\n  };\r\n  JZZ.addMidiOut = function(name, widget) {\r\n    var info = _clone(widget._info || {});\r\n    info.name = name;\r\n    info.type = info.type || 'javascript';\r\n    info.manufacturer = info.manufacturer || 'virtual';\r\n    info.version = info.version || '0.0';\r\n    var engine = {\r\n      _info: function() { return info; },\r\n      _openOut: function(port) {\r\n        port._pause();\r\n        port._info = _clone(info);\r\n        port._close = function() { port.disconnect(); };\r\n        _connect.apply(port, [widget]);\r\n        port._resume();\r\n      }\r\n    };\r\n    return JZZ.lib.registerMidiOut(name, engine);\r\n  };\r\n\r\n  // JZZ.SMPTE\r\n\r\n  function SMPTE() {\r\n    var self = this instanceof SMPTE ? this : self = new SMPTE();\r\n    SMPTE.prototype.reset.apply(self, arguments);\r\n    return self;\r\n  }\r\n  SMPTE.prototype.reset = function(arg) {\r\n    if (arg instanceof SMPTE) {\r\n      this.setType(arg.getType());\r\n      this.setHour(arg.getHour());\r\n      this.setMinute(arg.getMinute());\r\n      this.setSecond(arg.getSecond());\r\n      this.setFrame(arg.getFrame());\r\n      this.setQuarter(arg.getQuarter());\r\n      return this;\r\n    }\r\n    var arr = arg instanceof Array ? arg : arguments;\r\n    this.setType(arr[0]);\r\n    this.setHour(arr[1]);\r\n    this.setMinute(arr[2]);\r\n    this.setSecond(arr[3]);\r\n    this.setFrame(arr[4]);\r\n    this.setQuarter(arr[5]);\r\n    return this;\r\n  };\r\n  function _fixDropFrame() { if (this.type == 29.97 && !this.second && this.frame < 2 && this.minute % 10) this.frame = 2; }\r\n  SMPTE.prototype.isFullFrame = function() { return this.quarter == 0 || this.quarter == 4; };\r\n  SMPTE.prototype.getType = function() { return this.type; };\r\n  SMPTE.prototype.getHour = function() { return this.hour; };\r\n  SMPTE.prototype.getMinute = function() { return this.minute; };\r\n  SMPTE.prototype.getSecond = function() { return this.second; };\r\n  SMPTE.prototype.getFrame = function() { return this.frame; };\r\n  SMPTE.prototype.getQuarter = function() { return this.quarter; };\r\n  SMPTE.prototype.setType = function(x) {\r\n    if (typeof x == 'undefined' || x == 24) this.type = 24;\r\n    else if (x == 25) this.type = 25;\r\n    else if (x == 29.97) { this.type = 29.97; _fixDropFrame.apply(this); }\r\n    else if (x == 30) this.type = 30;\r\n    else throw RangeError('Bad SMPTE frame rate: ' + x);\r\n    if (this.frame >= this.type) this.frame = this.type - 1; // could not be more than 29\r\n    return this;\r\n  };\r\n  SMPTE.prototype.setHour = function(x) {\r\n    if (typeof x == 'undefined') x = 0;\r\n    if (x != parseInt(x) || x < 0 || x >= 24) throw RangeError('Bad SMPTE hours value: ' + x);\r\n    this.hour = x;\r\n    return this;\r\n  };\r\n  SMPTE.prototype.setMinute = function(x) {\r\n    if (typeof x == 'undefined') x = 0;\r\n    if (x != parseInt(x) || x < 0 || x >= 60) throw RangeError('Bad SMPTE minutes value: ' + x);\r\n    this.minute = x;\r\n    _fixDropFrame.apply(this);\r\n    return this;\r\n  };\r\n  SMPTE.prototype.setSecond = function(x) {\r\n    if (typeof x == 'undefined') x = 0;\r\n    if (x != parseInt(x) || x < 0 || x >= 60) throw RangeError('Bad SMPTE seconds value: ' + x);\r\n    this.second = x;\r\n    _fixDropFrame.apply(this);\r\n    return this;\r\n  };\r\n  SMPTE.prototype.setFrame = function(x) {\r\n    if (typeof x == 'undefined') x = 0;\r\n    if (x != parseInt(x) || x < 0 || x >= this.type) throw RangeError('Bad SMPTE frame number: ' + x);\r\n    this.frame = x;\r\n    _fixDropFrame.apply(this);\r\n    return this;\r\n  };\r\n  SMPTE.prototype.setQuarter = function(x) {\r\n    if (typeof x == 'undefined') x = 0;\r\n    if (x != parseInt(x) || x < 0 || x >= 8) throw RangeError('Bad SMPTE quarter frame: ' + x);\r\n    this.quarter = x;\r\n    return this;\r\n  };\r\n  SMPTE.prototype.incrFrame = function() {\r\n    this.frame++;\r\n    if (this.frame >= this.type) {\r\n      this.frame = 0;\r\n      this.second++;\r\n      if (this.second >= 60) {\r\n        this.second = 0;\r\n        this.minute++;\r\n        if (this.minute >= 60) {\r\n          this.minute = 0;\r\n          this.hour = this.hour >= 23 ? 0 : this.hour + 1;\r\n        }\r\n      }\r\n    }\r\n    _fixDropFrame.apply(this);\r\n    return this;\r\n  };\r\n  SMPTE.prototype.decrFrame = function() {\r\n    if (!this.second && this.frame == 2 && this.type == 29.97 && this.minute % 10) this.frame = 0; // drop-frame\r\n    this.frame--;\r\n    if (this.frame < 0) {\r\n      this.frame = this.type == 29.97 ? 29 : this.type - 1;\r\n      this.second--;\r\n      if (this.second < 0) {\r\n        this.second = 59;\r\n        this.minute--;\r\n        if (this.minute < 0) {\r\n          this.minute = 59;\r\n          this.hour = this.hour ? this.hour - 1 : 23;\r\n        }\r\n      }\r\n    }\r\n    return this;\r\n  };\r\n  SMPTE.prototype.incrQF = function() {\r\n    this.backwards = false;\r\n    this.quarter = (this.quarter + 1) & 7;\r\n    if (this.quarter == 0 || this.quarter == 4) this.incrFrame();\r\n    return this;\r\n  };\r\n  SMPTE.prototype.decrQF = function() {\r\n    this.backwards = true;\r\n    this.quarter = (this.quarter + 7) & 7;\r\n    if (this.quarter == 3 || this.quarter == 7) this.decrFrame();\r\n    return this;\r\n  };\r\n  function _825(a) { return [[24, 25, 29.97, 30][(a[7] >> 1) & 3], ((a[7] & 1) << 4) | a[6], (a[5] << 4) | a[4], (a[3] << 4) | a[2], (a[1] << 4) | a[0]]; }\r\n  SMPTE.prototype.read = function(m) {\r\n    if (!(m instanceof MIDI)) m = MIDI.apply(null, arguments);\r\n    if (m[0] == 0xf0 && m[1] == 0x7f && m[3] == 1 && m[4] == 1 && m[9] == 0xf7) {\r\n      this.type = [24, 25, 29.97, 30][(m[5] >> 5) & 3];\r\n      this.hour = m[5] & 31;\r\n      this.minute = m[6];\r\n      this.second = m[7];\r\n      this.frame = m[8];\r\n      this.quarter = 0;\r\n      this._ = undefined;\r\n      this._b = undefined;\r\n      this._f = undefined;\r\n      return true;\r\n    }\r\n    if (m[0] == 0xf1 && typeof m[1] != 'undefined') {\r\n      var q = m[1] >> 4;\r\n      var n = m[1] & 15;\r\n      if (q == 0) {\r\n        if (this._ == 7) {\r\n          if (this._f == 7) {\r\n            this.reset(_825(this._a));\r\n            this.incrFrame();\r\n          }\r\n          this.incrFrame();\r\n        }\r\n      }\r\n      else if (q == 3) {\r\n        if (this._ == 4) {\r\n          this.decrFrame();\r\n        }\r\n      }\r\n      else if (q == 4) {\r\n        if (this._ == 3) {\r\n          this.incrFrame();\r\n        }\r\n      }\r\n      else if (q == 7) {\r\n        if (this._ === 0) {\r\n          if (this._b === 0) {\r\n            this.reset(_825(this._a));\r\n            this.decrFrame();\r\n          }\r\n          this.decrFrame();\r\n        }\r\n      }\r\n      if (!this._a) this._a = [];\r\n      this._a[q] = n;\r\n      this._f = this._f === q - 1 || q == 0 ? q : undefined;\r\n      this._b = this._b === q + 1 || q == 7 ? q : undefined;\r\n      this._ = q;\r\n      this.quarter = q;\r\n      return true;\r\n    }\r\n    return false;\r\n  };\r\n  function _mtc(t) {\r\n    if (!t.backwards && t.quarter >= 4) t.decrFrame(); // continue encoding previous frame\r\n    else if (t.backwards && t.quarter < 4) t.incrFrame();\r\n    var ret;\r\n    switch (t.quarter >> 1) {\r\n      case 0: ret = t.frame; break;\r\n      case 1: ret = t.second; break;\r\n      case 2: ret = t.minute; break;\r\n      default: ret = t.hour;\r\n    }\r\n    if (t.quarter & 1) ret >>= 4;\r\n    else ret &= 15;\r\n    if (t.quarter == 7) {\r\n      if (t.type == 25) ret |= 2;\r\n      else if (t.type == 29.97) ret |= 4;\r\n      else if (t.type == 30) ret |= 6;\r\n    }\r\n    // restore original t\r\n    if (!t.backwards && t.quarter >= 4) t.incrFrame();\r\n    else if (t.backwards && t.quarter < 4) t.decrFrame();\r\n    return ret | (t.quarter << 4);\r\n  }\r\n  function _hrtype(t) {\r\n    if (t.type == 25) return t.hour | 0x20;\r\n    if (t.type == 29.97) return t.hour | 0x40;\r\n    if (t.type == 30) return t.hour | 0x60;\r\n    return t.hour;\r\n  }\r\n  function _dec(x) { return x < 10 ? '0' + x : x; }\r\n  function _smptetxt(x) {\r\n    var arr = [];\r\n    for (var i = 0; i < x.length; i++) arr[i] = _dec(i ? x[i] : x[i] & 0x1f);\r\n    return arr.join(':');\r\n  }\r\n  SMPTE.prototype.toString = function() { return _smptetxt([this.hour, this.minute, this.second, this.frame]); };\r\n  JZZ.SMPTE = SMPTE;\r\n  _J.prototype.SMPTE = SMPTE;\r\n\r\n  // JZZ.MIDI\r\n\r\n  function MIDI(arg) {\r\n    var self = this instanceof MIDI ? this : self = new MIDI();\r\n    var i;\r\n    if (arg instanceof MIDI) {\r\n      self._from = arg._from.slice();\r\n      _for(arg, function(i) { if (i != '_from') self[i] = arg[i]; });\r\n      return self;\r\n    }\r\n    else self._from = [];\r\n    if (typeof arg == 'undefined') return self;\r\n    var arr = arg instanceof Array ? arg : arguments;\r\n    for (i = 0; i < arr.length; i++) {\r\n      n = arr[i];\r\n      if (i == 1) {\r\n        if (self[0] >= 0x80 && self[0] <= 0xAF) n = MIDI.noteValue(n);\r\n        if (self[0] >= 0xC0 && self[0] <= 0xCF) n = MIDI.programValue(n);\r\n      }\r\n      if (n != parseInt(n) || n < 0 || n > 255) _throw(arr[i]);\r\n      self.push(n);\r\n    }\r\n    return self;\r\n  }\r\n  MIDI.prototype = [];\r\n  MIDI.prototype.constructor = MIDI;\r\n  var _noteNum = {};\r\n  MIDI.noteValue = function(x) { return typeof x == 'undefined' ? undefined : _noteNum[x.toString().toLowerCase()]; };\r\n  MIDI.programValue = function(x) { return x; };\r\n  MIDI.octaveValue = function(x) {\r\n    var n = _noteNum[x.toString().toLowerCase()];\r\n    if (typeof n == 'undefined') n = _noteNum[x.toString().toLowerCase() + '1'];\r\n    return typeof n == 'undefined' ? undefined : n % 12;\r\n  };\r\n  MIDI.freq = function(n, a) {\r\n    if (typeof a == 'undefined') a = 440.0;\r\n    _float(a);\r\n    if (n != parseFloat(n)) n = _7bn(n);\r\n    return (a * Math.pow(2, (n - 69.0) / 12.0));\r\n  };\r\n  function _float(x) { if (x != parseFloat(x)) throw TypeError('Not a number: ' + x); }\r\n  MIDI.shift = function(f, f0) {\r\n    if (typeof f0 == 'undefined') f0 = 440;\r\n    _float(f);\r\n    _float(f0);\r\n    return Math.log2(f / f0) * 12;\r\n  };\r\n  MIDI.midi = function(f, f0) {\r\n    if (f != parseFloat(f)) return _7bn(f);\r\n    return MIDI.shift(f, f0) + 69;\r\n  };\r\n  MIDI.to7b = function(x) {\r\n    _float(x);\r\n    return x <= 0 ? 0 : x >= 1 ? 0x7f : Math.floor(x * 0x80);\r\n  };\r\n  MIDI.to14b = function(x) {\r\n    _float(x);\r\n    return x <= 0 ? 0 : x >= 1 ? 0x3fff : Math.floor(x * 0x4000);\r\n  };\r\n  MIDI.to21b = function(x) {\r\n    if (typeof x == 'undefined') return 0x1fffff;\r\n    _float(x);\r\n    if (x <= 0) return 0;\r\n    x = (Math.floor(x) << 14) + MIDI.to14b(x - Math.floor(x));\r\n    return x < 0x1fffff ? x : 0x1ffffe;\r\n  };\r\n  function _MIDI() {}\r\n  _MIDI.prototype = MIDI;\r\n  MIDI._sxid = 0x7f;\r\n  MIDI.sxId = function(id) {\r\n    if (typeof id == 'undefined') id = MIDI._sxid;\r\n    if (id == this._sxid) return this;\r\n    id = _7b(id);\r\n    var ret = new _MIDI();\r\n    ret._ch = this._ch;\r\n    ret._sxid = id;\r\n    return ret;\r\n  };\r\n  MIDI.ch = function(c) {\r\n    if (c == this._ch || typeof c == 'undefined' && typeof this._ch == 'undefined') return this;\r\n    var ret = new _MIDI();\r\n    if (typeof c != 'undefined') c = _ch(c);\r\n    ret._ch = c;\r\n    ret._sxid = this._sxid;\r\n    return ret;\r\n  };\r\n\r\n  var _noteMap = { c:0, d:2, e:4, f:5, g:7, a:9, b:11, h:11 };\r\n  _for(_noteMap, function(k) {\r\n    for (n = 0; n < 12; n++) {\r\n      m = _noteMap[k] + n * 12;\r\n      if (m > 127) break;\r\n      _noteNum[k + n] = m; _noteNum[k + '♮' + n] = m;\r\n      if (m > 0) {\r\n        _noteNum[k + 'b' + n] = m - 1; _noteNum[k + '♭' + n] = m - 1;\r\n        _noteNum[k + 'bb' + n] = m - 2; _noteNum[k + '♭♭' + n] = m - 2; _noteNum[k + '𝄫' + n] = m - 2;\r\n      }\r\n      if (m < 127) {\r\n        _noteNum[k + '#' + n] = m + 1; _noteNum[k + '♯' + n] = m + 1;\r\n        _noteNum[k + '##' + n] = m + 2; _noteNum[k + '♯♯' + n] = m + 2; _noteNum[k + '𝄪' + n] = m + 2;\r\n      }\r\n    }\r\n  });\r\n  for (n = 0; n < 128; n++) _noteNum[n] = n;\r\n  function _throw(x) { throw RangeError('Bad MIDI value: ' + x); }\r\n  function _bad(x) { throw TypeError('Invalid value: ' + x); }\r\n  function _oor(x) { throw RangeError('Out of range: ' + x); }\r\n  function _ch(c) { _validateChannel(c); return parseInt(c); }\r\n  function _7b(n, m) { if (n != parseInt(n) || n < 0 || n > 0x7f) _throw(typeof m == 'undefined' ? n : m); return parseInt(n); }\r\n  function _8b(n) { if (n != parseInt(n) || n < 0 || n > 0xff) _throw(n); return parseInt(n); }\r\n  function _14b(n) { if (n != parseInt(n) || n < 0 || n > 0x3fff) _throw(n); return parseInt(n); }\r\n  function _16b(n) { if (n != parseInt(n) || n < 0 || n > 0xffff) throw RangeError('Expected a 16-bit value: ' + n); return parseInt(n); }\r\n  function _21b(n) { if (n != parseInt(n) || n < 0 || n > 0x1fffff) _throw(n); return parseInt(n); }\r\n  function _7bn(n) { return _7b(MIDI.noteValue(n), n); }\r\n  function _lsb(n) { return _14b(n) & 0x7f; }\r\n  function _msb(n) { return _14b(n) >> 7; }\r\n  function _8bs(s) { s = '' + s; for (var i = 0; i < s.length; i++) if (s.charCodeAt(i) > 255) _throw(s[i]); return s; }\r\n  function _to777(n) { return [n >> 14, (n >> 7) & 0x7f, n & 0x7f]; }\r\n  function _01(x, y) {\r\n    if (x != parseFloat(x)) _bad(typeof y == 'undefined' ? x : y);\r\n    if (x < 0 || x > 1) _oor(typeof y == 'undefined' ? x : y);\r\n    return parseFloat(x);\r\n }\r\n  function _rt(b) { return typeof b != 'undefined' && !b ? 0x7E : 0x7F; }\r\n  function _ntu(x) {\r\n    var k, m;\r\n    var kkk = [];\r\n    var vvv = {};\r\n    _for(x, function(k) {\r\n      m = _21b(x[k]);\r\n      k = _7bn(k);\r\n      if (k in vvv) throw RangeError('Duplicate MIDI value: ' + k);\r\n      kkk.push(k);\r\n      vvv[k] = m;\r\n    });\r\n    kkk.sort();\r\n    var out = [kkk.length];\r\n    for (k = 0; k < kkk.length; k++) out = out.concat([kkk[k]], _to777(vvv[kkk[k]]));\r\n    return out;\r\n  }\r\n  function _f2ntu(x) {\r\n    var out = {};\r\n    _for (x, function(k) { out[k] = MIDI.to21b(x[k] == parseFloat(x[k]) ? x[k] : _7bn(x[k])); });\r\n    return out;\r\n  }\r\n  function _hz2ntu(x) {\r\n    var out = {};\r\n    _for (x, function(k) { out[k] = MIDI.to21b(MIDI.midi(x[k])); });\r\n    return out;\r\n  }\r\n  function _12x7(a) {\r\n    var out = [];\r\n    if (!(a instanceof Array) || a.length != 12) throw TypeError('Expected an array of size 12');\r\n    for (var i = 0; i < 12; i++) out.push(_7b(a[i]));\r\n    return out;\r\n  }\r\n  function _12x14(a) {\r\n    var out = [];\r\n    if (!(a instanceof Array) || a.length != 12) throw TypeError('Expected an array of size 12');\r\n    for (var i = 0; i < 12; i++) {\r\n      out.push(_msb(a[i]));\r\n      out.push(_lsb(a[i]));\r\n    }\r\n    return out;\r\n  }\r\n  var _helperMPE = {\r\n    noteOff: function(c, n, v) { if (typeof v == 'undefined') v = 64; return [0x80 + _ch(c), _7bn(n), _7b(v)]; },\r\n    noteOn: function(c, n, v) { if (typeof v == 'undefined') v = 127; return [0x90 + _ch(c), _7bn(n), _7b(v)]; },\r\n    aftertouch: function(c, n, v) { return [0xA0 + _ch(c), _7bn(n), _7b(v)]; },\r\n  };\r\n  var _helperCH = {\r\n    control: function(c, n, v) { return [0xB0 + _ch(c), _7b(n), _7b(v)]; },\r\n    program: function(c, n) { return [0xC0 + _ch(c), _7b(MIDI.programValue(n), n)]; },\r\n    pressure: function(c, n) { return [0xD0 + _ch(c), _7b(n)]; },\r\n    pitchBend: function(c, n, l) { return typeof l == 'undefined' ? [0xE0 + _ch(c), _lsb(n), _msb(n)] : [0xE0 + _ch(c), _7b(l), _7b(n)]; },\r\n    pitchBendF: function(c, x) { return _helperCH.pitchBend(c, MIDI.to14b((x + 1) / 2)); },\r\n    bankMSB: function(c, n) { return [0xB0 + _ch(c), 0x00, _7b(n)]; },\r\n    bankLSB: function(c, n) { return [0xB0 + _ch(c), 0x20, _7b(n)]; },\r\n    modMSB: function(c, n) { return [0xB0 + _ch(c), 0x01, _7b(n)]; },\r\n    modLSB: function(c, n) { return [0xB0 + _ch(c), 0x21, _7b(n)]; },\r\n    breathMSB: function(c, n) { return [0xB0 + _ch(c), 0x02, _7b(n)]; },\r\n    breathLSB: function(c, n) { return [0xB0 + _ch(c), 0x22, _7b(n)]; },\r\n    footMSB: function(c, n) { return [0xB0 + _ch(c), 0x04, _7b(n)]; },\r\n    footLSB: function(c, n) { return [0xB0 + _ch(c), 0x24, _7b(n)]; },\r\n    portamentoMSB: function(c, n) { return [0xB0 + _ch(c), 0x05, _7b(n)]; },\r\n    portamentoLSB: function(c, n) { return [0xB0 + _ch(c), 0x25, _7b(n)]; },\r\n    dataMSB: function(c, n) { return [0xB0 + _ch(c), 0x06, _7b(n)]; },\r\n    dataLSB: function(c, n) { return [0xB0 + _ch(c), 0x26, _7b(n)]; },\r\n    volumeMSB: function(c, n) { return [0xB0 + _ch(c), 0x07, _7b(n)]; },\r\n    volumeLSB: function(c, n) { return [0xB0 + _ch(c), 0x27, _7b(n)]; },\r\n    balanceMSB: function(c, n) { return [0xB0 + _ch(c), 0x08, _7b(n)]; },\r\n    balanceLSB: function(c, n) { return [0xB0 + _ch(c), 0x28, _7b(n)]; },\r\n    panMSB: function(c, n) { return [0xB0 + _ch(c), 0x0A, _7b(n)]; },\r\n    panLSB: function(c, n) { return [0xB0 + _ch(c), 0x2A, _7b(n)]; },\r\n    expressionMSB: function(c, n) { return [0xB0 + _ch(c), 0x0B, _7b(n)]; },\r\n    expressionLSB: function(c, n) { return [0xB0 + _ch(c), 0x2B, _7b(n)]; },\r\n    damper: function(c, b) { if (typeof b == 'undefined') b = true; return [0xB0 + _ch(c), 0x40, b ? 127 : 0]; },\r\n    portamento: function(c, b) { if (typeof b == 'undefined') b = true; return [0xB0 + _ch(c), 0x41, b ? 127 : 0]; },\r\n    sostenuto: function(c, b) { if (typeof b == 'undefined') b = true; return [0xB0 + _ch(c), 0x42, b ? 127 : 0]; },\r\n    soft: function(c, b) { if (typeof b == 'undefined') b = true; return [0xB0 + _ch(c), 0x43, b ? 127 : 0]; },\r\n    legato: function(c, b) { if (typeof b == 'undefined') b = true; return [0xB0 + _ch(c), 0x44, b ? 127 : 0]; },\r\n    hold2: function(c, b) { if (typeof b == 'undefined') b = true; return [0xB0 + _ch(c), 0x45, b ? 127 : 0]; },\r\n    soundVariation: function(c, n) { return [0xB0 + _ch(c), 0x46, _7bn(n)]; },\r\n    filterResonance: function(c, n) { return [0xB0 + _ch(c), 0x47, _7bn(n)]; },\r\n    releaseTime: function(c, n) { return [0xB0 + _ch(c), 0x48, _7bn(n)]; },\r\n    attackTime: function(c, n) { return [0xB0 + _ch(c), 0x49, _7bn(n)]; },\r\n    brightness: function(c, n) { return [0xB0 + _ch(c), 0x4A, _7bn(n)]; },\r\n    decayTime: function(c, n) { return [0xB0 + _ch(c), 0x4B, _7bn(n)]; },\r\n    vibratoRate: function(c, n) { return [0xB0 + _ch(c), 0x4C, _7bn(n)]; },\r\n    vibratoDepth: function(c, n) { return [0xB0 + _ch(c), 0x4D, _7bn(n)]; },\r\n    vibratoDelay: function(c, n) { return [0xB0 + _ch(c), 0x4E, _7bn(n)]; },\r\n    ptc: function(c, n) { return [0xB0 + _ch(c), 0x54, _7bn(n)]; },\r\n    dataIncr: function(c) { return [0xB0 + _ch(c), 0x60, 0]; },\r\n    dataDecr: function(c) { return [0xB0 + _ch(c), 0x61, 0]; },\r\n    nrpnLSB: function(c, n) { return [0xB0 + _ch(c), 0x62, _7b(n)]; },\r\n    nrpnMSB: function(c, n) { return [0xB0 + _ch(c), 0x63, _7b(n)]; },\r\n    rpnLSB: function(c, n) { return [0xB0 + _ch(c), 0x64, _7b(n)]; },\r\n    rpnMSB: function(c, n) { return [0xB0 + _ch(c), 0x65, _7b(n)]; },\r\n    allSoundOff: function(c) { return [0xB0 + _ch(c), 0x78, 0]; },\r\n    resetAllControllers: function(c) { return [0xB0 + _ch(c), 0x79, 0]; },\r\n    localControl: function(c, b) { if (typeof b == 'undefined') b = true; return [0xB0 + _ch(c), 0x7a, b ? 127 : 0]; },\r\n    allNotesOff: function(c) { return [0xB0 + _ch(c), 0x7b, 0]; },\r\n    omni: function(c, b) { if (typeof b == 'undefined') b = true; return [0xB0 + _ch(c), b ? 0x7d : 0x7c, 0]; },\r\n    mono: function(c, n) { if (typeof n == 'undefined') n = 1; return [0xB0 + _ch(c), 0x7e, _7b(n)]; },\r\n    poly: function(c) { return [0xB0 + _ch(c), 0x7f, 0]; },\r\n  };\r\n  function _splitMasterTuning(a, b, c, d) {\r\n    if (typeof b != 'undefined') return [_7b(a), _7b(b), _7b(c), _7b(d)];\r\n    if (a != parseInt(a) || a < 0 || n > 0xffff) _bad(a);\r\n    a = parseInt(a);\r\n    return [(a >> 12) & 0xf, (a >> 8) & 0xf, (a >> 4) & 0xf, a & 0xf];\r\n  }\r\n  function _gsxg12b(x) { // -1 <= x <= 1\r\n    _float(x);\r\n    return Math.round(x * 1000 + 0x400);\r\n  }\r\n  var _helperNC = { // no channel\r\n    mtc: function(t) { return [0xF1, _mtc(t)]; },\r\n    songPosition: function(n, l) { return typeof l == 'undefined' ? [0xF2, _lsb(n), _msb(n)] : [0xF2, _7b(l), _7b(n)]; },\r\n    songSelect: function(n) { return [0xF3, _7b(n)]; },\r\n    tune: function() { return [0xF6]; },\r\n    clock: function() { return [0xF8]; },\r\n    start: function() { return [0xFA]; },\r\n    continue: function() { return [0xFB]; },\r\n    stop: function() { return [0xFC]; },\r\n    active: function() { return [0xFE]; },\r\n    sxIdRequest: function() { return [0xF0, 0x7E, this._sxid, 0x06, 0x01, 0xF7]; },\r\n    sxTuningDumpRequest: function(n, k) { return typeof k == 'undefined' ?\r\n      [0xF0, 0x7E, this._sxid, 0x08, 0x00, _7b(n), 0xF7] : [0xF0, 0x7E, this._sxid, 0x08, 0x03, _7b(n), _7b(k), 0xF7]; },\r\n    sxFullFrame: function(t) { return [0xF0, 0x7F, this._sxid, 0x01, 0x01, _hrtype(t), t.getMinute(), t.getSecond(), t.getFrame(), 0xF7]; },\r\n    sxMasterVolume: function(n, l) { return typeof l == 'undefined' ?\r\n      [0xF0, 0x7F, this._sxid, 0x04, 0x01, _lsb(n), _msb(n), 0xF7] : [0xF0, 0x7F, this._sxid, 0x04, 0x01, _7b(l), _7b(n), 0xF7]; },\r\n    sxMasterVolumeF: function(x) { return _helperNC.sxMasterVolume.call(this, MIDI.to14b(_01(x))); },\r\n    sxMasterFineTuning: function(n, l) { return typeof l == 'undefined' ?\r\n      [0xF0, 0x7F, this._sxid, 0x04, 0x03, _lsb(n), _msb(n), 0xF7] : [0xF0, 0x7F, this._sxid, 0x04, 0x03, _7b(l), _7b(n), 0xF7]; },\r\n    sxMasterFineTuningF: function(x) { return _helperNC.sxMasterFineTuning.call(this, MIDI.to14b(_01((x % 1 + 1) / 2, x))); },\r\n    sxMasterCoarseTuning: function(n) { return [0xF0, 0x7F, this._sxid, 0x04, 0x04, 0x00, _7b(n), 0xF7]; },\r\n    sxMasterCoarseTuningF: function(x) { return _helperNC.sxMasterCoarseTuning.call(this, 0x40 + (x - x % 1)); },\r\n    sxNoteTuning: function(a, b, c, d) { return b == parseInt(b) ?\r\n      [0xF0, _rt(d), this._sxid, 0x08, 0x07, _7b(a), _7b(b)].concat(_ntu(c), [0xF7]) :\r\n      [0xF0, 0x7F, this._sxid, 0x08, 0x02, _7b(a)].concat(_ntu(b), [0xF7]); },\r\n    sxNoteTuningF: function(a, b, c, d) { return b == parseInt(b) ?\r\n      _helperNC.sxNoteTuning.call(this, a, b, _f2ntu(c), d) : _helperNC.sxNoteTuning.call(this, a, _f2ntu(b)); },\r\n    sxNoteTuningHZ: function(a, b, c, d) { return b == parseInt(b) ?\r\n      _helperNC.sxNoteTuning.call(this, a, b, _hz2ntu(c), d) : _helperNC.sxNoteTuning.call(this, a, _hz2ntu(b)); },\r\n    sxScaleTuning1: function(a, b, c) { return a == parseInt(a) ?\r\n      [0xF0, _rt(c), this._sxid, 0x08, 0x08].concat(_to777(_16b(a)), _12x7(b), [0xF7]) :\r\n      _helperNC.sxScaleTuning1.call(this, 0xffff, a, b); },\r\n    sxScaleTuning1F: function(a, b, c) { if (a != parseInt(a)) return _helperNC.sxScaleTuning1F.call(this, 0xffff, a, b);\r\n      var v = []; for (var i = 0; i < b.length; i++) {\r\n        if (b[i] < -0.64 || b[i] > 0.63) throw RangeError('Out of range: ' + b[i]);\r\n        v.push(Math.floor(b[i] * 100 + 64)); }\r\n      return _helperNC.sxScaleTuning1.call(this, a, v, c); },\r\n    sxScaleTuning2: function(a, b, c) { return a == parseInt(a) ?\r\n      [0xF0, _rt(c), this._sxid, 0x08, 0x09].concat(_to777(_16b(a)), _12x14(b), [0xF7]) :\r\n      _helperNC.sxScaleTuning2.call(this, 0xffff, a, b); },\r\n    sxScaleTuning2F: function(a, b, c) { if (a != parseInt(a)) return _helperNC.sxScaleTuning2F.call(this, 0xffff, a, b);\r\n      var v = []; for (var i = 0; i < b.length; i++) {\r\n        var x = (b[i] + 1) / 2;\r\n        if (x < -1 || x > 1) throw RangeError('Out of range: ' + b[i]);\r\n        v.push(MIDI.to14b((b[i] + 1) / 2)); }\r\n      return _helperNC.sxScaleTuning2.call(this, a, v, c); },\r\n    sxGM: function(gm) { if (typeof gm == 'undefined') gm = 1; return [0xF0, 0x7E, this._sxid, 0x09, gm ? gm == 2 ? 3 : 1 : 2, 0xf7]; },\r\n    sxGS: function(arg) { var arr = typeof arg == 'undefined' ? [0x40, 0, 0x7F, 0] : arg instanceof Array ? arg : arguments;\r\n      var c = 0; var a = [0xF0, 0x41, this._sxid, 0x42, 0x12];\r\n      for (var i = 0; i < arr.length; i++) { var x = _7b(arr[i]); a.push(x); c += x; }\r\n      c %= 128; a.push(c ? 128 - c : 0); a.push(0xf7); return a; },\r\n    sxXG: function(arg) { var arr = typeof arg == 'undefined' ? [0, 0, 0x7E, 0] : arg instanceof Array ? arg : arguments;\r\n      var sxid = this._sxid == 0x7f ? 0 : this._sxid;\r\n      if (sxid > 15) _throw('Bad Yamaha device number: ' + sxid);\r\n      var a = [0xf0, 0x43, 16 + sxid, 0x4c];\r\n      for (var i = 0; i < arr.length; i++) a.push(_7b(arr[i])); a.push(0xf7); return a; },\r\n    sxMidiSoft: function(n, s) {\r\n      var a = [0xf0, 0x00, 0x20, 0x24, 0x00, _7b(n || 0)];\r\n      s = typeof s == 'undefined' ? '' : '' + s;\r\n      for (var i = 0; i < s.length; i++) a.push(_7b(s.charCodeAt(i)));\r\n      a.push(0xf7); return a; },\r\n    gsMasterVolume: function(n) { return _helperNC.sxGS.call(this, [0x40, 0, 4, _7b(n)]); },\r\n    gsMasterVolumeF: function(x) { return _helperNC.gsMasterVolume.call(this, MIDI.to7b(_01(x))); },\r\n    gsMasterFineTuning: function(a, b, c, d) { a = _splitMasterTuning(a, b, c, d); return _helperNC.sxGS.call(this, [0x40, 0, 0, a[0], a[1], a[2], a[3]]); },\r\n    gsMasterFineTuningF: function(x) { return _helperNC.gsMasterFineTuning.call(this, _gsxg12b(x % 1)); },\r\n    gsMasterCoarseTuning: function(n) { return _helperNC.sxGS.call(this, [0x40, 0, 5, _7b(n)]); },\r\n    gsMasterCoarseTuningF: function(x) { return _helperNC.gsMasterCoarseTuning.call(this, 0x40 + (x - x % 1)); },\r\n    gsOctaveTuning: function(c, n, x) { return _helperNC.sxGS.call(this, [0x40, 0x10 + [1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 11, 12, 13, 14, 15][_ch(c)], 0x40 + MIDI.octaveValue(n), _7b(x)]); },\r\n    gsOctaveTuningF: function(c, n, x) { if (x < -0.64 || x > 0.63) throw RangeError('Out of range: ' + x);\r\n      return _helperNC.gsOctaveTuning.call(this, c, n, Math.floor(x * 100 + 64)); },\r\n    xgMasterVolume: function(n) { return _helperNC.sxXG.call(this, [0, 0, 4, _7b(n)]); },\r\n    xgMasterVolumeF: function(x) { return _helperNC.xgMasterVolume.call(this, MIDI.to7b(_01(x))); },\r\n    xgMasterFineTuning: function(a, b, c, d) { a = _splitMasterTuning(a, b, c, d); return _helperNC.sxXG.call(this, [0, 0, 0, a[0], a[1], a[2], a[3]]); },\r\n    xgMasterFineTuningF: function(x) { return _helperNC.xgMasterFineTuning.call(this, _gsxg12b(x % 1)); },\r\n    xgMasterCoarseTuning: function(n) { return _helperNC.sxXG.call(this, [0, 0, 6, _7b(n)]); },\r\n    xgMasterCoarseTuningF: function(x) { return _helperNC.xgMasterCoarseTuning.call(this, 0x40 + (x - x % 1)); },\r\n    xgOctaveTuning: function(c, n, x) { return _helperNC.sxXG.call(this, [8, _ch(c), 0x41 + MIDI.octaveValue(n), _7b(x)]); },\r\n    xgOctaveTuningF: function(c, n, x) { if (x < -0.64 || x > 0.63) throw RangeError('Out of range: ' + x);\r\n      return _helperNC.xgOctaveTuning.call(this, c, n, Math.floor(x * 100 + 64)); },\r\n    reset: function() { return [0xFF]; },\r\n  };\r\n  _helperNC.sxScaleTuning = _helperNC.sxScaleTuning2;\r\n  _helperNC.sxScaleTuningF = _helperNC.sxScaleTuning2F;\r\n  _helperNC.sxMasterTranspose = _helperNC.sxMasterCoarseTuning;\r\n  _helperNC.sxMasterTransposeF = _helperNC.sxMasterCoarseTuningF;\r\n  _helperNC.gsMasterTranspose = _helperNC.gsMasterCoarseTuning;\r\n  _helperNC.gsMasterTransposeF = _helperNC.gsMasterCoarseTuningF;\r\n  _helperNC.xgMasterTranspose = _helperNC.xgMasterCoarseTuning;\r\n  _helperNC.xgMasterTransposeF = _helperNC.xgMasterCoarseTuningF;\r\n  var _helperGCH = { // compound messages\r\n    bank: function(c, m, l) { return typeof l == 'undefined' ?\r\n      [_helperCH.bankMSB(c, _msb(m)), _helperCH.bankLSB(c, _lsb(m))] : [_helperCH.bankMSB(c, m), _helperCH.bankLSB(c, l)]; },\r\n    modF: function(c, x) { return _helperGCH.mod(c, MIDI.to14b(x)); },\r\n    mod: function(c, m, l) { return typeof l == 'undefined' ?\r\n      [_helperCH.modMSB(c, _msb(m)), _helperCH.modLSB(c, _lsb(m))] : [_helperCH.modMSB(c, m), _helperCH.modLSB(c, l)]; },\r\n    breathF: function(c, x) { return _helperGCH.breath(c, MIDI.to14b(x)); },\r\n    breath: function(c, m, l) { return typeof l == 'undefined' ?\r\n      [_helperCH.breathMSB(c, _msb(m)), _helperCH.breathLSB(c, _lsb(m))] : [_helperCH.breathMSB(c, m), _helperCH.breathLSB(c, l)]; },\r\n    footF: function(c, x) { return _helperGCH.foot(c, MIDI.to14b(x)); },\r\n    foot: function(c, m, l) { return typeof l == 'undefined' ?\r\n      [_helperCH.footMSB(c, _msb(m)), _helperCH.footLSB(c, _lsb(m))] : [_helperCH.footMSB(c, m), _helperCH.footLSB(c, l)]; },\r\n    portamentoTimeF: function(c, x) { return _helperGCH.portamentoTime(c, MIDI.to14b(x)); },\r\n    portamentoTime: function(c, m, l) { return typeof l == 'undefined' ?\r\n      [_helperCH.portamentoMSB(c, _msb(m)), _helperCH.portamentoLSB(c, _lsb(m))] : [_helperCH.portamentoMSB(c, m), _helperCH.portamentoLSB(c, l)]; },\r\n    dataF: function(c, x) { return _helperGCH.data(c, MIDI.to14b(x)); },\r\n    data: function(c, m, l) { return typeof l == 'undefined' ?\r\n      [_helperCH.dataMSB(c, _msb(m)), _helperCH.dataLSB(c, _lsb(m))] : [_helperCH.dataMSB(c, m), _helperCH.dataLSB(c, l)]; },\r\n    volumeF: function(c, x) { return _helperGCH.volume(c, MIDI.to14b(x)); },\r\n    volume: function(c, m, l) { return typeof l == 'undefined' ?\r\n      [_helperCH.volumeMSB(c, _msb(m)), _helperCH.volumeLSB(c, _lsb(m))] : [_helperCH.volumeMSB(c, m), _helperCH.volumeLSB(c, l)]; },\r\n    balanceF: function(c, x) { return _helperGCH.balance(c, MIDI.to14b((x + 1) / 2)); },\r\n    balance: function(c, m, l) { return typeof l == 'undefined' ?\r\n      [_helperCH.balanceMSB(c, _msb(m)), _helperCH.balanceLSB(c, _lsb(m))] : [_helperCH.balanceMSB(c, m), _helperCH.balanceLSB(c, l)]; },\r\n    panF: function(c, x) { return _helperGCH.pan(c, MIDI.to14b((x + 1) / 2)); },\r\n    pan: function(c, m, l) { return typeof l == 'undefined' ?\r\n      [_helperCH.panMSB(c, _msb(m)), _helperCH.panLSB(c, _lsb(m))] : [_helperCH.panMSB(c, m), _helperCH.panLSB(c, l)]; },\r\n    expressionF: function(c, x) { return _helperGCH.expression(c, MIDI.to14b(x)); },\r\n    expression: function(c, m, l) { return typeof l == 'undefined' ?\r\n      [_helperCH.expressionMSB(c, _msb(m)), _helperCH.expressionLSB(c, _lsb(m))] : [_helperCH.expressionMSB(c, m), _helperCH.expressionLSB(c, l)]; },\r\n    nrpn: function(c, m, l) { return typeof l == 'undefined' ?\r\n      [_helperCH.nrpnMSB(c, _msb(m)), _helperCH.nrpnLSB(c, _lsb(m))] : [_helperCH.nrpnMSB(c, m), _helperCH.nrpnLSB(c, l)]; },\r\n    rpn: function(c, m, l) { return typeof l == 'undefined' ?\r\n      [_helperCH.rpnMSB(c, _msb(m)), _helperCH.rpnLSB(c, _lsb(m))] : [_helperCH.rpnMSB(c, m), _helperCH.rpnLSB(c, l)]; },\r\n    rpnPitchBendRange: function(c, m, l) { return _helperGCH.rpn(c, 0, 0).concat(_helperGCH.data(c, m, l)); },\r\n    rpnPitchBendRangeF: function(c, x) { return _helperGCH.rpnPitchBendRange(c, _7b(x - x % 1), Math.floor((x % 1) * 100)); },\r\n    rpnFineTuning: function(c, m, l) { return _helperGCH.rpn(c, 0, 1).concat(_helperGCH.data(c, m, l)); },\r\n    rpnFineTuningF: function(c, x) { return _helperGCH.rpn(c, 0, 1).concat(_helperGCH.dataF(c, (x % 1 + 1) / 2)); },\r\n    rpnCoarseTuning: function(c, m) { return _helperGCH.rpn(c, 0, 2).concat([_helperCH.dataMSB(c, m)]); },\r\n    rpnCoarseTuningF: function(c, x) { return _helperGCH.rpn(c, 0, 2).concat([_helperCH.dataMSB(c, 0x40 + (x - x % 1))]); },\r\n    rpnTuning: function(c, n, m, l) { return _helperGCH.rpnCoarseTuning(c, n).concat(_helperGCH.rpnFineTuning(c, m, l)); },\r\n    rpnTuningF: function(c, x) { return _helperGCH.rpnCoarseTuningF(c, x).concat(_helperGCH.rpnFineTuningF(c, x)); },\r\n    rpnTuningA: function(c, a) { return _helperGCH.rpnTuningF(c, MIDI.shift(a)); },\r\n    rpnSelectTuningProgram: function(c, n) { return _helperGCH.rpn(c, 0, 3).concat([_helperCH.dataMSB(c, n)]); },\r\n    rpnSelectTuningBank: function(c, n) { return _helperGCH.rpn(c, 0, 4).concat([_helperCH.dataMSB(c, n)]); },\r\n    rpnSelectTuning: function(c, n, k) { return typeof k == 'undefined' ?\r\n      _helperGCH.rpnSelectTuningProgram(c, n) : _helperGCH.rpnSelectTuningBank(c, n).concat(_helperGCH.rpnSelectTuningProgram(c, k)); },\r\n    rpnModulationDepthRange: function(c, m, l) { return _helperGCH.rpn(c, 0, 5).concat(_helperGCH.data(c, m, l)); },\r\n    rpnModulationDepthRangeF: function(c, x) { return _helperGCH.rpnModulationDepthRange(c, _7b(x - x % 1), Math.floor((x % 1) * 128)); },\r\n    rpnNull: function(c) { return _helperGCH.rpn(c, 0x7f, 0x7f); },\r\n    mode1: function(c) { return [ _helperCH.omni(c, true), _helperCH.poly(c) ]; },\r\n    mode2: function(c) { return [ _helperCH.omni(c, true), _helperCH.mono(c) ]; },\r\n    mode3: function(c) { return [ _helperCH.omni(c, false), _helperCH.poly(c) ]; },\r\n    mode4: function(c) { return [ _helperCH.omni(c, false), _helperCH.mono(c) ]; },\r\n  };\r\n  var _helperGNC = { // compound messages no channel\r\n    sxMasterTuning: function(n, m, l) { return [_helperNC.sxMasterCoarseTuning.call(this, n), _helperNC.sxMasterFineTuning.call(this, m, l)]; },\r\n    sxMasterTuningF: function(x) { return [_helperNC.sxMasterCoarseTuningF.call(this, x), _helperNC.sxMasterFineTuningF.call(this, x)]; },\r\n    gsMasterTuningF: function(x) { return [_helperNC.gsMasterCoarseTuningF.call(this, x), _helperNC.gsMasterFineTuningF.call(this, x)]; },\r\n    xgMasterTuningF: function(x) { return [_helperNC.xgMasterCoarseTuningF.call(this, x), _helperNC.xgMasterFineTuningF.call(this, x)]; },\r\n    sxMasterTuningA: function(a) { return _helperGNC.sxMasterTuningF.call(this, MIDI.shift(a)); },\r\n    gsMasterTuningA: function(a) { return _helperGNC.gsMasterTuningF.call(this, MIDI.shift(a)); },\r\n    xgMasterTuningA: function(a) { return _helperGNC.xgMasterTuningF.call(this, MIDI.shift(a)); },\r\n    gsScaleTuning: function(c, a) { var out = []; if (a.length != 12) throw RangeError('Wrong input size: ' + a.length);\r\n      for (var i = 0; i < 12; i++) out.push(_helperNC.gsOctaveTuning.call(this, c, i, a[i])); return out; },\r\n    gsScaleTuningF: function(c, a) { var out = []; if (a.length != 12) throw RangeError('Wrong input size: ' + a.length);\r\n      for (var i = 0; i < 12; i++) out.push(_helperNC.gsOctaveTuningF.call(this, c, i, a[i])); return out; },\r\n    xgScaleTuning: function(c, a) { var out = []; if (a.length != 12) throw RangeError('Wrong input size: ' + a.length);\r\n      for (var i = 0; i < 12; i++) out.push(_helperNC.xgOctaveTuning.call(this, c, i, a[i])); return out; },\r\n    xgScaleTuningF: function(c, a) { var out = []; if (a.length != 12) throw RangeError('Wrong input size: ' + a.length);\r\n      for (var i = 0; i < 12; i++) out.push(_helperNC.xgOctaveTuningF.call(this, c, i, a[i])); return out; },\r\n  };\r\n  function _smf(ff, dd) {\r\n    var midi = new MIDI();\r\n    midi.ff = _8b(ff);\r\n    midi.dd = typeof dd == 'undefined' ? '' : _8bs(dd);\r\n    return midi;\r\n  }\r\n  var _helperSMF = { // Standard MIDI File events\r\n    smf: function(arg) {\r\n      if (arg instanceof MIDI) return new MIDI(arg);\r\n      var arr = arg instanceof Array ? arg : arguments;\r\n      var ff = _8b(arr[0]);\r\n      var dd = '';\r\n      if (arr.length == 2) dd = _2s(arr[1]);\r\n      else if (arr.length > 2) dd = _2s(Array.prototype.slice.call(arr, 1));\r\n      return _smf(ff, dd);\r\n    },\r\n    smfSeqNumber: function(dd) {\r\n      if (dd == parseInt(dd)) {\r\n        if (dd < 0 || dd > 0xffff) throw RangeError('Sequence number out of range: ' + dd);\r\n        dd = String.fromCharCode(dd >> 8) + String.fromCharCode(dd & 0xff);\r\n      }\r\n      else {\r\n        dd = '' + dd;\r\n        if (dd.length == 0) dd = '\\x00\\x00';\r\n        else if (dd.length == 1) dd = '\\x00' + dd;\r\n        else if (dd.length > 2) throw RangeError('Sequence number out of range' + _smftxt(dd));\r\n      }\r\n      return _smf(0, dd);\r\n    },\r\n    smfText: function(dd) { return _smf(1, JZZ.lib.toUTF8(dd)); },\r\n    smfCopyright: function(dd) { return _smf(2, JZZ.lib.toUTF8(dd)); },\r\n    smfSeqName: function(dd) { return _smf(3, JZZ.lib.toUTF8(dd)); },\r\n    smfInstrName: function(dd) { return _smf(4, JZZ.lib.toUTF8(dd)); },\r\n    smfLyric: function(dd) { return _smf(5, JZZ.lib.toUTF8(dd)); },\r\n    smfMarker: function(dd) { return _smf(6, JZZ.lib.toUTF8(dd)); },\r\n    smfCuePoint: function(dd) { return _smf(7, JZZ.lib.toUTF8(dd)); },\r\n    smfProgName: function(dd) { return _smf(8, JZZ.lib.toUTF8(dd)); },\r\n    smfDevName: function(dd) { return _smf(9, JZZ.lib.toUTF8(dd)); },\r\n    smfChannelPrefix: function(dd) {\r\n      if (dd == parseInt(dd)) {\r\n        _validateChannel(dd);\r\n        dd = String.fromCharCode(dd);\r\n      }\r\n      else {\r\n        dd = '' + dd;\r\n        if (dd.length == 0) dd = '\\x00';\r\n        else if (dd.length > 1 || dd.charCodeAt(0) > 15) throw RangeError('Channel number out of range' + _smftxt(dd));\r\n      }\r\n      return _smf(32, dd);\r\n    },\r\n    smfMidiPort: function(dd) {\r\n      if (dd == parseInt(dd)) {\r\n        if (dd < 0 || dd > 127) throw RangeError('Port number out of range: ' + dd);\r\n        dd = String.fromCharCode(dd);\r\n      }\r\n      else {\r\n        dd = '' + dd;\r\n        if (dd.length == 0) dd = '\\x00';\r\n        else if (dd.length > 1 || dd.charCodeAt(0) > 127) throw RangeError('Port number out of range' + _smftxt(dd));\r\n      }\r\n      return _smf(33, dd);\r\n    },\r\n    smfEndOfTrack: function(dd) {\r\n      if (_2s(dd) != '') throw RangeError('Unexpected data' + _smftxt(_2s(dd)));\r\n      return _smf(47);\r\n    },\r\n    smfTempo: function(dd) { // microseconds per quarter note\r\n      if (('' + dd).length == 3) return _smf(81, dd);\r\n      if (dd == parseInt(dd) && dd > 0 && dd <= 0xffffff) {\r\n        return _smf(81, String.fromCharCode(dd >> 16) + String.fromCharCode((dd >> 8) & 0xff) + String.fromCharCode(dd & 0xff));\r\n      }\r\n      throw RangeError('Out of range' + _smftxt(_2s(dd)));\r\n    },\r\n    smfBPM: function(bpm) { return _helperSMF.smfTempo(Math.round(60000000.0 / bpm)); },\r\n    smfSMPTE: function(dd) {\r\n      if (dd instanceof SMPTE) return _smf(84, String.fromCharCode(dd.hour) + String.fromCharCode(dd.minute) + String.fromCharCode(dd.second) + String.fromCharCode(dd.frame) + String.fromCharCode((dd.quarter % 4) * 25));\r\n      var s = '' + dd;\r\n      if (s.length == 5) {\r\n        return _smf(84, dd);\r\n      }\r\n      var arr = dd instanceof Array ? dd : Array.prototype.slice.call(arguments);\r\n      arr.splice(0, 0, 30);\r\n      return _helperSMF.smfSMPTE(new SMPTE(arr));\r\n    },\r\n    smfTimeSignature: function(a, b, c, d) {\r\n      var nn, dd, cc, bb;\r\n      var m = ('' + a ).match(/^\\s*(\\d+)\\s*\\/\\s*(\\d+)\\s*$/);\r\n      if (m) {\r\n        nn = parseInt(m[1]);\r\n        dd = parseInt(m[2]);\r\n        if (nn > 0 && nn < 0x100 && dd > 0 && !(dd & (dd - 1))) {\r\n          cc = dd; dd = 0;\r\n          for (cc >>= 1; cc; cc >>= 1) dd++;\r\n          cc = b == parseInt(b) ? b : 24;\r\n          bb = c == parseInt(c) ? c : 8;\r\n          return _smf(88, String.fromCharCode(nn) + String.fromCharCode(dd) + String.fromCharCode(cc) + String.fromCharCode(bb));\r\n        }\r\n        else if (('' + a ).length == 4) return _smf(88, a);\r\n      }\r\n      else if (a == parseInt(a) && b == parseInt(b)) {\r\n        if (a > 0 && a < 0x100 && b > 0 && !(b & (b - 1))) {\r\n          nn = a;\r\n          dd = 0;\r\n          cc = b;\r\n          for (cc >>= 1; cc; cc >>= 1) dd++;\r\n          cc = c == parseInt(c) ? c : 24;\r\n          bb = d == parseInt(d) ? d : 8;\r\n          return _smf(88, String.fromCharCode(nn) + String.fromCharCode(dd) + String.fromCharCode(cc) + String.fromCharCode(bb));\r\n        }\r\n        else if (('' + a ).length == 4) return _smf(88, a);\r\n        a = a + '/' + b;\r\n      }\r\n      else if (('' + a ).length == 4) return _smf(88, a);\r\n      throw RangeError('Wrong time signature' + _smftxt(_2s('' + a)));\r\n    },\r\n    smfKeySignature: function(dd) {\r\n      dd = '' + dd;\r\n      var m = dd.match(/^\\s*([A-H][b#]?)\\s*(|maj|major|dur|m|min|minor|moll)\\s*$/i);\r\n      if (m) {\r\n        var sf = {\r\n          CB: 0, GB: 1, DB: 2, AB: 3, EB: 4, BB: 5, F: 6, C: 7, G: 8, D: 9, A: 10,\r\n          E:11, B: 12, H: 12, 'F#': 13, 'C#': 14, 'G#': 15, 'D#': 16, 'A#': 17\r\n        }[m[1].toUpperCase()];\r\n        var mi = { '': 0, MAJ: 0, MAJOR: 0, DUR: 0, M: 1, MIN: 1, MINOR: 1, MOLL: 1}[m[2].toUpperCase()];\r\n        if (typeof sf != 'undefined' && typeof mi != 'undefined') {\r\n          if (mi) sf -= 3;\r\n          sf -= 7;\r\n          if (sf >= -7 && sf < 0) dd = String.fromCharCode(256 + sf) + String.fromCharCode(mi);\r\n          else if (sf >= 0 && sf <= 7) dd = String.fromCharCode(sf) + String.fromCharCode(mi);\r\n        }\r\n      }\r\n      if (dd.length == 2 && dd.charCodeAt(1) <= 1 && (dd.charCodeAt(0) <= 7 || dd.charCodeAt(0) <= 255 && dd.charCodeAt(0) >= 249)) return _smf(89, dd);\r\n      throw RangeError('Incorrect key signature' + _smftxt(dd));\r\n    },\r\n    smfSequencer: function(dd) { return _smf(127, _2s(dd)); }\r\n  };\r\n\r\n  var _helpers = {};\r\n  function _copyHelperNC(name, func) {\r\n    MIDI[name] = function() { return new MIDI(func.apply(this, arguments)); };\r\n    _helpers[name] = function() { return this.send(func.apply(this, arguments)); };\r\n  }\r\n  function _copyHelperSMF(name, func) {\r\n    MIDI[name] = function() { return func.apply(this, arguments); };\r\n    _helpers[name] = function() { return this.send(func.apply(this, arguments)); };\r\n  }\r\n  function _copyHelperGNC(name, func) {\r\n    MIDI[name] = function() {\r\n      var i;\r\n      var g = [];\r\n      var a = func.apply(this, arguments);\r\n      for (i = 0; i < a.length; i++) g.push(new MIDI(a[i]));\r\n      return g;\r\n    };\r\n    _helpers[name] = function() {\r\n      var a = func.apply(this, arguments);\r\n      var g = this;\r\n      for (var i = 0; i < a.length; i++) g = g.send(a[i]);\r\n      return g;\r\n    };\r\n  }\r\n  function _copyHelperMPE(name, func) {\r\n    MIDI[name] = function() {\r\n      return new MIDI(func.apply(this, typeof this._ch == 'undefined' ? arguments : [this._ch].concat(Array.prototype.slice.call(arguments))));\r\n    };\r\n    _helpers[name] = function() {\r\n      if (typeof this._master != 'undefined') {\r\n        var msg = new MIDI(func.apply(this, [this._master].concat(Array.prototype.slice.call(arguments))));\r\n        msg._mpe = msg[1];\r\n        return this.send(msg);\r\n      }\r\n      return this.send(func.apply(this, typeof this._ch == 'undefined' ? arguments : [this._ch].concat(Array.prototype.slice.call(arguments))));\r\n    };\r\n  }\r\n  function _copyHelperCH(name, func) {\r\n    MIDI[name] = function() {\r\n      return new MIDI(func.apply(this, typeof this._ch == 'undefined' ? arguments : [this._ch].concat(Array.prototype.slice.call(arguments))));\r\n    };\r\n    _helpers[name] = function() {\r\n      if (typeof this._master != 'undefined') {\r\n        var chan;\r\n        var args = Array.prototype.slice.call(arguments);\r\n        if (args.length < func.length) args = [this._master].concat(args);\r\n        else {\r\n          chan = _7bn(args[0]);\r\n          args[0] = this._master;\r\n        }\r\n        var msg = new MIDI(func.apply(this, args));\r\n        msg._mpe = chan;\r\n        return this.send(msg);\r\n      }\r\n      return this.send(func.apply(this, typeof this._ch == 'undefined' ? arguments : [this._ch].concat(Array.prototype.slice.call(arguments))));\r\n    };\r\n  }\r\n  function _copyHelperGCH(name, func) {\r\n    MIDI[name] = function() {\r\n      var i;\r\n      var g = [];\r\n      var a = func.apply(this, typeof this._ch == 'undefined' ? arguments : [this._ch].concat(Array.prototype.slice.call(arguments)));\r\n      for (i = 0; i < a.length; i++) g.push(new MIDI(a[i]));\r\n      return g;\r\n    };\r\n    _helpers[name] = function() {\r\n      var i;\r\n      var a;\r\n      var g;\r\n      if (typeof this._master != 'undefined') {\r\n        var chan;\r\n        var args = Array.prototype.slice.call(arguments);\r\n        if (args.length < func.length) args = [this._master].concat(args);\r\n        else {\r\n          chan = _7bn(args[0]);\r\n          args[0] = this._master;\r\n        }\r\n        a = func.apply(this, args);\r\n        g = this;\r\n        for (i = 0; i < a.length; i++) {\r\n          var msg = MIDI(a[i]);\r\n          msg._mpe = chan;\r\n          g = g.send(msg);\r\n        }\r\n        return g;\r\n      }\r\n      a = func.apply(this, typeof this._ch == 'undefined' ? arguments : [this._ch].concat(Array.prototype.slice.call(arguments)));\r\n      g = this;\r\n      for (i = 0; i < a.length; i++) g = g.send(a[i]);\r\n      return g;\r\n    };\r\n  }\r\n\r\n  _for(_helperNC, function(n) { _copyHelperNC(n, _helperNC[n]); });\r\n  _for(_helperSMF, function(n) { _copyHelperSMF(n, _helperSMF[n]); });\r\n  _for(_helperGNC, function(n) { _copyHelperGNC(n, _helperGNC[n]); });\r\n  _for(_helperMPE, function(n) { _copyHelperMPE(n, _helperMPE[n]); });\r\n  _for(_helperCH, function(n) { _copyHelperCH(n, _helperCH[n]); });\r\n  _for(_helperGCH, function(n) { _copyHelperGCH(n, _helperGCH[n]); });\r\n\r\n  function _copyMidiHelpers(M) {\r\n    _for(_helpers, function(n) { M.prototype[n] = _helpers[n]; });\r\n  }\r\n  _copyMidiHelpers(_M);\r\n\r\n  var _channelMap = { a:10, b:11, c:12, d:13, e:14, f:15, A:10, B:11, C:12, D:13, E:14, F:15 };\r\n  for (k = 0; k < 16; k++) _channelMap[k] = k;\r\n  MIDI.prototype.getChannel = function() {\r\n    if (this.ff == 0x20 && this.dd.length == 1 && this.dd.charCodeAt(0) < 16) return this.dd.charCodeAt(0);\r\n    var c = this[0];\r\n    if (typeof c == 'undefined' || c < 0x80 || c > 0xef) return;\r\n    return c & 15;\r\n  };\r\n  MIDI.prototype.setChannel = function(x) {\r\n    x = _channelMap[x];\r\n    if (typeof x == 'undefined') return this;\r\n    if (this.ff == 0x20) this.dd = String.fromCharCode(x);\r\n    else {\r\n      var c = this[0];\r\n      if (typeof c != 'undefined' && c >= 0x80 && c <= 0xef) this[0] = (c & 0xf0) | x;\r\n    }\r\n    return this;\r\n  };\r\n  MIDI.prototype.getNote = function() {\r\n    var c = this[0];\r\n    if (typeof c == 'undefined' || c < 0x80 || c > 0xaf) return;\r\n    return this[1];\r\n  };\r\n  MIDI.prototype.setNote = function(x) {\r\n    var c = this[0];\r\n    if (typeof c == 'undefined' || c < 0x80 || c > 0xaf) return this;\r\n    x = MIDI.noteValue(x);\r\n    if (typeof x != 'undefined') this[1] = x;\r\n    return this;\r\n  };\r\n  MIDI.prototype.getVelocity = function() {\r\n    var c = this[0];\r\n    if (typeof c == 'undefined' || c < 0x80 || c > 0x9f) return;\r\n    return this[2];\r\n  };\r\n  MIDI.prototype.setVelocity = function(x) {\r\n    var c = this[0];\r\n    if (typeof c == 'undefined' || c < 0x80 || c > 0x9f) return this;\r\n    x = parseInt(x);\r\n    if (x >= 0 && x < 128) this[2] = x;\r\n    return this;\r\n  };\r\n  MIDI.prototype.getSysExId = function() {\r\n    if (this[0] == 0xf0) return this[2];\r\n  };\r\n  MIDI.prototype.setSysExId = function(x) {\r\n    if (this[0] == 0xf0 && this.length > 2) {\r\n      x = parseInt(x);\r\n      if (x >= 0 && x < 128) this[2] = x;\r\n    }\r\n    return this;\r\n  };\r\n  MIDI.prototype.getData = function() {\r\n    if (typeof this.dd != 'undefined') return this.dd.toString();\r\n  };\r\n  MIDI.prototype.setData = function(dd) {\r\n    this.dd = _2s(dd);\r\n    return this;\r\n  };\r\n  function _is_yamaha_smf(ff, dd) { return ff == 0x7f && typeof dd != 'undefined' && dd.charCodeAt(0) == 0x43 && dd.charCodeAt(1) == 0x7b; }\r\n  function _is_yamaha_chord(ff, dd) { return _is_yamaha_smf(ff, dd) && dd.charCodeAt(2) == 1; }\r\n  function _yamaha_chord(a, b) {\r\n    if (a >= 0 && a <= 0x7f && b >= 0 && b <= 0x7f) {\r\n      var c = a & 0xf;\r\n      var d = a >> 4;\r\n      if (c > 0 && c < 8 && d < 7) c = ['C', 'D', 'E', 'F', 'G', 'A', 'B'][c - 1] + ['bbb', 'bb', 'b', '', '#', '##', '###'][d];\r\n      else return '-';\r\n      if (b > 34) return c + '?';\r\n      else return c + [\r\n        '', '6', 'Maj7', 'Maj7(#11)', '(9)', 'Maj7(9)', '6(9)', 'aug', 'm', 'm6', 'm7', 'm7b5',\r\n        'm(9)', 'm7(9)', 'm7(11)', 'm+7', 'm+7(9)', 'dim', 'dim7', '7', '7sus4', '7b5', '7(9)',\r\n        '7(#11)', '7(13)', '7(b9)', '7(b13)', '7(#9)', 'Maj7aug', '7aug', '1+8', '1+5', 'sus4', '1+2+5', 'cc'][b];\r\n    }\r\n    return '-';\r\n  }\r\n  MIDI.prototype.getText = function() {\r\n    if (typeof this.dd != 'undefined') {\r\n      if (_is_yamaha_chord(this.ff, this.dd)) return _yamaha_chord(this.dd.charCodeAt(3), this.dd.charCodeAt(4));\r\n      else return JZZ.lib.fromUTF8(this.dd);\r\n    }\r\n    if (this.isMidiSoft()) {\r\n      var s = [];\r\n      for (var i = 6; i < this.length - 1; i++) s.push(String.fromCharCode(this[i]));\r\n      return s.join('');\r\n    }\r\n  };\r\n  MIDI.prototype.setText = function(dd) {\r\n    this.dd = JZZ.lib.toUTF8(dd);\r\n    return this;\r\n  };\r\n  MIDI.prototype.getTempo = function() {\r\n    if (this.ff == 0x51 && typeof this.dd != 'undefined') {\r\n      return this.dd.charCodeAt(0) * 65536 + this.dd.charCodeAt(1) * 256 + this.dd.charCodeAt(2);\r\n    }\r\n  };\r\n  MIDI.prototype.getBPM = function() {\r\n    var ms = this.getTempo();\r\n    if (ms) return 60000000 / ms;\r\n  };\r\n  MIDI.prototype.getTimeSignature = function() {\r\n    if (this.ff == 0x58 && typeof this.dd != 'undefined') {\r\n       return [this.dd.charCodeAt(0), 1 << this.dd.charCodeAt(1)];\r\n    }\r\n  };\r\n  MIDI.prototype.getKeySignature = function() {\r\n    if (this.ff == 0x59 && typeof this.dd != 'undefined') {\r\n      var sf = this.dd.charCodeAt(0);\r\n      var mi = this.dd.charCodeAt(1);\r\n      if (sf & 0x80) sf = sf - 0x100;\r\n      if (sf >= -7 && sf <= 7 && mi >= 0 && mi <= 1) {\r\n        return [sf,\r\n          ['Cb', 'Gb', 'Db', 'Ab', 'Eb', 'Bb', 'F', 'C', 'G', 'D', 'A', 'E', 'B', 'F#', 'C#', 'G#', 'D#', 'A#'][mi ? sf + 10 : sf + 7],\r\n          !!mi\r\n        ];\r\n      }\r\n    }\r\n  };\r\n\r\n  MIDI.prototype.isNoteOn = function() {\r\n    var c = this[0];\r\n    if (typeof c == 'undefined' || c < 0x90 || c > 0x9f) return false;\r\n    return this[2] > 0 ? true : false;\r\n  };\r\n  MIDI.prototype.isNoteOff = function() {\r\n    var c = this[0];\r\n    if (typeof c == 'undefined' || c < 0x80 || c > 0x9f) return false;\r\n    if (c < 0x90) return true;\r\n    return this[2] == 0 ? true : false;\r\n  };\r\n  MIDI.prototype.isSysEx = function() {\r\n    return this[0] == 0xf0;\r\n  };\r\n  MIDI.prototype.isFullSysEx = function() {\r\n    return this[0] == 0xf0 && this[this.length - 1] == 0xf7;\r\n  };\r\n  MIDI.prototype.isMidiSoft = function() {\r\n    return this.isFullSysEx() && this[1] == 0 && this[2] == 0x20 && this[3] == 0x24 && this[4] == 0;\r\n  };\r\n  MIDI.prototype.isSMF = function() {\r\n    return this.ff >= 0 && this.ff <= 0x7f;\r\n  };\r\n  MIDI.prototype.isEOT = function() {\r\n    return this.ff == 0x2f;\r\n  };\r\n  MIDI.prototype.isTempo = function() {\r\n    return this.ff == 0x51;\r\n  };\r\n  MIDI.prototype.isTimeSignature = function() {\r\n    return this.ff == 0x58;\r\n  };\r\n  MIDI.prototype.isKeySignature = function() {\r\n    return this.ff == 0x59;\r\n  };\r\n  MIDI.prototype.isGmReset = function() {\r\n    return this.match([0xf0, 0x7e, [0, 0], 0x09, [0, 0], 0xf7]);\r\n  };\r\n  MIDI.prototype.isGsReset = function() {\r\n    return this.match([0xf0, 0x41, [0, 0], 0x42, 0x12, 0x40, 0, 0x7f, 0, 0x41, 0xf7]);\r\n  };\r\n  MIDI.prototype.isXgReset = function() {\r\n    return this.match([0xf0, 0x43, [0x10, 0xf0], 0x4c, 0, 0, 0x7e, 0, 0xf7]);\r\n  };\r\n  MIDI.prototype.match = function(a) {\r\n    var i, m;\r\n    for (i = 0; i < a.length; i++) {\r\n      m = a[i][1];\r\n      if (typeof m == 'undefined') {\r\n        if (this[i] != a[i]) return false;\r\n      }\r\n      else {\r\n        if ((this[i] & m) != (a[i][0] & m)) return false;\r\n      }\r\n    }\r\n    return true;\r\n  };\r\n\r\n  function _s2a(x) {\r\n    var a = [];\r\n    for (var i = 0; i < x.length; i++) {\r\n      a[i] = x.charCodeAt(i);\r\n    }\r\n    return a;\r\n  }\r\n  function _a2s(x) {\r\n    var a = '';\r\n    for (var i = 0; i < x.length; i++) {\r\n      a += String.fromCharCode(x[i]);\r\n    }\r\n    return a;\r\n  }\r\n  function _2s(x) {\r\n    return x instanceof Array ? _a2s(x) : typeof x == 'undefined' ? '' : '' + x;\r\n  }\r\n  function _s2n(x) {\r\n    var n = 0;\r\n    for (var i = 0; i < x.length; i++) n = (n << 8) + x.charCodeAt(i);\r\n    return n;\r\n  }\r\n\r\n  function __hex(x) { return (x < 16 ? '0' : '') + x.toString(16); }\r\n  function _hex(x) {\r\n    var a = [];\r\n    for (var i = 0; i < x.length; i++) {\r\n      a[i] = __hex(x[i]);\r\n    }\r\n    return a.join(' ');\r\n  }\r\n  function _toLine(s) {\r\n    var out = '';\r\n    for (var i = 0; i < s.length; i++) {\r\n      if (s[i] == '\\n') out += '\\\\n';\r\n      else if (s[i] == '\\r') out += '\\\\r';\r\n      else if (s[i] == '\\t') out += '\\\\t';\r\n      else if (s.charCodeAt(i) < 32) out += '\\\\x' + __hex(s.charCodeAt(i));\r\n      else out += s[i];\r\n    }\r\n    return out;\r\n  }\r\n  function _smfhex(dd) {\r\n    return dd.length ? ': ' + _hex(_s2a(dd)) : '';\r\n  }\r\n  function _smftxt(dd) {\r\n    return dd.length ? ': ' + _toLine(JZZ.lib.fromUTF8(dd)) : '';\r\n  }\r\n  MIDI.prototype.label = function(s) {\r\n    this.lbl = this.lbl ? this.lbl + ', ' + s : s;\r\n    return this;\r\n  };\r\n  MIDI.prototype.toString = function() {\r\n    return this.lbl ? this._str() + ' (' + this.lbl + ')' : this._str();\r\n  };\r\n  MIDI.prototype._str = function() {\r\n    var s;\r\n    var ss;\r\n    if (!this.length) {\r\n      if (typeof this.ff != 'undefined') {\r\n        s = 'ff' + __hex(this.ff) + ' -- ';\r\n        if (this.ff == 0) s += 'Sequence Number: ' + _s2n(this.dd);\r\n        else if (this.ff > 0 && this.ff < 10) s += ['', 'Text', 'Copyright', 'Sequence Name', 'Instrument Name', 'Lyric', 'Marker', 'Cue Point', 'Program Name', 'Device Name'][this.ff] + _smftxt(this.dd);\r\n        else if (this.ff == 32) s += 'Channel Prefix' + _smfhex(this.dd);\r\n        else if (this.ff == 33) s += 'MIDI Port' + _smfhex(this.dd);\r\n        else if (this.ff == 47) s += 'End of Track' + _smfhex(this.dd);\r\n        else if (this.ff == 81) {\r\n          var bpm = Math.round(this.getBPM() * 100) / 100;\r\n          s += 'Tempo: ' + bpm + ' bpm';\r\n        }\r\n        else if (this.ff == 84) s += 'SMPTE Offset: ' + _smptetxt(_s2a(this.dd));\r\n        else if (this.ff == 88) {\r\n          var d = 1 << this.dd.charCodeAt(1);\r\n          s += 'Time Signature: ' + this.dd.charCodeAt(0) + '/' + d;\r\n          s += ' ' + this.dd.charCodeAt(2) + ' ' + this.dd.charCodeAt(3);\r\n        }\r\n        else if (this.ff == 89) {\r\n          s += 'Key Signature: ';\r\n          var ks = this.getKeySignature();\r\n          if (ks) {\r\n            s += ks[1];\r\n            if (ks[2]) s += ' min';\r\n          }\r\n          else s+= 'invalid';\r\n        }\r\n        else if (this.ff == 127) {\r\n          if (this.dd.charCodeAt(0) == 0x43) {\r\n            if (this.dd.charCodeAt(1) == 0x7b) {\r\n              s += '[XF:' + __hex(this.dd.charCodeAt(2)) + ']';\r\n              ss = { 0: 'Version', 1: 'Chord', 2: 'Rehearsal Mark', 3: 'Phrase Mark', 4: 'Max Phrase Mark',\r\n                5: 'Fingering Number', 12: 'Guide Track Flag', 16: 'Guitar Info', 18: 'Chord Voicing',\r\n                127: 'XG Song Data Number' }[this.dd.charCodeAt(2)];\r\n              s += ss ? ' ' + ss : '';\r\n              s += ': ';\r\n              if (this.dd.charCodeAt(2) == 0) {\r\n                return s + this.dd.substr(3, 4) + ' ' + _hex(_s2a(this.dd.substr(7)));\r\n              }\r\n              if (this.dd.charCodeAt(2) == 1) {\r\n                return s + this.getText();\r\n              }\r\n              return s + _hex(_s2a(this.dd.substr(3)));\r\n            }\r\n          }\r\n          s += 'Sequencer Specific' + _smfhex(this.dd);\r\n        }\r\n        else s += 'SMF' + _smfhex(this.dd);\r\n        return s;\r\n      }\r\n      return 'empty';\r\n    }\r\n    s = _hex(this);\r\n    if (this[0] < 0x80) return s;\r\n    ss = {\r\n      241: 'MIDI Time Code',\r\n      242: 'Song Position',\r\n      243: 'Song Select',\r\n      244: 'Undefined',\r\n      245: 'Undefined',\r\n      246: 'Tune request',\r\n      248: 'Timing clock',\r\n      249: 'Undefined',\r\n      250: 'Start',\r\n      251: 'Continue',\r\n      252: 'Stop',\r\n      253: 'Undefined',\r\n      254: 'Active Sensing',\r\n      255: 'Reset'\r\n    }[this[0]];\r\n    if (ss) return s + ' -- ' + ss;\r\n    if (this.isMidiSoft()) {\r\n      ss = _toLine(this.getText());\r\n      if (ss) ss = ' ' + ss;\r\n      return s + ' -- [K:' + __hex(this[5]) + ']' + ss;\r\n    }\r\n    var c = this[0] >> 4;\r\n    ss = {8: 'Note Off', 10: 'Aftertouch', 12: 'Program Change', 13: 'Channel Aftertouch', 14: 'Pitch Wheel'}[c];\r\n    if (ss) return s + ' -- ' + ss;\r\n    if (c == 9) return s + ' -- ' + (this[2] ? 'Note On' : 'Note Off');\r\n    if (c != 11) return s;\r\n    ss = {\r\n      0: 'Bank Select MSB',\r\n      1: 'Modulation Wheel MSB',\r\n      2: 'Breath Controller MSB',\r\n      4: 'Foot Controller MSB',\r\n      5: 'Portamento Time MSB',\r\n      6: 'Data Entry MSB',\r\n      7: 'Channel Volume MSB',\r\n      8: 'Balance MSB',\r\n      10: 'Pan MSB',\r\n      11: 'Expression Controller MSB',\r\n      12: 'Effect Control 1 MSB',\r\n      13: 'Effect Control 2 MSB',\r\n      16: 'General Purpose Controller 1 MSB',\r\n      17: 'General Purpose Controller 2 MSB',\r\n      18: 'General Purpose Controller 3 MSB',\r\n      19: 'General Purpose Controller 4 MSB',\r\n      31: 'Karaoke',\r\n      32: 'Bank Select LSB',\r\n      33: 'Modulation Wheel LSB',\r\n      34: 'Breath Controller LSB',\r\n      36: 'Foot Controller LSB',\r\n      37: 'Portamento Time LSB',\r\n      38: 'Data Entry LSB',\r\n      39: 'Channel Volume LSB',\r\n      40: 'Balance LSB',\r\n      42: 'Pan LSB',\r\n      43: 'Expression Controller LSB',\r\n      44: 'Effect control 1 LSB',\r\n      45: 'Effect control 2 LSB',\r\n      48: 'General Purpose Controller 1 LSB',\r\n      49: 'General Purpose Controller 2 LSB',\r\n      50: 'General Purpose Controller 3 LSB',\r\n      51: 'General Purpose Controller 4 LSB',\r\n      64: 'Damper Pedal',\r\n      65: 'Portamento',\r\n      66: 'Sostenuto',\r\n      67: 'Soft Pedal',\r\n      68: 'Legato',\r\n      69: 'Hold 2',\r\n      70: 'Sound Variation',\r\n      71: 'Filter Resonance',\r\n      72: 'Release Time',\r\n      73: 'Attack Time',\r\n      74: 'Brightness',\r\n      75: 'Decay Time',\r\n      76: 'Vibrato Rate',\r\n      77: 'Vibrato Depth',\r\n      78: 'Vibrato Delay',\r\n      79: 'Sound Controller 10',\r\n      80: 'General Purpose Controller 5',\r\n      81: 'General Purpose Controller 6',\r\n      82: 'General Purpose Controller 7',\r\n      83: 'General Purpose Controller 8',\r\n      84: 'Portamento Control',\r\n      88: 'High Resolution Velocity Prefix',\r\n      91: 'Effects 1 Depth',\r\n      92: 'Effects 2 Depth',\r\n      93: 'Effects 3 Depth',\r\n      94: 'Effects 4 Depth',\r\n      95: 'Effects 5 Depth',\r\n      96: 'Data Increment',\r\n      97: 'Data Decrement',\r\n      98: 'Non-Registered Parameter Number LSB',\r\n      99: 'Non-Registered Parameter Number MSB',\r\n      100: 'Registered Parameter Number LSB',\r\n      101: 'Registered Parameter Number MSB',\r\n      120: 'All Sound Off',\r\n      121: 'Reset All Controllers',\r\n      122: 'Local Control On/Off',\r\n      123: 'All Notes Off',\r\n      124: 'Omni Mode Off',\r\n      125: 'Omni Mode On',\r\n      126: 'Mono Mode On',\r\n      127: 'Poly Mode On'\r\n    }[this[1]];\r\n    if (this[1] >= 64 && this[1] <= 69) ss += this[2] < 64 ? ' Off' : ' On';\r\n    if (!ss) ss = 'Undefined';\r\n    return s + ' -- ' + ss;\r\n  };\r\n  MIDI.prototype._stamp = function(obj) { this._from.push(obj._orig ? obj._orig : obj); return this; };\r\n  MIDI.prototype._unstamp = function(obj) {\r\n    if (typeof obj == 'undefined') this._from = [];\r\n    else {\r\n      if (obj._orig) obj = obj._orig;\r\n      var i = this._from.indexOf(obj);\r\n      if (i > -1) this._from.splice(i, 1);\r\n    }\r\n    return this;\r\n  };\r\n  MIDI.prototype._stamped = function(obj) {\r\n    if (obj._orig) obj = obj._orig;\r\n    for (var i = 0; i < this._from.length; i++) if (this._from[i] == obj) return true;\r\n    return false;\r\n  };\r\n\r\n  JZZ.MIDI = MIDI;\r\n  _J.prototype.MIDI = MIDI;\r\n\r\n  function _clear_ctxt() {\r\n    var i;\r\n    this._cc = [];\r\n    for (i = 0; i < 16; i++) this._cc[i] = {};\r\n  }\r\n  function _rpn_txt(msb, lsb) {\r\n    var a = typeof msb == 'undefined' ? '??' : __hex(msb);\r\n    var b = typeof lsb == 'undefined' ? '??' : __hex(lsb);\r\n    var c = {\r\n      '0000': 'Pitch Bend Sensitivity',\r\n      '0001': 'Channel Fine Tune',\r\n      '0002': 'Channel Coarse Tune',\r\n      '0003': 'Select Tuning Program',\r\n      '0004': 'Select Tuning Bank',\r\n      '0005': 'Vibrato Depth Range',\r\n      '7f7f': 'NONE'\r\n    }[a + '' + b];\r\n    return 'RPN ' + a + ' ' + b + (c ? ': ' + c : '');\r\n  }\r\n  function _nrpn_txt(msb, lsb) {\r\n    var a = typeof msb == 'undefined' ? '??' : __hex(msb);\r\n    var b = typeof lsb == 'undefined' ? '??' : __hex(lsb);\r\n    return 'NRPN ' + a + ' ' + b;\r\n  }\r\n  function _read_ctxt(msg) {\r\n    if (!msg.length || msg[0] < 0x80) return msg;\r\n    if (msg[0] == 0xff) { this._clear(); return msg; }\r\n    var ch = msg[0] & 15;\r\n    var st = msg[0] >> 4;\r\n    var s;\r\n    if (st == 12) {\r\n      msg._bm = this._cc[ch].bm;\r\n      msg._bl = this._cc[ch].bl;\r\n      if (JZZ.MIDI.programName) msg.label(JZZ.MIDI.programName(msg[1], msg._bm, msg._bl));\r\n    }\r\n    else if (st == 11) {\r\n      switch (msg[1]) {\r\n        case 0: this._cc[ch].bm = msg[2]; break;\r\n        case 32: this._cc[ch].bl = msg[2]; break;\r\n        case 98: this._cc[ch].nl = msg[2]; this._cc[ch].rn = 'n'; break;\r\n        case 99: this._cc[ch].nm = msg[2]; this._cc[ch].rn = 'n'; break;\r\n        case 100: this._cc[ch].rl = msg[2]; this._cc[ch].rn = 'r'; break;\r\n        case 101: this._cc[ch].rm = msg[2]; this._cc[ch].rn = 'r'; break;\r\n        case 6: case 38: case 96: case 97:\r\n          if (this._cc[ch].rn == 'r') {\r\n            msg._rm = this._cc[ch].rm;\r\n            msg._rl = this._cc[ch].rl;\r\n            msg.label(_rpn_txt(this._cc[ch].rm, this._cc[ch].rl));\r\n          }\r\n          if (this._cc[ch].rn == 'n') {\r\n            msg._nm = this._cc[ch].rm;\r\n            msg._nl = this._cc[ch].nl;\r\n            msg.label(_nrpn_txt(this._cc[ch].nm, this._cc[ch].nl));\r\n          }\r\n          break;\r\n      }\r\n    }\r\n    else if (msg.isFullSysEx()) {\r\n      if (msg[1] == 0x7f) {\r\n        if (msg[3] == 4) {\r\n          s = { 1: 'Master Volume', 2: 'Master Balance', 3: 'Master Fine Tuning', 4: 'Master Coarse Tuning' }[msg[4]];\r\n          if (s) msg.label(s);\r\n        }\r\n        else if (msg[3] == 8) {\r\n          s = { 2: 'Note Tuning', 7: 'Note Tuning, Bank', 8: 'Scale Tuning, 1 byte format', 9: 'Scale Tuning, 2 byte format' }[msg[4]];\r\n          if (s) msg.label(s);\r\n        }\r\n      }\r\n      else if (msg[1] == 0x7e) {\r\n        if (msg[3] == 6) {\r\n          if (msg[4] == 1) msg.label('Device ID Request');\r\n          else if (msg[4] == 2) {\r\n            msg.label('Device ID Response');\r\n          }\r\n        }\r\n        else if (msg[3] == 8) {\r\n          s = {\r\n            0: 'Bulk Tuning Dump Request', 1: 'Bulk Tuning Dump', 3: 'Bulk Tuning Dump Request, Bank', 4: 'Bulk Tuning Dump, Bank',\r\n            5: 'Scale Tuning Dump, 1 byte format', 6: 'Scale Tuning Dump, 2 byte format',\r\n            7: 'Note Tuning, Bank', 8: 'Scale Tuning, 1 byte format', 9: 'Scale Tuning, 2 byte format'\r\n          }[msg[4]];\r\n          if (s) msg.label(s);\r\n        }\r\n        else if (msg[3] == 9) {\r\n          if (msg[4] == 1) { msg.label('GM1 System On'); this._clear(); this._gm = '1'; }\r\n          else if (msg[4] == 2) { msg.label('GM System Off'); this._clear(); this._gm = '0'; }\r\n          else if (msg[4] == 3) { msg.label('GM2 System On'); this._clear(); this._gm = '2'; }\r\n        }\r\n      }\r\n      else if (msg[1] == 0x43) {\r\n        if ((msg[2] & 0xf0) == 0x10 && msg[3] == 0x4c) {\r\n          if (msg[4] == 0 && msg[5] == 0 && msg[6] == 0x7e && msg[7] == 0) {\r\n            msg.label('XG System On'); this._clear(); this._gm = 'Y';\r\n          }\r\n          else if (msg[4] == 0 && msg[5] == 0 && msg[6] == 0) msg.label('XG Master Tuning');\r\n          else if (msg[4] == 0 && msg[5] == 0 && msg[6] == 4) msg.label('XG Master Volume');\r\n          else if (msg[4] == 0 && msg[5] == 0 && msg[6] == 6) msg.label('XG Master Transpose');\r\n          else if (msg[4] == 8 && msg[5] < 16 && msg[6] >= 0x41 && msg[6] <= 0x4c) msg.label('XG Scale Tuning');\r\n          else  msg.label('XG Parameter');\r\n        }\r\n      }\r\n      else if (msg[1] == 0x41) {\r\n        if (msg[3] == 0x42 && msg[4] == 0x12) {\r\n          if (msg[5] == 0x40) {\r\n            if (msg[6] == 0) {\r\n              if (msg[7] == 0x7f && msg[8] == 0 && msg[9] == 0x41) {\r\n                msg.label('GS Reset'); this._clear(); this._gm = 'R';\r\n              }\r\n              else if (msg[7] == 0) msg.label('GS Master Tuning');\r\n              else if (msg[7] == 4) msg.label('GS Master Volume');\r\n              else if (msg[7] == 5) msg.label('GS Master Transpose');\r\n              else msg.label('GS Parameter');\r\n            }\r\n            else if ((msg[6] & 0xf0) == 0x10 && msg[7] == 0x15) msg.label('GS Drum Part Change');\r\n            else if ((msg[6] & 0xf0) == 0x10 && msg[7] >= 0x40 && msg[7] <= 0x4b) msg.label('GS Scale Tuning');\r\n            else msg.label('GS Parameter');\r\n          }\r\n          if (msg[5] == 0x41) msg.label('GS Parameter');\r\n        }\r\n      }\r\n    }\r\n    return msg;\r\n  }\r\n  function Context() {\r\n    var self = new _M();\r\n    self._clear = _clear_ctxt;\r\n    self._read = _read_ctxt;\r\n    self._receive = function(msg) { this._emit(this._read(msg)); };\r\n    self._clear();\r\n    self._resume();\r\n    return self;\r\n  }\r\n  JZZ.Context = Context;\r\n  _J.prototype.Context = Context;\r\n\r\n  function MPE() {\r\n    var self = this instanceof MPE ? this : self = new MPE();\r\n    self.reset();\r\n    if (arguments.length) MPE.prototype.setup.apply(self, arguments);\r\n    return self;\r\n  }\r\n  MPE.validate = function(arg) {\r\n    var a = arg instanceof Array ? arg : arguments;\r\n    if (a[0] != parseInt(a[0]) || a[0] < 0 || a[0] > 14) throw RangeError('Bad master channel value: ' + a[0]);\r\n    if (a[1] != parseInt(a[1]) || a[1] < 0 || a[0] + a[1] > 15) throw RangeError('Bad zone size value: ' + a[1]);\r\n  };\r\n  MPE.prototype.reset = function() { for (var n = 0; n < 16; n++) this[n] = { band: 0, master: n }; };\r\n  MPE.prototype.setup = function(m, n) {\r\n    MPE.validate(m, n);\r\n    var k;\r\n    var last = m + n;\r\n    if (this[m].master == m && this[m].band == n) return;\r\n    if (!n && !this[m].band) return;\r\n    if (this[m].band) {\r\n      k = m + this[m].band;\r\n      if (last < k) last = k;\r\n    }\r\n    else if (this[m].master == m - 1) {\r\n      k = m - 1;\r\n      k = k + this[k].band;\r\n      if (last < k) last = k;\r\n      this[m - 1] = { band: 0, master: m - 1 };\r\n    }\r\n    else if (this[m].master != m) {\r\n      k = this[m].master;\r\n      k = k + this[k].band;\r\n      if (last < k) last = k;\r\n      this[this[m].master].band = m - this[m].master - 1;\r\n    }\r\n    this[m].master = m;\r\n    this[m].band = n;\r\n    for (k = m + 1; k <= m + n; k++) {\r\n      if (this[k].band && last < k + this[k].band) last = k + this[k].band;\r\n      this[k] = { band: 0, master: m };\r\n    }\r\n    for (; k <= last; k++) this[k] = { band: 0, master: k };\r\n  };\r\n  MPE.prototype.filter = function(msg) {\r\n    var c = msg.getChannel();\r\n    if (!this[c] || !this[this[c].master].band) return msg;\r\n    var m = this[c].master;\r\n    var n = this[m].band;\r\n    var i, j, k;\r\n    if (typeof msg._mpe != 'undefined') {\r\n      k = 256;\r\n      for (i = m + 1; i <= m + n; i++) {\r\n        if (!this[i].notes) {\r\n          if (k > 0) { c = i; k = 0; }\r\n        }\r\n        else {\r\n          if (k > this[i].notes.length) { c = i; k = this[i].notes.length; }\r\n          for (j = 0; j < this[i].notes.length; j++) {\r\n            if (this[i].notes[j] == msg._mpe) { c = i; k = -1; break; }\r\n          }\r\n        }\r\n      }\r\n      msg.setChannel(c);\r\n      msg._mpe = undefined;\r\n    }\r\n    if (c == m) return msg; // bad mpe\r\n    if (msg.isNoteOn()) {\r\n      if (!this[c].notes) this[c].notes = [];\r\n      _push(this[c].notes, msg.getNote());\r\n    }\r\n    else if (msg.isNoteOff()) {\r\n      if (this[c].notes) _pop(this[c].notes, msg.getNote());\r\n    }\r\n    return msg;\r\n  };\r\n  JZZ.MPE = MPE;\r\n\r\n  JZZ.lib = {};\r\n  JZZ.lib.now = _now;\r\n  JZZ.lib.schedule = _schedule;\r\n  var _sch_list = [];\r\n  var _sch_worker;\r\n  var _sch_count = 0;\r\n  try {\r\n    var _blob = URL.createObjectURL(new Blob(['(', function() {\r\n      function tick() {\r\n        postMessage({});\r\n        setTimeout(tick, 0);\r\n      }\r\n      tick();\r\n    }.toString(), ')()'], { type: 'application/javascript' }));\r\n    var _sch_tick = function() {\r\n      var n = _sch_list.length;\r\n      // cannot use i < _sch_list.length !\r\n      for (var i = 0; i < n; i++) _sch_list.shift()();\r\n      _sch_count++;\r\n      if (_sch_count > 20 && _sch_worker) {\r\n        _sch_worker.terminate();\r\n        _sch_worker = undefined;\r\n      }\r\n    };\r\n    var _sch = function(x) {\r\n      _sch_list.push(x);\r\n      _sch_count = 0;\r\n      if (!_sch_worker) {\r\n        _sch_worker = new Worker(_blob);\r\n        _sch_worker.onmessage = _sch_tick;\r\n      }\r\n    };\r\n    _sch(function() { JZZ.lib.schedule = _sch; });\r\n  }\r\n  catch (e) {}\r\n\r\n  JZZ.lib.openMidiOut = function(name, engine) {\r\n    var port = new _M();\r\n    engine._openOut(port);\r\n    port._info = engine._info(name);\r\n    return port;\r\n  };\r\n  JZZ.lib.openMidiIn = function(name, engine) {\r\n    var port = new _M();\r\n    engine._openIn(port);\r\n    port._info = engine._info(name);\r\n    return port;\r\n  };\r\n  JZZ.lib.registerMidiOut = function(name, engine) {\r\n    var x = engine._info(name);\r\n    for (var i = 0; i < _virtual._outs.length; i++) if (_virtual._outs[i].name == x.name) return false;\r\n    x.engine = engine;\r\n    _virtual._outs.push(x);\r\n    if (_jzz) {\r\n      _postRefresh();\r\n      if (_jzz._bad) { _jzz._repair(); _jzz._resume(); }\r\n    }\r\n    return true;\r\n  };\r\n  JZZ.lib.registerMidiIn = function(name, engine) {\r\n    var x = engine._info(name);\r\n    for (var i = 0; i < _virtual._ins.length; i++) if (_virtual._ins[i].name == x.name) return false;\r\n    x.engine = engine;\r\n    _virtual._ins.push(x);\r\n    if (_jzz) {\r\n      _postRefresh();\r\n      if (_jzz._bad) { _jzz._repair(); _jzz._resume(); }\r\n    }\r\n    return true;\r\n  };\r\n  var _ac;\r\n  function _initAudioContext() {\r\n    if (!_ac && typeof window !== 'undefined') {\r\n      var AudioContext = window.AudioContext || window.webkitAudioContext;\r\n      if (AudioContext) {\r\n        _ac = new AudioContext();\r\n        if (_ac && !_ac.createGain) _ac.createGain = _ac.createGainNode;\r\n        var _activateAudioContext = function() {\r\n          if (_ac.state != 'running') {\r\n            _ac.resume();\r\n            var osc = _ac.createOscillator();\r\n            var gain = _ac.createGain();\r\n            try { gain.gain.value = 0; } catch (err) {}\r\n            gain.gain.setTargetAtTime(0, _ac.currentTime, 0.01);\r\n            osc.connect(gain);\r\n            gain.connect(_ac.destination);\r\n            if (!osc.start) osc.start = osc.noteOn;\r\n            if (!osc.stop) osc.stop = osc.noteOff;\r\n            osc.start(0.1); osc.stop(0.11);\r\n          }\r\n          else if (typeof document != 'undefined') {\r\n            document.removeEventListener('touchstart', _activateAudioContext);\r\n            document.removeEventListener('touchend', _activateAudioContext);\r\n            document.removeEventListener('mousedown', _activateAudioContext);\r\n            document.removeEventListener('keydown', _activateAudioContext);\r\n          }\r\n        };\r\n        if (typeof document != 'undefined') {\r\n          document.addEventListener('touchstart', _activateAudioContext);\r\n          document.addEventListener('touchend', _activateAudioContext);\r\n          document.addEventListener('mousedown', _activateAudioContext);\r\n          document.addEventListener('keydown', _activateAudioContext);\r\n        }\r\n        _activateAudioContext();\r\n      }\r\n    }\r\n  }\r\n  JZZ.lib.copyMidiHelpers = _copyMidiHelpers;\r\n  JZZ.lib.getAudioContext = function() { _initAudioContext(); return _ac; };\r\n  var _b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\r\n  JZZ.lib.fromBase64 = function(input) {\r\n    var output = '';\r\n    var chr1, chr2, chr3;\r\n    var enc1, enc2, enc3, enc4;\r\n    var i = 0;\r\n    input = input.replace(/[^A-Za-z0-9+/=]/g, '');\r\n    while (i < input.length) {\r\n      enc1 = _b64.indexOf(input.charAt(i++));\r\n      enc2 = _b64.indexOf(input.charAt(i++));\r\n      enc3 = _b64.indexOf(input.charAt(i++));\r\n      enc4 = _b64.indexOf(input.charAt(i++));\r\n      chr1 = (enc1 << 2) | (enc2 >> 4);\r\n      chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\r\n      chr3 = ((enc3 & 3) << 6) | enc4;\r\n      output = output + String.fromCharCode(chr1);\r\n      if (enc3 != 64) {\r\n        output = output + String.fromCharCode(chr2);\r\n      }\r\n      if (enc4 != 64) {\r\n        output = output + String.fromCharCode(chr3);\r\n      }\r\n    }\r\n    return output;\r\n  };\r\n  JZZ.lib.toBase64 = function(data) {\r\n    var o1, o2, o3, h1, h2, h3, h4, bits, i = 0, ac = 0, enc = '', arr = [];\r\n    if (!data) return data;\r\n    do {\r\n      o1 = data.charCodeAt(i++);\r\n      o2 = data.charCodeAt(i++);\r\n      o3 = data.charCodeAt(i++);\r\n      bits = o1 << 16 | o2 << 8 | o3;\r\n      h1 = bits >> 18 & 0x3f;\r\n      h2 = bits >> 12 & 0x3f;\r\n      h3 = bits >> 6 & 0x3f;\r\n      h4 = bits & 0x3f;\r\n      arr[ac++] = _b64.charAt(h1) + _b64.charAt(h2) + _b64.charAt(h3) + _b64.charAt(h4);\r\n    } while(i < data.length);\r\n    enc = arr.join('');\r\n    var r = data.length % 3;\r\n    return (r ? enc.slice(0, r - 3) + '==='.slice(r) : enc);\r\n  };\r\n  JZZ.lib.fromUTF8 = function(data) {\r\n    data = typeof data == 'undefined' ? '' : '' + data;\r\n    var out = '';\r\n    var i, n, m;\r\n    for (i = 0; i < data.length; i++) {\r\n      n = data.charCodeAt(i);\r\n      if (n > 0xff) return data;\r\n      if (n < 0x80) out += data[i];\r\n      else if ((n & 0xe0) == 0xc0) {\r\n        n = (n & 0x1f) << 6;\r\n        i++; if (i >= data.length) return data;\r\n        m = data.charCodeAt(i);\r\n        if ((m & 0xc0) != 0x80) return data;\r\n        n += (m & 0x3f);\r\n        out += String.fromCharCode(n);\r\n      }\r\n      else if ((n & 0xf0) == 0xe0) {\r\n        n = (n & 0x0f) << 12;\r\n        i++; if (i >= data.length) return data;\r\n        m = data.charCodeAt(i);\r\n        if ((m & 0xc0) != 0x80) return data;\r\n        n += (m & 0x3f) << 6;\r\n        i++; if (i >= data.length) return data;\r\n        m = data.charCodeAt(i);\r\n        if ((m & 0xc0) != 0x80) return data;\r\n        n += (m & 0x3f);\r\n        out += String.fromCharCode(n);\r\n      }\r\n      else if ((n & 0xf8) == 0xf0) {\r\n        n = (n & 0x07) << 18;\r\n        i++; if (i >= data.length) return data;\r\n        m = data.charCodeAt(i);\r\n        if ((m & 0xc0) != 0x80) return data;\r\n        n += (m & 0x3f) << 12;\r\n        i++; if (i >= data.length) return data;\r\n        m = data.charCodeAt(i);\r\n        if ((m & 0xc0) != 0x80) return data;\r\n        n += (m & 0x3f) << 6;\r\n        i++; if (i >= data.length) return data;\r\n        m = data.charCodeAt(i);\r\n        if ((m & 0xc0) != 0x80) return data;\r\n        n += (m & 0x3f);\r\n        if (n > 0x10ffff) return data;\r\n        n -= 0x10000;\r\n        out += String.fromCharCode(0xd800 + (n >> 10));\r\n        out += String.fromCharCode(0xdc00 + (n & 0x3ff));\r\n      }\r\n    }\r\n    return out;\r\n  };\r\n  JZZ.lib.toUTF8 = function(data) {\r\n    data = typeof data == 'undefined' ? '' : '' + data;\r\n    var out = '';\r\n    var i, n;\r\n    for (i = 0; i < data.length; i++) {\r\n      n = data.charCodeAt(i);\r\n      if (n < 0x80) out += data[i];\r\n      else if (n < 0x800) {\r\n        out += String.fromCharCode(0xc0 + (n >> 6));\r\n        out += String.fromCharCode(0x80 + (n & 0x3f));\r\n      }\r\n      else if (n < 0x10000) {\r\n        out += String.fromCharCode(0xe0 + (n >> 12));\r\n        out += String.fromCharCode(0x80 + ((n >> 6) & 0x3f));\r\n        out += String.fromCharCode(0x80 + (n & 0x3f));\r\n      }\r\n      /* istanbul ignore next */\r\n      else {\r\n        out += String.fromCharCode(0xf0 + (n >> 18));\r\n        out += String.fromCharCode(0x80 + ((n >> 12) & 0x3f));\r\n        out += String.fromCharCode(0x80 + ((n >> 6) & 0x3f));\r\n        out += String.fromCharCode(0x80 + (n & 0x3f));\r\n      }\r\n    }\r\n    return out;\r\n  };\r\n\r\n  // Web MIDI API\r\n  var _wma = [];\r\n  var _outputMap = {};\r\n  var _inputMap = {};\r\n\r\n  var Promise = _scope.Promise;\r\n  /* istanbul ignore next */\r\n  if (typeof Promise !== 'function') {\r\n    Promise = function(executor) {\r\n      this.executor = executor;\r\n    };\r\n    Promise.prototype.then = function(resolve, reject) {\r\n      if (typeof resolve !== 'function') {\r\n        resolve = _nop;\r\n      }\r\n      if (typeof reject !== 'function') {\r\n        reject = _nop;\r\n      }\r\n      this.executor(resolve, reject);\r\n    };\r\n  }\r\n  function DOMException(name, message, code) {\r\n    this.name = name;\r\n    this.message = message;\r\n    this.code = code;\r\n  }\r\n\r\n  function MIDIConnectionEvent(port, target) {\r\n    this.bubbles = false;\r\n    this.cancelBubble = false;\r\n    this.cancelable = false;\r\n    this.currentTarget = target;\r\n    this.defaultPrevented = false;\r\n    this.eventPhase = 0;\r\n    this.path = [];\r\n    this.port = port;\r\n    this.returnValue = true;\r\n    this.srcElement = target;\r\n    this.target = target;\r\n    this.timeStamp = _now();\r\n    this.type = 'statechange';\r\n  }\r\n\r\n  function MIDIMessageEvent(port, data) {\r\n    this.bubbles = false;\r\n    this.cancelBubble = false;\r\n    this.cancelable = false;\r\n    this.currentTarget = port;\r\n    this.data = data;\r\n    this.defaultPrevented = false;\r\n    this.eventPhase = 0;\r\n    this.path = [];\r\n    this.receivedTime = _now();\r\n    this.returnValue = true;\r\n    this.srcElement = port;\r\n    this.target = port;\r\n    this.timeStamp = this.receivedTime;\r\n    this.type = 'midimessage';\r\n  }\r\n\r\n  function _statechange(p, a) {\r\n    if (p) {\r\n      if (p.onstatechange) p.onstatechange(new MIDIConnectionEvent(p, p));\r\n      if (a.onstatechange) a.onstatechange(new MIDIConnectionEvent(p, a));\r\n    }\r\n  }\r\n\r\n  function MIDIInput(a, p) {\r\n    var self = this;\r\n    var _open = false;\r\n    var _ochng = null;\r\n    var _onmsg = null;\r\n    this.type = 'input';\r\n    this.id = p.id;\r\n    this.name = p.name;\r\n    this.manufacturer = p.man;\r\n    this.version = p.ver;\r\n    Object.defineProperty(this, 'state', { get: function() { return p.connected ? 'connected' : 'disconnected'; }, enumerable: true });\r\n    Object.defineProperty(this, 'connection', { get: function() {\r\n      return _open ? p.proxy ? 'open' : 'pending' : 'closed';\r\n    }, enumerable: true });\r\n    Object.defineProperty(this, 'onmidimessage', {\r\n      get: function() { return _onmsg; },\r\n      set: function(value) {\r\n        if (_func(value)) {\r\n          _onmsg = value;\r\n          if (!_open) self.open().then(_nop, _nop);\r\n        }\r\n        else _onmsg = null;\r\n      },\r\n      enumerable: true\r\n    });\r\n    Object.defineProperty(this, 'onstatechange', {\r\n      get: function() { return _ochng; },\r\n      set: function(value) {\r\n        if (_func(value)) _ochng = value;\r\n        else _ochng = null;\r\n      },\r\n      enumerable: true\r\n    });\r\n    this.open = function() {\r\n      return new Promise(function(resolve, reject) {\r\n        if (_open) resolve(self);\r\n        else {\r\n          p.open().then(function() {\r\n            if (!_open) {\r\n              _open = true;\r\n              _statechange(self, a);\r\n            }\r\n            resolve(self);\r\n          }, function() {\r\n            reject(new DOMException('InvalidAccessError', 'Port is not available', 15));\r\n          });\r\n        }\r\n      });\r\n    };\r\n    this.close = function() {\r\n      return new Promise(function(resolve/*, reject*/) {\r\n        if (_open) {\r\n          _open = false;\r\n          p.close();\r\n          _statechange(self, a);\r\n        }\r\n        resolve(self);\r\n      });\r\n    };\r\n    Object.freeze(this);\r\n  }\r\n\r\n  function _split(q) {\r\n    var i, k;\r\n    while (q.length) {\r\n      for (i = 0; i < q.length; i++) if (q[i] == parseInt(q[i]) && q[i] >= 0x80 && q[i] <= 0xff && q[i] != 0xf7) break;\r\n      q.splice(0, i);\r\n      if (!q.length) return;\r\n      if (q[0] == 0xf0) {\r\n        for (i = 1; i < q.length; i++) if (q[i] == 0xf7) break;\r\n        if (i == q.length) return;\r\n        return q.splice(0, i + 1);\r\n      }\r\n      else {\r\n        k = _datalen(q[0]) + 1;\r\n        if (k > q.length) return;\r\n        for (i = 1; i < k; i++) if (q[i] != parseInt(q[i]) || q[i] < 0 || q[i] >= 0x80) break;\r\n        if (i == k) return q.splice(0, i);\r\n        else q.splice(0, i);\r\n      }\r\n    }\r\n  }\r\n\r\n  function _InputProxy(id, name, man, ver) {\r\n    var self = this;\r\n    this.id = id;\r\n    this.name = name;\r\n    this.man = man;\r\n    this.ver = ver;\r\n    this.connected = true;\r\n    this.ports = [];\r\n    this.pending = [];\r\n    this.proxy = undefined;\r\n    this.queue = [];\r\n    this.onmidi = function(msg) {\r\n      var m;\r\n      self.queue = self.queue.concat(msg.slice());\r\n      for (m = _split(self.queue); m; m = _split(self.queue)) {\r\n        for (i = 0; i < self.ports.length; i++) {\r\n          if (self.ports[i][0].onmidimessage && (m[0] != 0xf0 || self.ports[i][1])) {\r\n            self.ports[i][0].onmidimessage(new MIDIMessageEvent(self, new Uint8Array(m)));\r\n          }\r\n        }\r\n      }\r\n    };\r\n  }\r\n  _InputProxy.prototype.open = function() {\r\n    var self = this;\r\n    return new Promise(function(resolve, reject) {\r\n      var i;\r\n      if (self.proxy || !self.connected) resolve();\r\n      else {\r\n        self.pending.push([resolve, reject]);\r\n        if (self.pending.length == 1) {\r\n          JZZ().openMidiIn(self.name).or(function() {\r\n            for (i = 0; i < self.pending.length; i++) self.pending[i][1]();\r\n            self.pending = [];\r\n          }).and(function() {\r\n            self.proxy = this;\r\n            self.proxy.connect(self.onmidi);\r\n            for (i = 0; i < self.pending.length; i++) self.pending[i][0]();\r\n            self.pending = [];\r\n          });\r\n        }\r\n      }\r\n    });\r\n  };\r\n  _InputProxy.prototype.close = function() {\r\n    var i;\r\n    if (this.proxy) {\r\n      for (i = 0; i < this.ports.length; i++) if (this.ports[i].connection == 'open') return;\r\n      this.proxy.close();\r\n      this.proxy = undefined;\r\n    }\r\n  };\r\n  _InputProxy.prototype.disconnect = function() {\r\n    this.connected = false;\r\n    if (this.proxy) {\r\n      this.proxy.close();\r\n      this.proxy = undefined;\r\n    }\r\n  };\r\n  _InputProxy.prototype.reconnect = function() {\r\n    var self = this;\r\n    var i, p;\r\n    var a = [];\r\n    this.connected = true;\r\n    for (i = 0; i < _wma.length; i++) {\r\n      p = _wma[i].inputs.get(this.id);\r\n      if (p.connection == 'closed') _statechange(p, _wma[i]);\r\n      else a.push([p, _wma[i]]);\r\n    }\r\n    if (a.length) {\r\n      JZZ()._openMidiInNR(self.name).or(function() {\r\n        for (i = 0; i < a.length; i++) a[i][0].close();\r\n      }).and(function() {\r\n        self.proxy = this;\r\n        self.proxy.connect(self.onmidi);\r\n        for (i = 0; i < a.length; i++) _statechange(a[i][0], a[i][1]);\r\n      });\r\n    }\r\n  };\r\n\r\n  function _datalen(x) {\r\n    if (x >= 0x80 && x <= 0xbf || x >= 0xe0 && x <= 0xef || x == 0xf2) return 2;\r\n    if (x >= 0xc0 && x <= 0xdf || x == 0xf1 || x == 0xf3) return 1;\r\n    return 0;\r\n  }\r\n\r\n  var _epr = \"Failed to execute 'send' on 'MIDIOutput': \";\r\n\r\n  function _validate(arr, sysex) {\r\n    var i, k;\r\n    var msg;\r\n    var data = [];\r\n    for (i = 0; i < arr.length; i++) {\r\n      if (arr[i] != parseInt(arr[i]) || arr[i] < 0 || arr[i] > 255) throw TypeError(_epr + arr[i] + ' is not a UInt8 value.');\r\n    }\r\n    k = 0;\r\n    for (i = 0; i < arr.length; i++) {\r\n      if (!k) {\r\n        if (arr[i] < 0x80) throw TypeError(_epr + 'Running status is not allowed at index ' + i + ' (' + arr[i] + ').');\r\n        if (arr[i] == 0xf7) throw TypeError(_epr + 'Unexpected end of system exclusive message at index ' + i + ' (' + arr[i] + ').');\r\n        msg = [arr[i]];\r\n        data.push(msg);\r\n        if (arr[i] == 0xf0) {\r\n          if (!sysex) throw new DOMException('InvalidAccessError', _epr + 'System exclusive messag is not allowed at index ' + i + ' (' + arr[i] + ').', 15);\r\n          k = -1;\r\n          for (; i < arr.length; i++) {\r\n            msg.push(arr[i]);\r\n            if (arr[i] == 0xf7) {\r\n              k = 0;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n        else {\r\n          k = _datalen(arr[i]);\r\n        }\r\n      }\r\n      else {\r\n        if (arr[i] > 0x7f) throw TypeError(_epr + 'Unexpected status byte at index ' + i + ' (' + arr[i] + ').');\r\n        msg.push(arr[i]);\r\n        k--;\r\n      }\r\n    }\r\n    if (k) throw TypeError(_epr + 'Message is incomplete');\r\n    return [data];\r\n  }\r\n\r\n  function MIDIOutput(a, p) {\r\n    var self = this;\r\n    var _open = false;\r\n    var _ochng = null;\r\n    this.type = 'output';\r\n    this.id = p.id;\r\n    this.name = p.name;\r\n    this.manufacturer = p.man;\r\n    this.version = p.ver;\r\n    Object.defineProperty(this, 'state', { get: function() { return p.connected ? 'connected' : 'disconnected'; }, enumerable: true });\r\n    Object.defineProperty(this, 'connection', { get: function() {\r\n      return _open ? p.proxy ? 'open' : 'pending' : 'closed';\r\n    }, enumerable: true });\r\n    Object.defineProperty(this, 'onstatechange', {\r\n      get: function() { return _ochng; },\r\n      set: function(value) {\r\n        if (_func(value)) _ochng = value;\r\n        else _ochng = null;\r\n      },\r\n      enumerable: true\r\n    });\r\n    this.open = function() {\r\n      return new Promise(function(resolve, reject) {\r\n        if (_open) resolve(self);\r\n        else {\r\n          p.open().then(function() {\r\n            if (!_open) {\r\n              _open = true;\r\n              _statechange(self, a);\r\n            }\r\n            resolve(self);\r\n          }, function() {\r\n            reject(new DOMException('InvalidAccessError', 'Port is not available', 15));\r\n          });\r\n        }\r\n      });\r\n    };\r\n    this.close = function() {\r\n      return new Promise(function(resolve/*, reject*/) {\r\n        if (_open) {\r\n          _open = false;\r\n          self.clear();\r\n          p.close();\r\n          _statechange(self, a);\r\n        }\r\n        resolve(self);\r\n      });\r\n    };\r\n    this.clear = function() {\r\n    };\r\n    this.send = function(data, timestamp) {\r\n      _validate(data, a.sysexEnabled);\r\n      if (!p.connected) throw new DOMException('InvalidStateError', 'Port is not connected', 11);\r\n      if (_open) {\r\n        var now = _now();\r\n        if (timestamp > now) setTimeout(function() { p.proxy.send(data); }, timestamp - now);\r\n        else p.proxy.send(data);\r\n      }\r\n      else this.open().then(function() { self.send(data, timestamp); }, _nop);\r\n    };\r\n    Object.freeze(this);\r\n  }\r\n\r\n  function _OutputProxy(id, name, man, ver) {\r\n    this.id = id;\r\n    this.name = name;\r\n    this.man = man;\r\n    this.ver = ver;\r\n    this.connected = true;\r\n    this.ports = [];\r\n    this.pending = [];\r\n    this.proxy = undefined;\r\n  }\r\n  _OutputProxy.prototype.open = function() {\r\n    var self = this;\r\n    return new Promise(function(resolve, reject) {\r\n      var i;\r\n      if (self.proxy || !self.connected) resolve();\r\n      else {\r\n        self.pending.push([resolve, reject]);\r\n        if (self.pending.length == 1) {\r\n          JZZ().openMidiOut(self.name).or(function() {\r\n            for (i = 0; i < self.pending.length; i++) self.pending[i][1]();\r\n            self.pending = [];\r\n          }).and(function() {\r\n            self.proxy = this;\r\n            for (i = 0; i < self.pending.length; i++) self.pending[i][0]();\r\n            self.pending = [];\r\n          });\r\n        }\r\n      }\r\n    });\r\n  };\r\n  _OutputProxy.prototype.close = function() {\r\n    var i;\r\n    if (this.proxy) {\r\n      for (i = 0; i < this.ports.length; i++) if (this.ports[i].connection == 'open') return;\r\n      this.proxy.close();\r\n      this.proxy = undefined;\r\n    }\r\n  };\r\n  _OutputProxy.prototype.disconnect = function() {\r\n    this.connected = false;\r\n    if (this.proxy) {\r\n      this.proxy.close();\r\n      this.proxy = undefined;\r\n    }\r\n  };\r\n  _OutputProxy.prototype.reconnect = function() {\r\n    var self = this;\r\n    var i, p;\r\n    var a = [];\r\n    this.connected = true;\r\n    for (i = 0; i < _wma.length; i++) {\r\n      p = _wma[i].outputs.get(this.id);\r\n      if (p.connection == 'closed') _statechange(p, _wma[i]);\r\n      else a.push([p, _wma[i]]);\r\n    }\r\n    if (a.length) {\r\n      JZZ()._openMidiOutNR(self.name).or(function() {\r\n        for (i = 0; i < a.length; i++) a[i][0].close();\r\n      }).and(function() {\r\n        self.proxy = this;\r\n        for (i = 0; i < a.length; i++) _statechange(a[i][0], a[i][1]);\r\n      });\r\n    }\r\n  };\r\n\r\n  function _Maplike(data) {\r\n    this.has = function(id) {\r\n      return data.hasOwnProperty(id) && data[id].connected;\r\n    };\r\n    this.keys = function() {\r\n      try { // some old browsers may have no Map object\r\n        var m = new Map();\r\n        for (var id in data) if (this.has(id)) m.set(id, this.get(id));\r\n        return m.keys();\r\n      } catch (e) {}\r\n    };\r\n    this.values = function() {\r\n      try {\r\n        var m = new Map();\r\n        for (var id in data) if (this.has(id)) m.set(id, this.get(id));\r\n        return m.values();\r\n      } catch (e) {}\r\n    };\r\n    this.entries = function() {\r\n      try {\r\n        var m = new Map();\r\n        for (var id in data) if (this.has(id)) m.set(id, this.get(id));\r\n        return m.entries();\r\n      } catch (e) {}\r\n    };\r\n    this.forEach = function(fun, self) {\r\n      if (typeof self == 'undefined') self = this;\r\n      for (var id in data) if (this.has(id)) fun.call(self, this.get(id), id, this);\r\n    };\r\n    Object.defineProperty(this, 'size', {\r\n      get: function() {\r\n        var len = 0;\r\n        for (var id in data) if (this.has(id)) len++;\r\n        return len;\r\n      },\r\n      enumerable: true\r\n    });\r\n  }\r\n\r\n  function MIDIInputMap(_access, _inputs) {\r\n    this.get = function(id) {\r\n      if (_inputMap.hasOwnProperty(id) && _inputMap[id].connected) {\r\n        if (!_inputs[id]) {\r\n          _inputs[id] = new MIDIInput(_access, _inputMap[id]);\r\n          _inputMap[id].ports.push([_inputs[id], _access.sysexEnabled]);\r\n        }\r\n        return _inputs[id];\r\n      }\r\n    };\r\n    Object.freeze(this);\r\n  }\r\n  MIDIInputMap.prototype = new _Maplike(_inputMap);\r\n  MIDIInputMap.prototype.constructor = MIDIInputMap;\r\n\r\n  function MIDIOutputMap(_access, _outputs) {\r\n    this.get = function(id) {\r\n      if (_outputMap.hasOwnProperty(id) && _outputMap[id].connected) {\r\n        if (!_outputs[id]) {\r\n          _outputs[id] = new MIDIOutput(_access, _outputMap[id]);\r\n          _outputMap[id].ports.push([_outputs[id], _access.sysexEnabled]);\r\n        }\r\n        return _outputs[id];\r\n      }\r\n    };\r\n    Object.freeze(this);\r\n  }\r\n  MIDIOutputMap.prototype = new _Maplike(_outputMap);\r\n  MIDIOutputMap.prototype.constructor = MIDIOutputMap;\r\n\r\n  function _wm_watch(x) {\r\n    var i, k, p, a;\r\n    for (i = 0; i < x.inputs.added.length; i++) {\r\n      p = x.inputs.added[i];\r\n      if (!_inputMap.hasOwnProperty(p.id)) _inputMap[p.id] = new _InputProxy(p.id, p.name, p.manufacturer, p.version);\r\n      _inputMap[p.id].reconnect();\r\n    }\r\n    for (i = 0; i < x.outputs.added.length; i++) {\r\n      p = x.outputs.added[i];\r\n      if (!_outputMap.hasOwnProperty(p.id)) _outputMap[p.id] = new _OutputProxy(p.id, p.name, p.manufacturer, p.version);\r\n      _outputMap[p.id].reconnect();\r\n    }\r\n    for (i = 0; i < x.inputs.removed.length; i++) {\r\n      p = x.inputs.removed[i];\r\n      if (_inputMap.hasOwnProperty(p.id)) {\r\n        a = [];\r\n        for (k = 0; k < _wma.length; k++) a.push([_wma[k].inputs.get(p.id), _wma[k]]);\r\n        _inputMap[p.id].disconnect();\r\n        for (k = 0; k < a.length; k++) _statechange(a[k][0], a[k][1]);\r\n      }\r\n    }\r\n    for (i = 0; i < x.outputs.removed.length; i++) {\r\n      p = x.outputs.removed[i];\r\n      if (_outputMap.hasOwnProperty(p.id)) {\r\n        a = [];\r\n        for (k = 0; k < _wma.length; k++) a.push([_wma[k].outputs.get(p.id), _wma[k]]);\r\n        _outputMap[p.id].disconnect();\r\n        for (k = 0; k < a.length; k++) _statechange(a[k][0], a[k][1]);\r\n      }\r\n    }\r\n  }\r\n\r\n  function MIDIAccess(sysex) {\r\n    var _inputs = {};\r\n    var _outputs = {};\r\n    var _onstatechange = null;\r\n    var self = this;\r\n    this.sysexEnabled = sysex;\r\n    this.inputs = new MIDIInputMap(self, _inputs);\r\n    this.outputs = new MIDIOutputMap(self, _outputs);\r\n    Object.defineProperty(this, 'onstatechange', {\r\n      get: function() { return _onstatechange; },\r\n      set: function(f) { _onstatechange = _func(f) ? f : null; },\r\n      enumerable: true\r\n    });\r\n    Object.freeze(this);\r\n    var i;\r\n    var p;\r\n    var info = _jzz._info;\r\n    for (i = 0; i < info.inputs.length; i++) {\r\n      p = info.inputs[i];\r\n      if (!_inputMap.hasOwnProperty(p.id)) _inputMap[p.id] = new _InputProxy(p.id, p.name, p.manufacturer, p.version);\r\n    }\r\n    for (i = 0; i < info.outputs.length; i++) {\r\n      p = info.outputs[i];\r\n      if (!_outputMap.hasOwnProperty(p.id)) _outputMap[p.id] = new _OutputProxy(p.id, p.name, p.manufacturer, p.version);\r\n    }\r\n    if (!_wma.length) JZZ().onChange(_wm_watch);\r\n    _wma.push(this);\r\n  }\r\n\r\n  JZZ.requestMIDIAccess = function(opt) {\r\n    return new Promise(function(resolve, reject) {\r\n      JZZ.JZZ(opt).or(function() {\r\n      }).and(function() {\r\n        var sysex = !!(opt && opt.sysex);\r\n        if (sysex && !this.info().sysex) reject(new DOMException('SecurityError', 'Sysex is not allowed', 18));\r\n        else {\r\n          var wma = new MIDIAccess(sysex);\r\n          resolve(wma);\r\n        }\r\n      });\r\n    });\r\n  };\r\n  if (typeof navigator !== 'undefined' && !navigator.requestMIDIAccess) navigator.requestMIDIAccess = JZZ.requestMIDIAccess;\r\n  JZZ.close = function() { if (_engine._close) _engine._close(); };\r\n\r\n  return JZZ;\r\n});\r\n\r\n//export {JZZ}\r\n\n\n//# sourceURL=webpack://Synthesizer/./src/js/JZZ.js?");

/***/ }),

/***/ "./src/js/Share.js":
/*!*************************!*\
  !*** ./src/js/Share.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MusicClip\": () => (/* binding */ MusicClip),\n/* harmony export */   \"MusicClipType\": () => (/* binding */ MusicClipType),\n/* harmony export */   \"MusicTrack\": () => (/* binding */ MusicTrack),\n/* harmony export */   \"SyntheysizerEvents\": () => (/* binding */ SyntheysizerEvents),\n/* harmony export */   \"TemplateClip\": () => (/* binding */ TemplateClip),\n/* harmony export */   \"VideoClip\": () => (/* binding */ VideoClip),\n/* harmony export */   \"dial_set\": () => (/* binding */ dial_set),\n/* harmony export */   \"joystick_set\": () => (/* binding */ joystick_set),\n/* harmony export */   \"note_set\": () => (/* binding */ note_set),\n/* harmony export */   \"pad_set\": () => (/* binding */ pad_set),\n/* harmony export */   \"poly_note_set\": () => (/* binding */ poly_note_set)\n/* harmony export */ });\nconst SyntheysizerEvents = window;\r\n\r\nconst note_set = {\r\n  pitch: 0,\r\n  note: 0,\r\n  value: 0\r\n};\r\nconst poly_note_set = {\r\n  pitch: [],\r\n  note : [],\r\n  value : []\r\n}\r\n\r\nconst pad_set = {\r\n  id: 0,\r\n  value: 0\r\n};\r\n\r\nconst dial_set = {\r\n  value: [[0.0, 0.0, 0.0, 0.0], \r\n          [0.0, 0.0, 0.0, 0.0]]  //순서대로  [21, 22, 23, 24]]\r\n}; \r\n\r\nconst joystick_set = {\r\n  value:[0, 0]\r\n};  \r\n\r\nconst MusicClipType = {\r\n  Mood: \"Mood\",\r\n  Melody: \"Melody\",\r\n  Beat: \"Beat\",\r\n  Lyrics:\"Lyrics\",\r\n  Template: \"Template\",\r\n  Total:\"Total\"\r\n}\r\n\r\nconst MusicNote = {\r\n  note:\"C0\",\r\n  intensity : 0.0,\r\n  start: 0.0,\r\n  end: -1.0\r\n}\r\nclass TemplateClip{\r\n  constructor(Clip_id, duration = 60, instrument = 0){\r\n    this.Clip_id = Clip_id;\r\n    this.duration = duration;\r\n    this.instrument = instrument;\r\n    this.dial_set = [[0.0, 0.0, 0.0, 0.0], \r\n                     [0.0, 0.0, 0.0, 0.0]]\r\n  }\r\n  set_dial(dial_set){\r\n    this.dial_set = dial_set\r\n  }\r\n  set_duration(duration){\r\n    this.duration = duration;\r\n  }\r\n  get_Clip_id(){\r\n    return this.Clip_id;\r\n  }\r\n  get_duration(){\r\n    return this.duration;\r\n  }\r\n  get_instrument(){\r\n    return this.instrument;\r\n  }\r\n  get_dial(){\r\n    return this.dial_set;\r\n  }\r\n}\r\n\r\nclass VideoObject{\r\n  constructor(videoId, videoData, videoDuration){{\r\n    this.videoId = videoId;\r\n    this.videoData = videoData;\r\n    this.videoDuration = videoDuration;\r\n  }}\r\n}\r\n\r\n\r\nclass VideoClip{\r\n  constructor (videoId = [], videoData = [], videoDuration = []){ \r\n    this.videoId = videoId;\r\n    this.videoData = videoData;\r\n    this.videoDuration = videoDuration;\r\n  }\r\n  setVideo(videoId, videoData, videoDuration){\r\n    this.videoId.push(videoId);\r\n    this.videoData.push(videoData);\r\n    this.videoDuration.push(videoDuration);\r\n  }\r\n  getVideoData(videoId){\r\n    if (videoId >= 0 && videoId < this.videoId.length){\r\n      // console.log(this.videoId)\r\n      // console.log(videoId)\r\n      // let index = this.videoId.indexOf(videoId);\r\n      // console.log(\"get id :\", videoId, \"index :\", index)\r\n      return this.videoData[videoId]\r\n    }\r\n    else{\r\n      console.log(\"Data index out of bounds\");\r\n      return null\r\n    }\r\n  }\r\n  getVideoDuration(videoId){\r\n    console.log(\"getVideoDuration\", videoId,  this.videoId.length);\r\n    if (videoId >= 0 && videoId < this.videoId.length){\r\n      // console.log(this.videoId)\r\n      // console.log(videoId)\r\n      // let index = this.videoId.indexOf(videoId);\r\n      // console.log(\"get id :\", videoId, \"index :\", index)\r\n      return this.videoDuration[videoId]\r\n    }\r\n    else{\r\n      console.log(\"Data index out of bounds\");\r\n      return null\r\n    }\r\n  }\r\n  getAllData(){\r\n    return [this.videoId, this.videoData, this.videoDuration]\r\n  }\r\n  get_newVideoId(){\r\n    return this.videoId.length;\r\n  }\r\n  checkIdIn(checkId){\r\n    return this.videoId.includes(checkId);\r\n  }\r\n}\r\n\r\nclass MusicClip {\r\n  constructor (Type, Clip_id, duration = 60, arraySet = [], timeSet = [], lyricSet = [], lyrictimeSet = [], lyricsVideoId = []) {\r\n      console.log(\"music Type : \", Type, \"Clip_id\", Clip_id,  \"duration\", duration);\r\n      this.Type = Type;\r\n      this.Clip_id = Clip_id;\r\n      this.duration = duration;\r\n      if(Type==MusicClipType.Melody){\r\n        this.melodyNoteSet = arraySet;\r\n        this.melodyTimeset = timeSet;\r\n        this.melodyNoteId = arraySet.length;\r\n\r\n        this.lyricSet = lyricSet;\r\n        this.lyrictimeSet = lyrictimeSet;\r\n        this.lyricId = lyricSet.length;\r\n        this.lyricsVideoId = lyricsVideoId\r\n      }\r\n      if(Type==MusicClipType.Beat){\r\n        this.beatSet = arraySet;\r\n        this.beatTime = timeSet;\r\n        this.beatSetId = arraySet.length;\r\n      }\r\n  }\r\n  setType(type){\r\n    this.Type = type;\r\n  }\r\n  setNoteInput(note, time) {\r\n    if(this.Type==MusicClipType.Melody){\r\n      this.melodyNoteSet.push(note);\r\n      this.melodyTimeset.push([time, -1]);\r\n      this.melodyNoteId +=1;\r\n    }\r\n    else{\r\n      alert(\"This Cilp type is Melody\");\r\n    }\r\n  }\r\n  setNoteRelease(note, time) {\r\n    if(this.Type==MusicClipType.Melody){\r\n      for (let i = this.melodyNoteSet.length - 1; i >= 0; i--) {\r\n        if (this.melodyNoteSet[i] === note) {\r\n          if(this.melodyTimeset[i][1] == -1){\r\n            this.melodyTimeset[i][1] = time;\r\n            break;\r\n          }\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    else{\r\n      alert(\"This Cilp type is Melody\");\r\n    }\r\n  }\r\n  setBeatInput(pad_id, time) {\r\n    if(this.Type==MusicClipType.Beat){\r\n      this.beatSet.push(pad_id);\r\n      this.beatTime.push(time);\r\n      this.beatSetId+=1;\r\n    }\r\n    else{\r\n      alert(\"This Clip type is Beat\");\r\n    }\r\n  }\r\n  setDuration(duration){\r\n    this.duration = duration;\r\n  }\r\n  setInstrument(instrument_id){\r\n    this.instrument_id = instrument_id;\r\n  }\r\n  setLyrics(lyric, timeset){\r\n    this.lyricSet.push(lyric);\r\n    this.lyrictimeSet.push(timeset);\r\n    this.lyricId += 1;\r\n    this.lyricsVideoId.push(-1);\r\n  }\r\n  setLyricsVideo(lyricsId, vidoeId){\r\n    this.lyricsVideoId[lyricsId] = vidoeId;\r\n  }\r\n  setAllLyrics(lyricSet, lyrictimeSet, lyricsVideoId){\r\n    this.lyricSet = lyricSet;\r\n    this.lyrictimeSet = lyrictimeSet;\r\n    this.lyricsVideoId = lyricsVideoId\r\n  }\r\n  editNote(noteIndex, deltaTimeset){\r\n    if(this.Type==MusicClipType.Melody){\r\n      this.melodyTimeset[noteIndex][0] += deltaTimeset[0];\r\n      this.melodyTimeset[noteIndex][1] += deltaTimeset[1];\r\n    }\r\n    else{\r\n      this.beatTime[noteIndex] += deltaTimeset[0];\r\n    }\r\n  }\r\n  editLyrics(lyricid, deltaTimeset){\r\n    if(this.Type==MusicClipType.Melody){\r\n      this.lyrictimeSet[lyricid][0] += deltaTimeset[0];\r\n      this.lyrictimeSet[lyricid][1] += deltaTimeset[1];\r\n    }\r\n  }\r\n  deleteNote(noteIndex){\r\n    if(this.Type==MusicClipType.Melody){\r\n      this.melodyNoteSet.splice(noteIndex,1);\r\n      this.melodyTimeset.splice(noteIndex,1);\r\n    }\r\n    else{\r\n      this.beatSet.splice(noteIndex,1);\r\n      this.beatTime.splice(noteIndex,1);\r\n    }\r\n  }\r\n  deletelyric(lyricId){\r\n    if(this.Type==MusicClipType.Melody){\r\n      //this.lyricSet.splice(lyricId,1);\r\n      //this.lyrictimeSet.splice(lyricId,1);\r\n      //this.lyricsVideoId.push(lyricId,1);\r\n      this.lyricSet[lyricId] = \"\";\r\n      this.lyrictimeSet[lyricId] = [0, 0];\r\n      this.lyricsVideoId[lyricId] = -1;\r\n    }\r\n  }\r\n  dleteAlllyric(){\r\n    if(this.Type==MusicClipType.Melody){\r\n      this.lyricSet =[];\r\n      this.lyrictimeSet=[];\r\n      this.lyricId = 0;\r\n      this.lyricsVideoId = [];\r\n    }\r\n  }\r\n  getClipLastTime(){\r\n    let lastTime = 1;\r\n    if(this.Type == MusicClipType.Melody){\r\n      for(let i=0; i<this.melodyTimeset.length; i++){\r\n        if(lastTime < this.melodyTimeset[i][1]){\r\n          lastTime = this.melodyTimeset[i][1]\r\n        }\r\n      }\r\n      for(let i=0; i<this.lyrictimeSet.length; i++){\r\n        if(lastTime < this.lyrictimeSet[i][1]){\r\n          lastTime = this.lyrictimeSet[i][1]\r\n        }\r\n      }\r\n      return lastTime\r\n    }\r\n    else{\r\n      for(let i=0; i<this.beatTime.length; i++){\r\n        if(lastTime < this.beatTime[i]){\r\n          lastTime = this.beatTime[i]\r\n        }\r\n      }\r\n      return lastTime\r\n    }\r\n  }\r\n  getLyricsVideoId(lyricsId){\r\n    return this.lyricsVideoId[lyricsId];\r\n  }\r\n  getClipId(){\r\n    return this.Clip_id;\r\n  }\r\n  getClipType(){\r\n    return this.Type;\r\n  }\r\n  getDuration(){\r\n    return parseFloat(this.duration);\r\n  }\r\n  getNoteIndex(){\r\n    if(this.Type==MusicClipType.Melody){\r\n      return this.melodyNoteId;\r\n    }\r\n    else{\r\n      return this.beatSetId;\r\n    }\r\n  }\r\n  getLyricsIndex(){\r\n    return this.lyricId;\r\n  }\r\n  getMusicClip(){\r\n    if(this.Type==MusicClipType.Melody){\r\n      return [this.melodyNoteSet, this.melodyTimeset]\r\n    }\r\n    else{\r\n      return [this.beatSet, this.beatTime]\r\n    }\r\n  }\r\n\r\n  getcurrentNoteSet(currentTime){\r\n    const noteSet = []\r\n    if(this.Type==MusicClipType.Melody){\r\n      //return [this.melodyNoteSet, this.melodyTimeset]\r\n      for (let i = 0; i < this.melodyTimeset.length; i++) {\r\n        if (this.melodyTimeset[i][0] <= currentTime && currentTime < this.melodyTimeset[i][1]) {\r\n          noteSet.push(this.melodyNoteSet[i]);\r\n        }\r\n      }\r\n      return noteSet;\r\n    }\r\n    else{\r\n      //return [this.beatSet, this.beatTime]\r\n      for (let i = 0; i < this.beatTime.length; i++) {\r\n        if (this.beatTime[i] - 1/60 <= currentTime && currentTime < this.beatTime[i] + 1/60) {\r\n          noteSet.push(this.beatSet[i]);\r\n        }\r\n      }\r\n      return noteSet;\r\n    }\r\n  }\r\n\r\n  getLyrics(currentTime){\r\n    //console.log(this.lyricSet, this.lyrictimeSet)\r\n    for (let i = 0; i < this.lyrictimeSet.length; i++) {\r\n      if (this.lyrictimeSet[i][0] <= currentTime && currentTime < this.lyrictimeSet[i][1]) {\r\n        return [this.lyricSet[i], i];\r\n      }\r\n    }\r\n    return [\"\", -1];\r\n  }\r\n  getLyricsTimeset(lyricsId){\r\n    if (lyricsId < this.lyrictimeSet.length && lyricsId >= 0 ){ \r\n      return [this.lyrictimeSet[lyricsId][0], this.lyrictimeSet[lyricsId][1]];\r\n    }\r\n    else{\r\n      return [null, null]\r\n    }\r\n  }\r\n  getLyricsLastTime(){\r\n    let lastTime = 0;\r\n    if(this.Type == MusicClipType.Melody){\r\n      for(let i=0; i<this.lyrictimeSet.length; i++){\r\n        if(lastTime < this.lyrictimeSet[i][1]){\r\n          lastTime = this.lyrictimeSet[i][1]\r\n        }\r\n      }\r\n    }\r\n    return lastTime\r\n  }\r\n  getLyricsText(lyricsId){\r\n    return this.lyricSet[lyricsId];\r\n  }\r\n  getAllLyrics(){\r\n    return [this.lyricSet, this.lyrictimeSet, this.lyricsVideoId];\r\n  }\r\n}\r\n\r\nclass MusicTrack{\r\n  constructor (userId = 0, id_set = [[],[],[]], time_set = [[], [], []]){\r\n    this.userId = userId;\r\n\r\n    this.TemplateIdClip = id_set[0];\r\n    this.MelodyClipIdList = id_set[1];\r\n    this.BeatClipIdList = id_set[2];\r\n\r\n    this.TemplateTimeset = time_set[0];\r\n    this.MelodyTimeset = time_set[1];\r\n    this.BeatTimeset = time_set[2];\r\n  }\r\n  setMusicClip(musicClip, clipTime){\r\n    if(musicClip.getClipType() == MusicClipType.Melody){\r\n      this.MelodyClipIdList.push(musicClip.getClipId());\r\n      let duration = parseFloat(musicClip.getDuration());\r\n      this.MelodyTimeset.push([clipTime, clipTime + duration]);\r\n      console.log(\"Add Melody box\", this.MelodyClipIdList);\r\n    }\r\n    else{\r\n      this.BeatClipIdList.push(musicClip.getClipId());\r\n      let duration = parseFloat(musicClip.getDuration());\r\n      this.BeatTimeset.push([clipTime, clipTime + duration]);\r\n      console.log(\"Add Beat box\", this.BeatClipIdList);\r\n    }\r\n  }\r\n  setTemplateClip(templateId, clipTime){  //지금 코드가 조금 꼬여서 임의로 Template은 30초 길이로 고정\r\n    this.TemplateIdClip.push(templateId);\r\n    this.TemplateTimeset.push([clipTime, clipTime + 30]);\r\n    console.log(\"Add Template box\", this.TemplateIdClip);\r\n  }\r\n  editMusicClip(type, clip_id, deltaTime){\r\n    if(type == MusicClipType.Melody){\r\n      this.MelodyTimeset[clip_id][0] += deltaTime;\r\n      this.MelodyTimeset[clip_id][1] += deltaTime;\r\n    }\r\n    else{\r\n      this.BeatTimeset[clip_id][0] += deltaTime;\r\n      this.BeatTimeset[clip_id][1] += deltaTime;\r\n    }\r\n  }\r\n  getTempalateId(){\r\n    return this.TemplateIdClip.length;\r\n  }\r\n  getMelodyId(){\r\n    return this.MelodyClipIdList.length;\r\n  }\r\n  getBeatId(){\r\n    return this.BeatClipIdList.length;\r\n  }\r\n  getcurrentClipSet(currentTime){\r\n    const Meldoy_set = []\r\n    const Beat_set = []\r\n    const Template_set = []\r\n    //console.log(this.BeatTimeset);\r\n    for (let i = 0; i < this.TemplateTimeset.length; i++) {\r\n      if (this.TemplateTimeset[i][0] <= currentTime && currentTime < this.TemplateTimeset[i][1]) {\r\n        Template_set.push(this.TemplateTimeset[i][0]);  // 시간이 먼저\r\n        Template_set.push(this.TemplateIdClip[i]);\r\n      }\r\n    }\r\n    for (let i = 0; i < this.MelodyTimeset.length; i++) {\r\n      if (this.MelodyTimeset[i][0] <= currentTime && currentTime < this.MelodyTimeset[i][1]) {\r\n        Meldoy_set.push(this.MelodyTimeset[i][0]);\r\n        Meldoy_set.push(this.MelodyClipIdList[i]);\r\n      }\r\n    }\r\n    for (let i = 0; i < this.BeatTimeset.length; i++) {\r\n      if (this.BeatTimeset[i][0] <= currentTime && currentTime < this.BeatTimeset[i][1]) {\r\n        Beat_set.push(this.BeatTimeset[i][0]);\r\n        Beat_set.push(this.BeatClipIdList[i]);\r\n      }\r\n    }\r\n    return [Template_set, Meldoy_set, Beat_set];  //순서는 항상 Template, Melody, Beat로 고정\r\n  }\r\n  getUserId(){\r\n    return this.userId;\r\n  }\r\n  getIdData(){\r\n    return [this.TemplateIdClip, this.MelodyClipIdList, this.BeatClipIdList]\r\n  }\r\n  getTimeData(){\r\n    return [this.TemplateTimeset, this.MelodyTimeset, this.BeatTimeset]\r\n  }\r\n  getTemplateSet(){\r\n    return [this.TemplateIdClip, this.TemplateTimeset]\r\n  }\r\n  getMelodySet(){\r\n    return [this.MelodyClipIdList, this.MelodyTimeset]\r\n  }\r\n  getBeatSet(){\r\n    return [this.BeatClipIdList, this.BeatTimeset]\r\n  }\r\n  deleteClip(clipType, clipIndex){\r\n    console.log(\"delete Track\", clipType, clipIndex);\r\n    if(clipType != null){\r\n      if(clipType == MusicClipType.Template){\r\n        this.TemplateIdClip.splice(clipIndex,1)\r\n        this.TemplateTimeset.splice(clipIndex,1)\r\n      }\r\n      else if(clipType == MusicClipType.Melody){\r\n        this.MelodyClipIdList.splice(clipIndex,1)\r\n        this.MelodyTimeset.splice(clipIndex,1)\r\n      }\r\n      else{\r\n        this.BeatClipIdList.splice(clipIndex,1)\r\n        this.BeatTimeset.splice(clipIndex,1)\r\n      }\r\n    }\r\n  }\r\n  getLastClipData(clipType){\r\n    if(clipType == MusicClipType.Melody){\r\n      let index = this.MelodyClipIdList.length-1\r\n      if(index != -1){\r\n        return [this.MelodyClipIdList[index], this.MelodyTimeset[index]]\r\n      }\r\n      else{\r\n        return [null, 0]\r\n      }\r\n    }\r\n    else if(clipType == MusicClipType.Beat){\r\n      let index = this.BeatClipIdList.length-1\r\n      if(index != -1){\r\n        return [this.BeatClipIdList[index], this.BeatTimeset[index]]\r\n      }\r\n      else{\r\n        return [null, 0]\r\n      }\r\n    }\r\n    else{\r\n      return [null, 0]\r\n    }\r\n  }\r\n  // setMusicClip(Melody_clip_array){  //Track의 Clip 정리 코드\r\n  //   const MaxId = Math.max.apply(null, this.MelodyClipIdList);\r\n  // }\r\n  // setBeatClip(Beat_clip_array){  //Track의 Clip 정리 코드\r\n  //   const MaxId = Math.max.apply(null, this.BeatClipIdList);\r\n  // }\r\n  // saveTrack(){\r\n  //   console.log(\"save the Music Track\");\r\n  // }\r\n}\n\n//# sourceURL=webpack://Synthesizer/./src/js/Share.js?");

/***/ }),

/***/ "./src/js/Synthesizer.js":
/*!*******************************!*\
  !*** ./src/js/Synthesizer.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"beat_output_play\": () => (/* binding */ beat_output_play),\n/* harmony export */   \"beat_player\": () => (/* binding */ beat_player),\n/* harmony export */   \"dialInitialize\": () => (/* binding */ dialInitialize),\n/* harmony export */   \"piano_player\": () => (/* binding */ piano_player)\n/* harmony export */ });\n/* harmony import */ var _JZZ_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./JZZ.js */ \"./src/js/JZZ.js\");\n/* harmony import */ var _JZZ_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_JZZ_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Share_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Share.js */ \"./src/js/Share.js\");\n/* harmony import */ var soundfont_player__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! soundfont-player */ \"../node_modules/soundfont-player/lib/index.js\");\n/* harmony import */ var soundfont_player__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(soundfont_player__WEBPACK_IMPORTED_MODULE_2__);\n\r\n\r\n\r\n\r\n\r\nlet noteType = [\r\n  \"C\",\r\n  \"C#\",\r\n  \"D\",\r\n  \"D#\",\r\n  \"E\",\r\n  \"F\",\r\n  \"F#\",\r\n  \"G\",\r\n  \"G#\",\r\n  \"A\",\r\n  \"A#\",\r\n  \"B\",\r\n];\r\nlet vector = { X: \"x\", Y: \"y\" };\r\n\r\nlet BeatHapticOn = true; //bpm-beat haptic 설정용 예비함수2 (서로 반대로 설정해야함)\r\n\r\n//AutiFilter >> 그냥 필터!\r\nconst filter = new Tone.Filter().toDestination();\r\nfilter.set({\r\n  frequency: \"C4\",\r\n  type: \"highpass\",\r\n});\r\n\r\nconst beatAudio1 = document.getElementById(\"beat1\");\r\nconst beatAudio2 = document.getElementById(\"beat2\");\r\nconst beatAudio3 = document.getElementById(\"beat3\");\r\nconst beatAudio4 = document.getElementById(\"beat4\");\r\n//AutoWah >> 울리는 효과\r\n// const autoWah = new Tone.AutoWah(50, 6, -30).toDestination();\r\n// autoWah.Q.value = 6;\r\n\r\n//BitCrusher >> 찢어지는 듯한 효과\r\n// const crusher = new Tone.BitCrusher(4).toDestination();\r\n\r\n//Chebyshev >> 고양이 소리?\r\n// const cheby = new Tone.Chebyshev(50).toDestination();\r\n\r\n//Chorus >> 동시에 누를 때 확인\r\n// const chorus = new Tone.Chorus(4, 2.5, 0.5).toDestination().start();\r\n\r\n//Distortion >> 음이 더 늘어지는 효과\r\n//const dist = new Tone.Distortion(1.5).toDestination();\r\n\r\n//FeedbackDelay >> delay랑 코러스 효과음?\r\n// const feedbackDelay = new Tone.FeedbackDelay(\"8n\", 0.5).toDestination();\r\n\r\n//Freeverb >> 먹먹해지는 효과?\r\n// const freeverb = new Tone.Freeverb().toDestination();\r\n// freeverb.dampening = 1000;\r\n\r\n//JCReverb >> 두 음이 울리는 느낌?\r\n//const reverb = new Tone.JCReverb(0.4).toDestination();\r\nconst delay = new Tone.FeedbackDelay(0.5).toDestination();\r\n//const synth = new Tone.Synth().chain(delay, reverb);\r\n\r\n//Phaser >> 잡음이 섞이는 느낌\r\n// const phaser = new Tone.Phaser({\r\n// \tfrequency: 150,\r\n// \toctaves: 10,\r\n// \tbaseFrequency: 1000\r\n// }).toDestination();\r\n\r\n// //PingPonDelay >> 탁구공이 튀는 느낌으로 점점 음이 생기는 느낌\r\n// const pingPong = new Tone.PingPongDelay(\"4n\", 0.2).toDestination();\r\n\r\n// const vibrato = new Tone.Vibrato(5, 0.1).toDestination();\r\n\r\n// let autoWah = new Tone.AutoWah(50, 6, -30).toDestination();\r\n// let crusher = new Tone.BitCrusher(4).toDestination();\r\n// let cheby = new Tone.Chebyshev(50).toDestination();\r\n// let chorus = new Tone.Chorus(5, 2.5, 0.5).toDestination();\r\n// let feedbackDelay = new Tone.FeedbackDelay(\"8n\", 0.5).toDestination();\r\n// let freeverb = new Tone.Freeverb().toDestination();\r\n// let phaser = new Tone.Phaser({\r\n//   frequency: 150,\r\n//   octaves: 10,\r\n//   baseFrequency: 1000\r\n// }).toDestination();\r\n// let vibrato = new Tone.Vibrato(5, 0.1).toDestination();\r\nlet dial_bool = [false, false, false, false, false, false, false, false];\r\n\r\n// const synth = new Tone.Synth().chain(chorus).toDestination();\r\n// const AMsynth = new Tone.AMSynth().toDestination();\r\n// const duoSynth = new Tone.DuoSynth().toDestination();\r\n// const fmSynth = new Tone.FMSynth().toDestination();\r\n// const MembraneSynth = new Tone.MembraneSynth().toDestination();\r\n// const plucky = new Tone.PluckSynth().toDestination();\r\n\r\nlet polySynth = new Tone.PolySynth().toDestination();\r\nconst audioContext = new (window.AudioContext || window.webkitAudioContext)(); //soundfont\r\n//polySynth.set({ detune: -1200 });\r\nlet synth; // SoundFont 신시사이저\r\n\r\nsoundfont_player__WEBPACK_IMPORTED_MODULE_2___default().instrument(audioContext, \"acoustic_grand_piano\").then(\r\n  (instrument) => {\r\n    synth = instrument;\r\n  }\r\n);\r\n\r\n// const MonoSynth = new Tone.MonoSynth({\r\n// \toscillator: {\r\n// \t\ttype: \"square\"\r\n// \t},\r\n// \tenvelope: {\r\n// \t\tattack: 0.1\r\n// \t}\r\n// }).toDestination();\r\n\r\n// const sampler = new Tone.Sampler({\r\n// \turls: {\r\n// \t\tA1: \"A1.mp3\",\r\n// \t\tA2: \"A2.mp3\",\r\n// \t},\r\n// \t//baseUrl: \"https://tonejs.github.io/audio/salamander/\",\r\n//   baseUrl: \"https://tonejs.github.io/audio/casio/\",\r\n//   attack: 1,\r\n//   release: 0,\r\n// }).toDestination();\r\n\r\n//sampler.connect(pingPong)\r\n\r\n// Beat\r\n//const MetalSynth = new Tone.MetalSynth().toDestination();\r\n//const noiseSynth = new Tone.NoiseSynth().toDestination();\r\ndocument\r\n  .getElementById(\"synthInitialize\")\r\n  .addEventListener(\"click\", function () {\r\n    polySynth = new Tone.PolySynth().toDestination();\r\n    polySynth.set({ detune: -1200 });\r\n  });\r\n\r\nfunction set_synthesiser(msg) {\r\n  let synthesiser_msg = get_msg_input(msg);\r\n  switch (synthesiser_msg.input_type) {\r\n    case \"90\": //Press the piano keys\r\n      piano_key_input(synthesiser_msg.input_id, synthesiser_msg.input_value);\r\n      break;\r\n    case \"80\": //Release the piano keys\r\n      piano_key_release(synthesiser_msg.input_id);\r\n      break;\r\n    case \"99\": //tap the touch pad\r\n      pad_input(synthesiser_msg.input_id, synthesiser_msg.input_value);\r\n      break;\r\n    case \"89\": //Release the touch pad\r\n      pad_output(synthesiser_msg.input_id);\r\n      break;\r\n    case \"b0\": //Moving the dial or Moving the joystick(up,down)\r\n      if (synthesiser_msg.input_id != 1) {\r\n        dial_input(synthesiser_msg.input_id, synthesiser_msg.input_value);\r\n      } else {\r\n        joystick_input(\r\n          synthesiser_msg.input_id,\r\n          synthesiser_msg.input_value,\r\n          vector.Y\r\n        );\r\n      }\r\n      break;\r\n    case \"e0\": //Moving the joystick(left, right)\r\n      joystick_input(\r\n        synthesiser_msg.input_id,\r\n        synthesiser_msg.input_value,\r\n        vector.X\r\n      );\r\n      break;\r\n    case \"d9\": //Press the touch pad\r\n      break;\r\n    default:\r\n      break;\r\n  }\r\n}\r\n\r\nfunction get_msg_input(msg) {\r\n  // output list : [input_type, input_id, input_value, bool(OnOff)]\r\n  return {\r\n    input_type: msg.substr(0, 2),\r\n    input_id: parseInt(msg.substr(3, 2), 16),\r\n    input_value: parseInt(msg.substr(6, 2), 16),\r\n  };\r\n}\r\nfunction piano_player(input_note, attackRelase, value = 127) {\r\n  if (attackRelase) {\r\n    // polySynth.triggerAttack(input_note);\r\n    synth.play(input_note, audioContext.currentTime, { gain: value / 127 });\r\n    _Share_js__WEBPACK_IMPORTED_MODULE_1__.note_set.pitch = note2Pitch(input_note); //output : 0 ~ 127\r\n    _Share_js__WEBPACK_IMPORTED_MODULE_1__.note_set.note = input_note; //output : C0 ~ B7\r\n    _Share_js__WEBPACK_IMPORTED_MODULE_1__.note_set.value = value; //output : 0 ~ 127\r\n    const event = new CustomEvent(\"noteInput\", { detail: _Share_js__WEBPACK_IMPORTED_MODULE_1__.note_set });\r\n    _Share_js__WEBPACK_IMPORTED_MODULE_1__.SyntheysizerEvents.dispatchEvent(event);\r\n  } else {\r\n    // polySynth.triggerRelease(input_note);\r\n    // synth.stop(input_note);\r\n    _Share_js__WEBPACK_IMPORTED_MODULE_1__.note_set.pitch = note2Pitch(input_note); //output : 0 ~ 127\r\n    _Share_js__WEBPACK_IMPORTED_MODULE_1__.note_set.note = input_note; //output : C0 ~ B7\r\n    const event = new CustomEvent(\"noteRelease\", { detail: _Share_js__WEBPACK_IMPORTED_MODULE_1__.note_set });\r\n    _Share_js__WEBPACK_IMPORTED_MODULE_1__.SyntheysizerEvents.dispatchEvent(event);\r\n  }\r\n}\r\nfunction note2Pitch(input_note) {\r\n  //console.log(\"input\", input_note.slice(0,-1), input_note.slice(-1));\r\n  let num = noteType.findIndex((num) => num == input_note.slice(0, 1));\r\n  return num + noteType.length * parseInt(input_note.slice(-1));\r\n}\r\nfunction pitch2Note(input_pitch) {\r\n  return noteType[input_pitch % 12] + String(parseInt(input_pitch / 12));\r\n}\r\n\r\nfunction piano_key_input(input_id, input_value) {\r\n  let input_note = pitch2Note(input_id);\r\n  piano_player(input_note, true);\r\n  _Share_js__WEBPACK_IMPORTED_MODULE_1__.note_set.pitch = input_id; //output : 0 ~ 127\r\n  _Share_js__WEBPACK_IMPORTED_MODULE_1__.note_set.note = input_note; //output : C0 ~ B7\r\n  _Share_js__WEBPACK_IMPORTED_MODULE_1__.note_set.value = input_value; //output : 0 ~ 127\r\n  const event = new CustomEvent(\"pianoKeyInput\", { detail: _Share_js__WEBPACK_IMPORTED_MODULE_1__.note_set });\r\n  _Share_js__WEBPACK_IMPORTED_MODULE_1__.SyntheysizerEvents.dispatchEvent(event);\r\n}\r\n\r\nfunction piano_key_release(input_id) {\r\n  let input_note = pitch2Note(input_id);\r\n  piano_player(input_note, false);\r\n  _Share_js__WEBPACK_IMPORTED_MODULE_1__.note_set.pitch = input_id; //output : 0 ~ 127\r\n  _Share_js__WEBPACK_IMPORTED_MODULE_1__.note_set.note = input_note; //output : C0 ~ B7\r\n  const event = new CustomEvent(\"pianoKeyOutput\", { detail: _Share_js__WEBPACK_IMPORTED_MODULE_1__.note_set });\r\n  _Share_js__WEBPACK_IMPORTED_MODULE_1__.SyntheysizerEvents.dispatchEvent(event);\r\n}\r\nfunction restartAudio(audioElement) {\r\n  audioElement.currentTime = 0; // 재생 위치를 0으로 설정\r\n  audioElement.play(); // 오디오 재생 시작\r\n}\r\nfunction beat_player(input_id) {\r\n  _Share_js__WEBPACK_IMPORTED_MODULE_1__.pad_set.id = input_id;\r\n  const event = new CustomEvent(\"padInput\", { detail: _Share_js__WEBPACK_IMPORTED_MODULE_1__.pad_set });\r\n  _Share_js__WEBPACK_IMPORTED_MODULE_1__.SyntheysizerEvents.dispatchEvent(event);\r\n  //console.log(\"tap Check\");\r\n  switch (input_id) {\r\n    case 0:\r\n      restartAudio(beatAudio1);\r\n      if (!document.getElementById(\"hapticType\").checked) {\r\n        document.getElementById(\"HapticPlayButton1\").click();\r\n      }\r\n      break;\r\n    case 1:\r\n      restartAudio(beatAudio2);\r\n      if (!document.getElementById(\"hapticType\").checked) {\r\n        document.getElementById(\"HapticPlayButton2\").click();\r\n      }\r\n      break;\r\n    case 2:\r\n      restartAudio(beatAudio3);\r\n      if (!document.getElementById(\"hapticType\").checked) {\r\n        document.getElementById(\"HapticPlayButton3\").click();\r\n      }\r\n      break;\r\n    case 3:\r\n      restartAudio(beatAudio4);\r\n      if (!document.getElementById(\"hapticType\").checked) {\r\n        document.getElementById(\"HapticPlayButton4\").click();\r\n      }\r\n      break;\r\n    default:\r\n      break;\r\n  }\r\n}\r\nfunction beat_output_play(input_id) {\r\n  _Share_js__WEBPACK_IMPORTED_MODULE_1__.pad_set.id = input_id;\r\n  const event = new CustomEvent(\"padOutput\", { detail: _Share_js__WEBPACK_IMPORTED_MODULE_1__.pad_set });\r\n  _Share_js__WEBPACK_IMPORTED_MODULE_1__.SyntheysizerEvents.dispatchEvent(event);\r\n}\r\n\r\nfunction pad_input(input_id) {\r\n  _Share_js__WEBPACK_IMPORTED_MODULE_1__.pad_set.id = input_id - 36;\r\n  beat_player(input_id - 36);\r\n  const event = new CustomEvent(\"padkeyInput\", { detail: _Share_js__WEBPACK_IMPORTED_MODULE_1__.pad_set });\r\n  _Share_js__WEBPACK_IMPORTED_MODULE_1__.SyntheysizerEvents.dispatchEvent(event);\r\n}\r\nfunction pad_output(input_id) {\r\n  beat_output_play(input_id - 36);\r\n}\r\n_Share_js__WEBPACK_IMPORTED_MODULE_1__.SyntheysizerEvents.addEventListener(\"templateLoad\", function (e) {\r\n  // console.log(\"In Circle note: \", e.detail.value); //범위가 0~127입니다.\r\n  _Share_js__WEBPACK_IMPORTED_MODULE_1__.dial_set.value = e.detail;\r\n  //console.log(\"set chnaged\", dial_set);\r\n  const event = new CustomEvent(\"dialInput\", { detail: _Share_js__WEBPACK_IMPORTED_MODULE_1__.dial_set });\r\n  _Share_js__WEBPACK_IMPORTED_MODULE_1__.SyntheysizerEvents.dispatchEvent(event);\r\n  //console.log(dial_set);\r\n  //for(let i = 70; i < 78; i++){\r\n  //  dial_effect(i, dial_set.value[parseInt((i-70)/4)][(i-70)%4]);\r\n  //}\r\n});\r\n\r\nfunction dialInitialize() {\r\n  _Share_js__WEBPACK_IMPORTED_MODULE_1__.dial_set.value = [\r\n    [0.0, 0.0, 0.0, 0.0],\r\n    [0.0, 0.0, 0.0, 0.0],\r\n  ];\r\n  const event = new CustomEvent(\"dialInput\", { detail: _Share_js__WEBPACK_IMPORTED_MODULE_1__.dial_set });\r\n  _Share_js__WEBPACK_IMPORTED_MODULE_1__.SyntheysizerEvents.dispatchEvent(event);\r\n  //for(let i = 70; i < 78; i++){\r\n  //  dial_effect(i, 0);\r\n  //}\r\n}\r\nfunction dial_input(input_id, input_value) {\r\n  //console.log(\"dial_input\", input_id, );\r\n  if (input_id > 69) {\r\n    //there are except case in joystick\r\n    _Share_js__WEBPACK_IMPORTED_MODULE_1__.dial_set.value[parseInt((input_id - 70) / 4)][(input_id - 70) % 4] =\r\n      input_value;\r\n    const event = new CustomEvent(\"dialInput\", { detail: _Share_js__WEBPACK_IMPORTED_MODULE_1__.dial_set });\r\n    _Share_js__WEBPACK_IMPORTED_MODULE_1__.SyntheysizerEvents.dispatchEvent(event);\r\n    //dial_effect(input_id, input_value);\r\n  }\r\n}\r\n\r\nfunction Normaizing(input_value, minmaxList) {\r\n  return (\r\n    minmaxList[0] +\r\n    (minmaxList[1] - minmaxList[0]) * ((input_value - 10) / (127 - 10))\r\n  );\r\n}\r\n\r\nfunction dial_effect(input_id, input_value) {\r\n  switch (input_id) {\r\n    case 70:\r\n      console.log(\"feedbackDelay\", input_value);\r\n      if (dial_bool[0]) {\r\n        console.log(\"feedbackDelay disconnect\");\r\n        polySynth.disconnect(feedbackDelay);\r\n        dial_bool[0] = false;\r\n      }\r\n      if (input_value > 10) {\r\n        // console.log(\"connect\");\r\n        //feedbackDelay = new Tone.FeedbackDelay(\"8n\", Normaizing(input_value, [0, 0.8])).toDestination();\r\n        //feedbackDelay.feedback.value = Normaizing(input_value, [0, 0.5]);\r\n        //polySynth.connect(feedbackDelay);\r\n        //dial_bool[0] = true;\r\n      }\r\n      break;\r\n    case 71:\r\n      console.log(\"crusher\", input_value);\r\n      if (dial_bool[1]) {\r\n        console.log(\"crusher disconnect\");\r\n        polySynth.disconnect(crusher);\r\n        dial_bool[1] = false;\r\n      }\r\n      if (input_value > 10) {\r\n        // console.log(\"connect\");\r\n        //crusher.bits.value = 9 - parseInt(Normaizing(input_value, [1, 3]));\r\n        //polySynth.connect(crusher);\r\n        //dial_bool[1] = true;\r\n      }\r\n      break;\r\n    case 72:\r\n      console.log(\"cheby\", input_value);\r\n      if (dial_bool[2]) {\r\n        console.log(\"cheby disconnect\");\r\n        polySynth.disconnect(cheby);\r\n        dial_bool[2] = false;\r\n      }\r\n      if (input_value > 10) {\r\n        // console.log(\"connect\");\r\n        //cheby.order = parseInt(Normaizing(input_value, [1, 20]));\r\n        //polySynth.connect(cheby);\r\n        //dial_bool[2] = true;\r\n      }\r\n      break;\r\n    case 73:\r\n      console.log(\"chorus\", input_value);\r\n      if (dial_bool[3]) {\r\n        console.log(\"chorus disconnect\");\r\n        polySynth.disconnect(chorus);\r\n        dial_bool[3] = false;\r\n      }\r\n      if (input_value > 10) {\r\n        // console.log(\"connect\");\r\n        //chorus = new Tone.Chorus(Normaizing(input_value, [1, 10]), 2.5, 0.5).toDestination();\r\n        chorus.frequency.value = Normaizing(input_value, [1, 7]);\r\n        polySynth.connect(chorus);\r\n        dial_bool[3] = true;\r\n      }\r\n      break;\r\n    default:\r\n      break;\r\n  }\r\n}\r\n\r\nfunction joystick_input(input_id, input_value, type) {\r\n  if (type == vector.X) {\r\n    //console.log(type, input_value - 64)\r\n    _Share_js__WEBPACK_IMPORTED_MODULE_1__.joystick_set.value[0] = input_value - 64;\r\n    const event = new CustomEvent(\"joystickInpnut\", { detail: _Share_js__WEBPACK_IMPORTED_MODULE_1__.joystick_set });\r\n    _Share_js__WEBPACK_IMPORTED_MODULE_1__.SyntheysizerEvents.dispatchEvent(event);\r\n  } else {\r\n    //console.log(type, parseInt(input_value/2))\r\n    _Share_js__WEBPACK_IMPORTED_MODULE_1__.joystick_set.value[1] = parseInt(input_value / 2);\r\n    const event = new CustomEvent(\"joystickInpnut\", { detail: _Share_js__WEBPACK_IMPORTED_MODULE_1__.joystick_set });\r\n    _Share_js__WEBPACK_IMPORTED_MODULE_1__.SyntheysizerEvents.dispatchEvent(event);\r\n  }\r\n}\r\n\r\n// MIDI Device Detect code\r\nvar midi_in;\r\nlet open_midi = document.querySelector('[data-action=\"open_midi_in\"]');\r\nopen_midi.addEventListener(\"click\", (event) => {\r\n  midi_in = (0,_JZZ_js__WEBPACK_IMPORTED_MODULE_0__.JZZ)()\r\n    .openMidiIn()\r\n    .or(function () {\r\n      document.getElementById(\"midiInName\").innerHTML = \"Cannot open!\";\r\n    })\r\n    .and(function () {\r\n      document.getElementById(\"midiInName\").innerHTML = this.name();\r\n      console.log(this.info());\r\n    })\r\n    .connect(function (msg) {\r\n      set_synthesiser(msg.toString());\r\n    });\r\n});\r\n\r\nlet close_midi = document.querySelector('[data-action=\"close_midi_in\"]');\r\nclose_midi.addEventListener(\"click\", (event) => {\r\n  if (midi_in) {\r\n    midi_in.close();\r\n    midi_in = undefined;\r\n    document.getElementById(\"midiInName\").innerHTML = \"closed\";\r\n  }\r\n});\r\n\n\n//# sourceURL=webpack://Synthesizer/./src/js/Synthesizer.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/Synthesizer.js");
/******/ 	
/******/ })()
;